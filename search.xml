<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TopCoder SRM664DIV1A: BearPlays 题解]]></title>
    <url>%2Fblog%2Ftcsrm664div1a%2F</url>
    <content type="text"><![CDATA[Problem StatementLimak is a little bear who loves to play. Today he is playing by moving some stones between two piles of stones. Initially, one of the piles has A and the other has B stones in it. Limak has decided to perform a sequence of K operations. In each operation he will double the size of the currently smaller pile. Formally, if the current pile sizes are labeled X and Y in such a way that X &lt;= Y, he will move X stones from the second pile to the first one. After this move the new pile sizes will be X+X and Y-X. You are given the ints A, B, and K. Determine the pile sizes after Limak finishes all his operations. Return the size of the smaller of those piles. Formally, suppose that the final pile sizes are labeled P and Q in such a way that P &lt;= Q. Return P. DefinitionClass: BearPlays Method: pileSize Parameters: int, int, int Returns: int Method signature: int pileSize(int A, int B, int K)(be sure your method is public) Notes Pay attention to the unusual time limit. Constraints A and B will be between 1 and 1,000,000,000, inclusive. K will be between 1 and 2,000,000,000, inclusive. Examples0) 4 7 2 Returns: 5 The process will look as follows: Initially, the pile sizes are 4 and 7. First operation: Limak doubles the pile of size 4 by moving 4 stones from the other pile to this pile. The new pile sizes are 8 and 3. Second operation: Limak doubles the pile of size 3. The final pile sizes are 5 and 6. As 5 &lt;= 6, the correct return value is 5. 1) 5 5 3 Returns: 0 The initial pile sizes are 5 and 5. In the first operation Limak will double one of them, so after the operation the new pile sizes will be 10 and 0. The second and third operation do nothing: in each of them Limak doubles the size of an empty pile. As 0 ≤ 10, the correct return value is 0. 2) 2 6 1 Returns: 4 After the only operation the pile sizes will be 4 and 4, hence the correct return value is 4. 3) 2 8 2000000000 Returns: 2 4) 900000000 350000000 3 Returns: 300000000 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution数学神思维题 首先的性质是$x+y$的和不会变，设$x+y=n$ 考虑如果当前$x\leq y$,则$x=2x$ 如果当前$x\ge y$,则$x=x-y=2x-(x+y)=2x-n\equiv 2x(mod$ &nbsp; $n)$ 综上，进行$k$轮之后,$x\equiv x*2^k(mod$ &nbsp; $n)$ 所以算出这个，返回$min(x,n-x)$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;class BearPlays&#123; int n; inline int quick_pow(int x,int y) &#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%n,y--; x=(1ll*x*x)%n;y&gt;&gt;=1; &#125; return res; &#125; public: inline int pileSize(int x,int y,int k) &#123; n=x+y; x=(1ll*x*quick_pow(2,k))%n; return min(x,n-x); &#125;&#125;;#ifdef LOCALint main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); BearPlays A; int nn,mm,kk; while (cin&gt;&gt;nn&gt;&gt;mm&gt;&gt;kk) cout&lt;&lt;A.pileSize(nn,mm,kk)&lt;&lt;endl; return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #908G: New Year and Original Order 题解]]></title>
    <url>%2Fblog%2Fcf908g%2F</url>
    <content type="text"><![CDATA[DescriptionLet S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555. Given a number X, compute modulo $10^9 + 7$. InputThe first line of input will contain the integer X ($1$ ≤ $X$ ≤ $10^{700}$). OutputPrint a single integer, the answer to the question. ExamplesInput 21 Output 195 Input 345342 Output 390548434 NoteThe first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. Solution很神的dp题 我们尝试考虑每一位的贡献，也就是要算第i位是j的数有多少个 容易想到一个$O(n^3)$的dp:令$dp[i][j][k][l][cmp]$表示当前考虑到第$i$位，大于等于j的数位有k个，j这个数位有l个，当前数与$n$的大小关系是cmp的情况下有多少种情况，转移只要枚举下一个数是多少即可 这样最后在算答案的时候，把这连续的$l$个$j$统计一下贡献即可 然而这题需要$O(n^2)$的复杂度，考虑优化：我们把上面的dp中$l$的那一维去掉，这样算dp的复杂度是$O(n^2)$的，但你会发现答案不好统计了，因为比如如果你有一串3，中间的那些3无法通过充斥得到 于是有这样一个神结论：对于每个$sum=dp[n][j][k][0]+dp[n][j][k][1]$，对答案的贡献是$sum*\underbrace{11…111}_{j个1}$ 下面证这个结论的正确性：我们尝试考虑每个数按数位排好序的那个序列是怎样被计算到的 首先对于最左边的数码$x_1$，显然会有$x_1$个长度为n的dp中会算到这个排列，所以会加$x_1$个$\underbrace{11…111}_{n个1}$，一个很好的性质是，如果有若干个连续的相同数码，在上面的dp中非开头位不会体现在某个状态之中，一起跟着开头的那个数位算掉了 然后我们考虑第二小的数码$x_2$，乍一看感觉它会被算$x_2$次，加上前面的$x_1$次就不对了，但我们注意到$x_2$是比$x_1$大的，所以从不大于$x_1$的数码中对$x_2$这位加的贡献其实都不归当前的这个状态，所以实际上这时$x_2$只被计算了$x_2-x_1$次，加上前面的$x_1$次正好是正确的，以此类推，后面的都是正确的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=700;char s[MAXN+48];int n;int dp[MAXN+48][MAXN+48][10][2],ans[MAXN+48][10];int pw[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); memset(dp,0,sizeof(dp)); for (register int i=0;i&lt;=9;i++) dp[0][0][i][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) for (register int k=0;k&lt;=9;k++) &#123; if (dp[i][j][k][0]) &#123; //to 0 add(dp[i+1][j+(s[i+1]-'0'&gt;=k)][k][0],dp[i][j][k][0]); //to 1 for (register int nxt=0;nxt&lt;=s[i+1]-'0'-1;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][0]); &#125; if (dp[i][j][k][1]) &#123; for (register int nxt=0;nxt&lt;=9;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][1]); &#125; &#125; pw[1]=1; for (register int i=2;i&lt;=n;i++) pw[i]=(1ll*pw[i-1]*10+1)%MOD; int ans=0; for (register int j=0;j&lt;=n;j++) for (register int k=1;k&lt;=9;k++) add(ans,1ll*add(dp[n][j][k][0]+dp[n][j][k][1])*pw[j]%MOD); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Code Festival 2016 Final G: Zigzag MST 题解]]></title>
    <url>%2Fblog%2Fatcoder-codefestival2016finalg%2F</url>
    <content type="text"><![CDATA[Problem StatementWe have a graph with N vertices, numbered 0 through N−1. Edges are yet to be added. We will process Q queries to add edges. In the i-th (1≦i≦Q) query, three integers Ai,Bi and Ci will be given, and we will add infinitely many edges to the graph as follows: The two vertices numbered Ai and Bi will be connected by an edge with a weight of Ci. The two vertices numbered Bi and Ai+1 will be connected by an edge with a weight of Ci+1. The two vertices numbered Ai+1 and Bi+1 will be connected by an edge with a weight of Ci+2. The two vertices numbered Bi+1 and Ai+2 will be connected by an edge with a weight of Ci+3. The two vertices numbered Ai+2 and Bi+2 will be connected by an edge with a weight of Ci+4. The two vertices numbered Bi+2 and Ai+3 will be connected by an edge with a weight of Ci+5. The two vertices numbered Ai+3 and Bi+3 will be connected by an edge with a weight of Ci+6. … Here, consider the indices of the vertices modulo N. For example, the vertice numbered N is the one numbered 0, and the vertice numbered 2N−1 is the one numbered N−1. The figure below shows the first seven edges added when N=16,Ai=7,Bi=14,Ci=1: After processing all the queries, find the total weight of the edges contained in a minimum spanning tree of the graph. Constraints2 ≦ N ≦ 200,000 1 ≦ Q ≦ 200,000 0 ≦ Ai,Bi ≦ N−1 1 ≦ Ci ≦ 1e9 InputThe input is given from Standard Input in the following format: N Q A1 B1 C1 A2 B2 C2 : AQ BQ CQ OutputPrint the total weight of the edges contained in a minimum spanning tree of the graph. Sample Input 17 1 5 2 1 Sample Output 121 The figure below shows the minimum spanning tree of the graph: Note that there can be multiple edges connecting the same pair of vertices. Sample Input 22 1 0 0 1000000000 Sample Output 21000000001 Also note that there can be self-loops. Sample Input 35 3 0 1 10 0 2 10 0 4 10 Sample Output 342 Solution对kruskal算法的灵活运用 我们考虑kruskal算法的精髓，不在于每条边连接的是哪两个点，而在于任意两点之间是否连通 对于每组边，首先我们考虑(Bi,Ai+1),因为(Ai,Bi)的边权比(Bi,Ai+1)小，所以我们一定会先处理(Ai,Bi),如果这条边没加进去，说明Ai和Bi已经连通了，如果这条边加进去了，那么此时Ai和Bi变得连通了，于是我们会发现处理(Bi,Ai+1)时Ai和Bi一定是连通的，所以这是Ai+1这个点我们可以改连到Ai上，把这条边换成(Ai,Ai+1) 依次类推，第二条边(Ai+1,Bi+1),Ai+1,Ai,Bi都是连通的，所以我们可以把Bi+1连到Bi上 最终我们会发现，对于每一组边，我们都是先在Ai和Bi之间连边，然后从Ai和Bi出发顺时针连边，所以我们可以把它拆成三部分：Ai和Bi的横跨边，从Ai出发的链和Bi出发的链 Ai和Bi的横跨边一共只有1e5条，可以不管。对于剩下的链,我们会发现一些很好的性质:如果某一条链当前在连的过程中，发现要连的两个点已经连通了，那么可以立刻停止这条链的连接过程，因为注意到每条链的边权都是公差为2的等差数列，所以已经连起来的那条边属于的链后面的边都会比当前链后面的边的边权小，当前链直接被废掉 因为一共只会向图中连n-1条边，所以直接用堆维护这个过程，复杂度正确 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;int n,m;struct node&#123; int A,B,C; inline void input() &#123;io.Get(A);io.Get(B);io.Get(C);&#125;&#125;a[MAXN+48];inline Pair query(int id,int ti)&#123; if (ti==1) return mp(a[id].A,a[id].B); if ((a[id].A+1)%n==a[id].B &amp;&amp; !(ti&amp;1)) return mp(0,0); if (ti&amp;1) &#123; Pair res=mp(a[id].B+ti/2-1,a[id].B+ti/2); res.x%=n;res.y%=n; return res; &#125; else &#123; Pair res=mp(a[id].A+ti/2-1,a[id].A+ti/2); res.x%=n;res.y%=n; return res; &#125;&#125;namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=0;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;priority_queue&lt;pair&lt;int,pair&lt;Pair,bool&gt; &gt; &gt; q;int main ()&#123; io.Get(n);io.Get(m); for (register int i=1;i&lt;=m;i++) &#123; a[i].input(); q.push(mp(-a[i].C,mp(mp(a[i].A,a[i].B),false))); if (a[i].A+1!=a[i].B) q.push(mp(-a[i].C-1,mp(mp(a[i].A,(a[i].A+1)%n),true))); q.push(mp(-a[i].C-2,mp(mp(a[i].B,(a[i].B+1)%n),true))); &#125; LL ans=0;DSU::init(); for (register int cnt=0;cnt&lt;n-1;) &#123; int len=q.top().x;Pair res=q.top().y.x;bool type=q.top().y.y;q.pop(); if (DSU::issame(res.x,res.y)) continue; cnt++;ans-=len; DSU::update(res.x,res.y); if (type) &#123; res.x=(res.x+1)%n;res.y=(res.y+1)%n; len-=2; q.push(mp(len,mp(res,type))); &#125; &#125; io.Print(ans,'\n'); io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>atcoder</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #1045A: Last Chance 题解]]></title>
    <url>%2Fblog%2Fcf1045a%2F</url>
    <content type="text"><![CDATA[DescriptionIt is the year 2969. 1000 years have passed from the moon landing. Meanwhile, the humanity colonized the Hyperspace™ and lived in harmony. Until we realized that we were not alone. Not too far away from the Earth, the massive fleet of aliens’ spaceships is preparing to attack the Earth. For the first time in a while, the humanity is in real danger. Crisis and panic are everywhere. The scientists from all around the solar system have met and discussed the possible solutions. However, no progress has been made. The Earth’s last hope is YOU! Fortunately, the Earth is equipped with very powerful defense systems made by MDCS. There are N aliens’ spaceships which form the line. The defense system consists of three types of weapons: SQL rockets – every SQL rocket can destroy at most one spaceship in the given set. Cognition beams – every Cognition beam has an interval [l,r]and can destroy at most one spaceship in that interval. OMG bazooka – every OMG bazooka has three possible targets, however, each bazooka can destroy either zero or exactly two spaceships. In addition, due to the smart targeting system, the sets of the three possible targets of any two different OMG bazookas are disjoint (that means that every ship is targeted with at most one OMG bazooka). Your task is to make a plan of the attack which will destroy the largest possible number of spaceships. Every destroyed spaceship should be destroyed with exactly one weapon. InputThe first line contains two integers: the number of your weapons N(1≤N≤5000)and the number of spaceships M(1≤M≤5000). In the next N lines, each line starts with one integer that represents type (either 0, 1 or 2). If the type is 0, then the weapon is SQL rocket, the rest of the line contains strictly positive number K(∑K≤100000) and array ki (1≤ki≤M) of K integers. If the type is 1, then the weapon is Cognition beam, the rest of the line contains integers l and r(1≤l≤r≤M). If the type is 2 then the weapon is OMG bazooka, the rest of the line contains distinct numbers a, b and c (1≤a,b,c≤M). OutputThe first line should contain the maximum number of destroyed spaceships —X. In the next X lines, every line should contain two numbers A and B, where A is an index of the weapon and B is an index of the spaceship which was destroyed by the weapon A. Exampleinput3 50 1 42 5 4 11 1 4 output42 13 21 42 5 NoteSQL rocket can destroy only 4th spaceship. OMG Bazooka can destroy two of 1st, 4th or 5th spaceship, and Cognition beam can destroy any spaceship from the interval [1,4]. The maximum number of destroyed spaceship is 4, and one possible plan is that SQL rocket should destroy 4th spaceship, OMG bazooka should destroy 1st and 5th spaceship and Cognition beam should destroy 2nd spaceship. Solution这题的宗旨是你要相信$1e5$的网络流是能跑的，然后你就真的过了（大雾 网络流的模型还是很显然的，考虑对每种武器建一个点，超级源点向这些点连流量为$1$的边（对于第三种武器，连流量为2的边），每个目标建一个点，这些点向超级汇点连流量为$1$的边 考虑三种武器怎么建： 第一种武器比较简单，从武器点向覆盖的集合连流量为1的边即可 第二种武器是区间，一条一条暴力连肯定会爆炸，考虑用线段树优化建边，我们可以把目标想象成线段树的叶子，然后向上垒出一棵线段树，线段树上的每个点向左右孩子连流量为$INF$的边，然后武器点只要像正常线段树一样查询一波，向所有查询到的区间$(left&lt;=l 且 r&lt;=right)$连边即可，这样点数仍然是$O(m)$的，边数是$O(nlogm)的$ 第三种武器，我们发现很难控制一选就要选两个这个条件，但是我们可以好好利用题目中的性质：任意两个第三种武器的集合是不交的。我们可以发现，只要向武器点连流量为2的边，武器点向对应目标连流量为1的边，不加控制答案就是对的，理由如下： 首先如果这条流量为2的边被流满了，那么它肯定选了两个 如果这条流量为2的边没流，那么它肯定不用选 如果这条流量为2的边流了1，首先可以确定的是，它指向的三个点不可能只有一个被选了，否则因为这个点还能流，所以当前的这个流肯定不是最大流。继而我们发现，我们可以直接把它对应的三个点中，任意一个被其他武器“占领”的点强行占为己有，这样带来的影响是，其他某个武器可能会因此变得无用，但最大流跑出的答案肯定是对的 接下来考虑如何构造答案。根据上面所述，第三种武器是要“抢占”别人的目标的，所以先处理掉。然后我们处理第一种武器，注意如果目标已经被第三种占领了就把这个武器直接扔掉。 第二种武器比较烦，因为比较难从残量网络中直接看出每个武器占用了哪个点，我们只能看出这些武器占领的点的总集合，所以我们换用一个贪心的手法来为每个区间分配一个点：考虑将所有的区间按照左端点从小到大排序，然后我们从左到右枚举每一个目标，这时我们要找出那些区间左端点在这个点左边的可能可行的区间，显然这个集合是单调增的，对于这些区间我们把它扔到按右端点从小到大排序的堆里，每次我们找区间右端点在这个点之右且最靠左的区间来覆盖这个点，这样的贪心策略显然是对的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=5e4;const int MAXM=1e6;int n,m,t,ind;int toid[MAXN+48],tonode[MAXN+48];int L[MAXN+48],R[MAXN+48],type[MAXN+48];bool visited[MAXN+48],chosen[MAXN+48];int head[MAXM+48],cur[MAXM+48],to[MAXM+48],nxt[MAXM+48],f[MAXM+48],tot=1;vector&lt;Pair&gt; ans;int seq[MAXN+48],stot;priority_queue&lt;Pair&gt; q;inline bool cmp_l(int x,int y) &#123;return L[x]&lt;L[y];&#125;inline bool cmp_x(Pair x,Pair y) &#123;return x.y&lt;y.y;&#125;namespace flow&#123; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[MAXM+48],Head,Tail,depth[MAXM+48]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; register int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; return depth[t]!=-1; &#125; inline int dfs(int x,int maxf) &#123; if (!maxf || x==t) return maxf; int minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; if (ans&gt;=maxf) break; &#125; &#125; if (!ans) depth[x]=-1; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;namespace SegmentTree&#123; inline void build(int cur,int left,int right) &#123; if (left==right) &#123; ++ind; toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,n+left,INF); return; &#125; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid);build(cur&lt;&lt;1|1,mid+1,right); ++ind;toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,toid[cur&lt;&lt;1],INF); flow::addedge(ind,toid[cur&lt;&lt;1|1],INF); &#125; inline void update(int cur,int left,int right,int l,int r,int id) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; flow::addedge(id,toid[cur],1); return; &#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,l,mid,id); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,mid+1,r,id); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);ind=n+m; SegmentTree::build(1,1,m);int num,x; for (register int i=1;i&lt;=n;i++) &#123; io.Get(type[i]); switch(type[i]) &#123; case 0: &#123; io.Get(num); for (register int j=1;j&lt;=num;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; case 1: &#123; io.Get(L[i]);io.Get(R[i]); SegmentTree::update(1,L[i],R[i],1,m,i); break; &#125; case 2: &#123; for (register int j=1;j&lt;=3;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; &#125; &#125; t=ind+1; for (register int i=1;i&lt;=n;i++) if (type[i]!=2) flow::addedge(0,i,1); else flow::addedge(0,i,2); for (register int i=1;i&lt;=m;i++) flow::addedge(n+i,t,1); io.Print(flow::dinic(),'\n'); for (register int i=1;i&lt;=m;i++) for (register int j=head[n+i];j;j=nxt[j]) if (to[j]==t) &#123; if (!f[j]) chosen[i]=true; break; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i],cnt=0; if (type[y]==2 &amp;&amp; f[i]&lt;2) &#123; for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; if (cnt&lt;2) for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !visited[to[j]-n] &amp;&amp; chosen[to[j]-n]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==0 &amp;&amp; !f[i]) for (register int j=head[y];j;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; if (!visited[to[j]-n]) visited[to[j]-n]=true,ans.pb(mp(y,to[j]-n)); break; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==1 &amp;&amp; !f[i]) seq[++stot]=y; &#125; sort(seq+1,seq+stot+1,cmp_l);int pt=1; for (register int i=1;i&lt;=m;i++) if (chosen[i] &amp;&amp; !visited[i]) &#123; while (pt&lt;=stot &amp;&amp; L[seq[pt]]&lt;=i) q.push(mp(-R[seq[pt]],seq[pt])),pt++; while (!q.empty() &amp;&amp; -q.top().x&lt;i) q.pop(); assert(!q.empty()); ans.pb(mp(q.top().y,i));q.pop(); &#125; sort(ans.begin(),ans.end(),cmp_x); for (auto y : ans) io.Print(y.x,' '),io.Print(y.y,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>网络流</category>
        <category>最大流</category>
        <category>线段树</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最大流</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4934: kangaroo 题解]]></title>
    <url>%2Fblog%2Fbzoj4934%2F</url>
    <content type="text"><![CDATA[Description有一个园子，里面有n个草丛排成一排，标号1~n，有一个袋鼠，从s出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达t。显然他会跳跃n-1次为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同，具体地，如果他现在在now,他是从prev跳跃一次到达now的，然后他跳跃一次到达next，那么如果prev&lt;now，就必须有now&lt;next，如果now&lt;prev，就必须有next&lt;now问从s到t的方案数，模1e9+7两个路线不同，当且仅当草丛被访问的顺序不同保证至少有一种方案初始时可以往任意方向跳。 修正下：那么如果prev&lt;now，就必须有next&lt;now,如果now&lt;prev,就必须有now&lt;next Input 一行三个整数，n，s，t 2&lt;=n&lt;=2000 1&lt;=s&lt;=n 1&lt;=t&lt;=n Output一行一个整数，代表答案 Sample Input4 2 3 Sample Output2 Solution最后的序列肯定长成一个不断上下的折线 如果考虑从左到右确定折线，就不免要维护每个数是否已经被选过，无法逃离指数级的算法 考虑把所有的数从小到大往里面放，我们会发现，如果有一个“上扬“的结构，那它的后面肯定不能再接东西了，否则就会形成一个连续三个的”上扬”,从而不符合题意，也就是一个数只能单独成一块，或者连接两个端点“下垂”的块，除非是$S$或$T$才能去形成“上扬”结构 于是dp的思路就很明显了，考虑$dp[i][j]$表示已经将$1～i$扔进了排列，当前形成了$j$个连通块的方案数 考虑$i+1$的方法 单独建一个新连通块,$dp[i][j]\rightarrow dp[i+1][j+1]$ 如果是$S$或$T$，可以选择一个连通块接在它的前面或后面，但要注意除非$S$和$T$等于$n$，$S$不能和$T$在一个联通块中，否则这个图就连不起来了 连接两个连通块，当前有$j$个连通块，所以显然有$j(j-1)$种连法，但要注意$S$所在的连通块前面不能有连通块，所以如果$i+1&gt;=S$要$-=j$，$T$所在的连通块后面不能有连通块，所以如果$i+1&gt;=T$要$-=j$，这样$TS$型连通块会被减两次，所以如果$i+1&gt;=S$且$i+j&gt;=T$要$+1$，还要注意如果$i+1&lt;n$的话$S$不能和$T$连起来，所以还要减一 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=2000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,S,T;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif // io.Get(n);io.Get(S);io.Get(T); scanf("%d%d%d",&amp;n,&amp;S,&amp;T); dp[0][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) if (dp[i][j]) &#123; // cerr&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;dp[i][j]&lt;&lt;endl; //create a new node dp[i+1][j+1]=add(dp[i+1][j+1]+dp[i][j]); //add before a node if (i+1==S) &#123; register int valid=j; if (i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //add after a node if (i+1==T) &#123; register int valid=j; if (i+1&gt;=S &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //connect two nodes if (i+1!=S &amp;&amp; i+1!=T &amp;&amp; j&gt;=2) &#123; register int valid=1ll*j*(j-1)%MOD; if (i+1&gt;=S) valid=sub(valid-(j-1)); //can't connect a node before S if (i+1&gt;=T) valid=sub(valid-(j-1)); //can't connect a node after T if (i+1&gt;=S &amp;&amp; i+1&gt;=T) valid=add(valid+1); //T-S is deleted twice if (i+1&gt;=S &amp;&amp; i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); //S-T is not allowed dp[i+1][j-1]=add(dp[i+1][j-1]+1ll*dp[i][j]*valid%MOD); &#125; &#125; // io.Print(dp[n][1],'\n'); printf("%d\n",dp[n][1]); // io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #992E: Nastya and King-Shamans 题解]]></title>
    <url>%2Fblog%2Fcf992e%2F</url>
    <content type="text"><![CDATA[DescriptionNastya likes reading and even spends whole days in a library sometimes. Today she found a chronicle of Byteland in the library, and it stated that there lived shamans long time ago. It is known that at every moment there was exactly one shaman in Byteland, and there were n shamans in total enumerated with integers from 1 to n in the order they lived. Also, each shaman had a magic power which can now be expressed as an integer. The chronicle includes a list of powers of the n shamans. Also, some shamans can be king-shamans, if they gathered all the power of their predecessors, i.e. their power is exactly the sum of powers of all previous shamans. Nastya is interested in whether there was at least one king-shaman in Byteland. Unfortunately many of the powers are unreadable in the list, so Nastya is doing the following: Initially she supposes some power for each shaman.After that she changes the power of some shaman q times (the shamans can differ) and after that wants to check if there is at least one king-shaman in the list. If yes, she wants to know the index of any king-shaman.Unfortunately the list is too large and Nastya wants you to help her. InputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105). The second line contains n integers a1, …, an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman. After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi. OutputPrint q lines, the i-th of them should contain - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change. If there are multiple king-shamans after each change, print the index of any of them. Examplesinput 2 11 31 2 output -1 input 3 42 2 31 11 22 43 6 output 32-13 input 10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0 output 1-19-14-11 NoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2. In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3. Solution注意到$a[i]=sum[i-1]$的话，那么$sum[i]=2*sum[i-1]$，似乎存在倍增的关系，尝试从这个角度入手 我们对原序列维护线段树，线段树记录区间和&amp;区间最大值,每次单点修改后，我们记录一个初始前缀和cursum，然后在序列中找第一个比cursum大的数a[i]，这个根据我们维护的区间最大值可以线段树二分在log的时间内求出，然后我们验证a[i]是否是king，如果是则结束，否则把cursum更新成sum[i]，从头来过。可以看出因为cursum每次至少乘2，所以最多只会做log(1e9)次，加上每次线段树二分的log，我们可以在$O(nlognlog(1e9))$的时间复杂度解决这个问题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int #define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rlen,wlen; fastio () &#123;rlen=wlen=0;&#125; inline char Getchar() &#123; if (rlen==S) rlen=0,fread(rbuf,1,S,stdin); return rbuf[rlen++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; T res=0;char ch;bool f; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=res; &#125; inline void flush() &#123;fwrite(wbuf,1,wlen,stdout);rlen=0;&#125; inline void Writechar(char ch) &#123; wbuf[wlen++]=ch; if (wlen==S) flush(); &#125; template &lt;class T&gt; inline void Print(T res,char ch) &#123; char s[48];int pt; if (res==0) &#123; pt=1; s[1]='0'; &#125; else &#123; bool f=true;if (res&lt;0) f=false,res=-res; pt=0;while (res) s[++pt]=res%10+'0',res/=10; if (!f) s[++pt]='-'; &#125; while (pt&gt;=1) Writechar(s[pt--]); Writechar(ch); &#125;&#125;io;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct node &#123; int left,right; int maxn;LL sum; &#125;tree[MAXN*4]; inline void pushup(int cur) &#123; tree[cur].maxn=max(tree[cur&lt;&lt;1].maxn,tree[cur&lt;&lt;1|1].maxn); tree[cur].sum=tree[cur&lt;&lt;1].sum+tree[cur&lt;&lt;1|1].sum; &#125; inline void build(int cur,int left,int right) &#123; tree[cur].left=left;tree[cur].right=right; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid); build(cur&lt;&lt;1|1,mid+1,right); pushup(cur); &#125; else &#123; tree[cur].maxn=tree[cur].sum=a[left]; &#125; &#125; inline void update(int cur,int pos,int newval) &#123; if (tree[cur].left==tree[cur].right) &#123; tree[cur].maxn=tree[cur].sum=newval; return; &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (pos&lt;=mid) update(cur&lt;&lt;1,pos,newval); else update(cur&lt;&lt;1|1,pos,newval); pushup(cur); &#125; inline LL querysum(int cur,int left,int right) &#123; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) return tree[cur].sum; LL res=0; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (left&lt;=mid) res+=querysum(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) res+=querysum(cur&lt;&lt;1|1,left,right); return res; &#125; inline int findpos(int cur,int left,int right,LL need) &#123; if (left&gt;right) return -1; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) &#123; if (tree[cur].maxn&lt;need) return -1; if (tree[cur].left==tree[cur].right) return tree[cur].left; if (tree[cur&lt;&lt;1].maxn&gt;=need) return findpos(cur&lt;&lt;1,left,right,need); else return findpos(cur&lt;&lt;1|1,left,right,need); &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; int res=-1; if (left&lt;=mid) res=findpos(cur&lt;&lt;1,left,right,need); if (res!=-1) return res; if (mid+1&lt;=right) res=findpos(cur&lt;&lt;1|1,left,right,need); return res; &#125;&#125;inline int solve()&#123; LL cursum=SegmentTree::querysum(1,1,1);int lastpos=1; if (!cursum) return 1; for (;;) &#123; int pos=SegmentTree::findpos(1,lastpos+1,n,cursum); if (pos==-1) return -1; if (SegmentTree::querysum(1,pos,pos)==SegmentTree::querysum(1,1,pos-1)) return pos; cursum=SegmentTree::querysum(1,1,pos); lastpos=pos; &#125;&#125;int main ()&#123; io.Get(n);io.Get(q); for (register int i=1;i&lt;=n;i++) io.Get(a[i]); SegmentTree::build(1,1,n); while (q--) &#123; register int pos,x; io.Get(pos);io.Get(x); SegmentTree::update(1,pos,x); io.Print(solve(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>倍增</category>
        <category>线段树</category>
        <category>线段树二分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6405: Make ZYB Happy 题解]]></title>
    <url>%2Fblog%2Fhdu6405%2F</url>
    <content type="text"><![CDATA[DescriptionIt’s known to all that ZYB is godlike, so obviously he has a large number of titles, such as jsking, bijingzyb and nbazyb. ZYB likes his titles very much. Each of ZYB’s titles is a string consisting of lower case letters ‘a’-‘z’ associated with a happiness value hi, which shows how much ZYB likes this title. If you say any substring of some title with happiness value x, he will get x happiness points. Moreover, a string may appear in more than one title. In this case, the happiness points ZYB gets are multiplied. If the string you say is not the substring of any of his titles, he gets no happiness point. For example, let’s say ZYB has two titles: zybnb (with happiness value 3) and ybyb (with happiness value 5). If you say y, b or yb, ZYB will get 15 happiness points; if you say z, zy or zyb, ZYB will only get 3 happiness points; if you say ybz or ybac he will get 0 happiness points. One day, you find ZYB pretty sad. As a big fan of ZYB, you want to say a word to ZYB to cheer him up. However, ZYB is really busy, so you can only say no more than m letters. As you haven’t seen ZYB for a long time, you are so excited that you forget what you want to say, so you decide to choose to say a nonempty string no longer than m and only containing ‘a’-‘z’ with equal probability. You want to know the expectations of happiness points you will bring to ZYB for different m. InputThe first line contains an integer n (1≤n≤104), the number of titles ZYB has. The i-th of the next n lines contains a nonempty string ti, which only contains lower case letters ‘a’-‘z’, representing the i-th title. The sum of lengths of all titles does not exceed 3×105. Then follows a line with n integers hi (1≤hi≤106), the happiness value of i-th title. The next line is a single integer Q (1≤Q≤3×105), the number of queries. For the next Q lines, each contains a single integer m (1≤m≤106), meaning that you can say no more than m letters to ZYB. The input data contains only one test case. OutputFor each query, display a single line of integer, representing the answer. It can be proved that the answer can be uniquely written as p/q where p and q are non-negative integers with gcd(p,q)=gcd(q,109+7)=1, and you should display p*q−1mod(109+7), where q−1 means the multiplicative inverse of q modulo 109+7. Sample Input2zybnbybyb3 541234 Sample Output769230776425925929891125950633120399 HintFor the first query, you can bring him 3 happiness points if you say “z” or “n”, and 15 happiness points if you say “y” or “b”; all other strings of length 1 bring no happiness point to ZYB. Therefore, the expectation is (2×3+2×15)/26 = 18/13, and the answer is 18×13^(-1) mod (10^9+7) = 769230776. Source2018 Multi-University Training Contest 8 Solution学习了一下广义后缀自动机 广义后缀自动机其实和普通后缀自动机一模一样，可以把它看做在trie上建立的SAM,实现上只要先建好一个串的SAM,然后后面的串把last置成root再来就可以了，中间不需要任何改动 首先对所有的串建立广义SAM,然后考虑题目的需求，对于广义SAM的每个节点，我们需要计算有多少个串包含它，然后把它们的happy值做累乘，这个的话，只要抓着每个串到SAM里面跑一遍，每跑到一个状态就同时顺着parent树更新所有的祖先，为了保证复杂度，每个节点记一个visited，如果已经被访问过了，那么它的祖先们肯定也都被访问过了，所以可以终止向上，这样保证每个点最多被访问一次，使得复杂度是$O(\sum len)$的 求出每个节点的累乘值后，考虑到每个节点所代表的子串长度都是在$min[i]$到$max[i]$范围内的，所以可以用一个差分数组来维护权值，具体来说，$sum[min[i]]+=\Pi_{happy},sum[max[i]+1]-=\Pi_{happy}$即可，这个数组做一遍前缀和就可以得到对于每种长度，所有可能子串的权值和 最后还要除以每种长度的子串个数，注意到子串是完全随机的，所以总个数显然是$26^{len}$,于是这题就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void getstring(string &amp;s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) s+=string(1,ch); &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=4e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int n,q;string s[MAXN+48];int h[MAXN+48];int sum[MAXN+48],ans[MAXN+48],maxlen;namespace SAM&#123; const int MAXN=1e6; int maxn[MAXN+48],nxt[MAXN+48][27],par[MAXN+48],h[MAXN+48],visited[MAXN+48],root,last,tot; inline void init() &#123;root=last=tot=1;&#125; inline void extend(char ch) &#123; int w=ch-'a'+1,p=last,np=++tot;maxn[np]=maxn[p]+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=++tot;maxn[nq]=maxn[p]+1; memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[q]=par[np]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline void insert(string s) &#123; last=root;int len=int(s.size()); for (register int i=0;i&lt;=len-1;i++) extend(s[i]); &#125; inline void go(string s,int ind,int val) &#123; int pos=root,len=int(s.size()); for (register int i=0;i&lt;len;i++) &#123; pos=nxt[pos][s[i]-'a'+1];int tmp=pos; while (tmp &amp;&amp; visited[tmp]!=ind) &#123; visited[tmp]=ind; //带着编号进去就不用清空visited if (!h[tmp]) h[tmp]=val; else h[tmp]=(1ll*h[tmp]*val)%MOD; tmp=par[tmp]; &#125; &#125; &#125;&#125;int main ()&#123; int i,qlen;io.Get(n);SAM::init(); for (i=1;i&lt;=n;i++) &#123; io.getstring(s[i]); SAM::insert(s[i]); maxlen=max(maxlen,int(s[i].size())); &#125; for (i=1;i&lt;=n;i++) io.Get(h[i]); for (i=1;i&lt;=n;i++) SAM::go(s[i],i,h[i]); for (i=2;i&lt;=SAM::tot;i++) &#123; int L=SAM::maxn[SAM::par[i]]+1,R=SAM::maxn[i]; sum[L]=add(sum[L]+SAM::h[i]);sum[R+1]=sub(sum[R+1]-SAM::h[i]); &#125; int ss=0,cur=1,vv=0; for (i=1;i&lt;=maxlen;i++) &#123; cur=(1ll*cur*26)%MOD; ss=add(ss+cur); sum[i]=add(sum[i]+sum[i-1]); vv=add(vv+sum[i]); ans[i]=1ll*vv*quick_pow(ss,MOD-2)%MOD; &#125; io.Get(q); while (q--) &#123; io.Get(qlen); qlen=min(qlen,maxlen); //注意一下这个细节 io.Print(ans[qlen],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>字符串</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6428: Calculate 题解]]></title>
    <url>%2Fblog%2Fhdu6428%2F</url>
    <content type="text"><![CDATA[DescriptionGiven A, B, C, Calculate $$ \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3)) (mod 2^{30}) $$ Where $\phi (n)$ denotes the number of positive integers ≤ n that are relatively prime to n. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there are three integers A, B, C in one line, as described above. 1 ≤ T ≤ 10, 0 &lt; A, B, C ≤ 10^7 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 2^30. Sample Input496 93 95970 906 89392460 95043 542459760979 8053227 7156842 Sample Output111453628070648388873924623507672 Source2018 Multi-University Training Contest 10 Solution考虑莫比乌斯反演 \begin{split}ans &amp;= \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3))\ &amp;= \sum_{d=1}^A\phi (d)\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=d]\end{split} 令$f(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=n]$ 令$F(n)=\sum_{n\mid d}f(d)$ $gcd(i,j^2,k^3)$是$n$的倍数等价于$i$,$j^2$,$k^3$都是$n$的倍数，所以 $$F(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{d\mid i,d\mid j^2,d\mid k^3} 1$$ 考虑$x\mid y^k$的充要条件，设$x=\Pi_ip_i^{a_i}$,则应满足$\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil} \mid y$ 令$f_k(x)=\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil}$,则 $$F(n)=\left \lfloor \frac{A}{f_1(n)}\right \rfloor \left\lfloor \frac{B}{f_2(n)}\right\rfloor \left\lfloor \frac{C}{f_3(n)} \right\rfloor $$ 根据莫比乌斯反演 $$f(n)=\sum_{n\mid d}F(d)\mu (\frac{d}{n})=\sum_{n\mid d}\left \lfloor \frac{A}{f_1(d)}\right \rfloor \left\lfloor \frac{B}{f_2(d)}\right\rfloor \left\lfloor \frac{C}{f_3(d)} \right\rfloor \mu (\frac{d}{n})$$ 将此式带回$ans$式,有 $$ans=\sum_{d=1}^A\phi (d)f(d)=\sum_{d=1}^A\sum_{d\mid t}\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \mu (\frac{t}{d})$$ 发现$\mu$和$\phi$很像卷积的关系，所以转而枚举$t$,我们有 \begin{split}ans &amp;=\sum_{t=1}^A\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \sum_{d\mid t}\phi (d)\mu (\frac{t}{d})&amp;=\sum_{t=1}^A(\phi \ast \mu)(t)\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor\end{split} 现在只要线性筛出$f_k(n)$和$(\phi \ast \mu)(n)$,$f_k(n)$是积性函数比较显然,对于$(\phi \ast \mu)(n)$是积性函数，下面给出一个简短的证明:证明：考虑$(\phi \ast \mu)(a)和(\phi \ast \mu)(b)$,其中$a$,$b$互质&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(\phi \ast \mu)(a)$可以写成$\sum \phi(x)\mu(y)[xy=a]$的形式，同理$(\phi \ast \mu)(b)$可以写成$\sum \phi(X)\mu(Y)[XY=b]$的形式&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 考虑$(\phi \ast \mu)(a)$和$(\phi \ast \mu)(b)$相乘，拆开括号后，每一项应该都是$\phi(x)\mu(y)\phi(X)\mu(Y)的形式$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为$(a,b)=1$,所以$(x,X)=1,(y,Y)=1$,因为$\phi$和$\mu$都是积性函数，所以上式可以写成$\phi(xX)\mu(yY)$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 注意到$xXyY=ab$,因为$xy$遍历了$a$的所有拆分,$XY$遍历了$b$的所有拆分，所以$xX$和$yY$必然也遍历了$ab$的所有拆分，又因为$(a,b)=1$,所以所有的$xX$必然互不相同,同时所有的$yY$也互不相同&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 所以，当$(a,b)=1$时,$(\phi \ast \mu)(ab)=(\phi \ast \mu)(a)(\phi \ast \mu)(b)$,$(\phi \ast \mu)(n)$是积性函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Q.E.D.$ $f_1(n)$不用筛，我们注意到线性筛有一个非常好的性质，每个数都是被它最小的质因数筛去的，举一个例子，如果有一个数是$2^2\cdot 3^2\cdot 5$,那筛掉它的一定是$2$,剩下的是$2\cdot 3^2\cdot 5$,而$2\cdot 3^2\cdot 5$又是被$2$筛掉的,剩下的是$3^2\cdot 5$…依次类推，我们会发现一个数的相同质因数总是会在一起，所以如果我们对每一个数记录一个$cnt$表示筛掉它的质数现在有几个，在$i%prime[j]==0$的环节$cnt$累加,否则$cnt$置为$1$,然后判断一下$cnt%k$是否为1就能维护$f_k(n)$,具体细节可以看看代码 对于$(\phi \ast \mu)(n)$,首先当n是质数的时候,$(\phi \ast \mu)(n)=\phi (n)\mu (1)+\phi(1) \mu(n)=n-2$,进而当$n=p^k$,其中$p$是质数时,$(\phi \ast \mu)(n)=(\phi \ast \mu)(p^k)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)+\phi(p^{k-2})\mu(p^2)+…+\phi(p)\mu(p^{k-1})+\phi(1)\mu(p^k)$, 根据莫比乌斯函数的定义,后面的$p$的次数大于等于二的项都是0,所以$(\phi \ast \mu)(n)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)=(p^k-p^{k-1})\cdot 1+(p^{k-1}-p^{k-2})\cdot (-1)=p^k-2\cdot p^{k-1}+p^{k-2}$根据这个就足够进行线性筛了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e7;bool isprime[MAXN+48];int prime[MAXN+48],tot;int phi[MAXN+48],mu[MAXN+48],mup[MAXN+48],f2[MAXN+48],f3[MAXN+48];int cnt[MAXN+48],pw[MAXN+48];inline void init()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=mu[1]=mup[1]=f2[1]=f3[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) &#123; prime[++tot]=i; phi[i]=i-1;mu[i]=-1;mup[i]=i-2; f2[i]=f3[i]=i;cnt[i]=1;pw[i]=i; &#125; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]!=0) &#123; phi[i*prime[j]]=phi[i]*(prime[j]-1); mu[i*prime[j]]=-mu[i]; mup[i*prime[j]]=mup[i]*mup[prime[j]]; f2[i*prime[j]]=f2[i]*prime[j]; f3[i*prime[j]]=f3[i]*prime[j]; cnt[i*prime[j]]=1;pw[i*prime[j]]=prime[j]; &#125; else &#123; phi[i*prime[j]]=phi[i]*prime[j]; mu[i*prime[j]]=0;cnt[i*prime[j]]=cnt[i]+1;pw[i*prime[j]]=pw[i]*prime[j]; mup[i*prime[j]]=mup[i/pw[i]]*(pw[i*prime[j]]-2*pw[i*prime[j]]/prime[j]+pw[i*prime[j]]/prime[j]/prime[j]); f2[i*prime[j]]=f2[i]*((cnt[i*prime[j]]%2==1)?prime[j]:1); f3[i*prime[j]]=f3[i]*((cnt[i*prime[j]]%3==1)?prime[j]:1); break; &#125; &#125; &#125;&#125;uint A,B,C;int main ()&#123; int ca;io.Get(ca);init(); while (ca--) &#123; io.Get(A);io.Get(B);io.Get(C); uint ans=0; for (register int i=1;i&lt;=A;i++) ans+=(A/i)*(B/f2[i])*(C/f3[i])*mup[i]; io.Print(ans&amp;((1&lt;&lt;30)-1),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller_Rabin强伪素性测试]]></title>
    <url>%2Fblog%2Fmiller_rabin%2F</url>
    <content type="text"><![CDATA[Miller_Rabin强伪素性测试主要基于下面两个定理 费尔马小定理：若$gcd(a,p)=1$,则$a^{p-1}\equiv 1(mod$ &nbsp; $p)$ 二次探测定理：若p是质数且$a^2\equiv 1(mod$ &nbsp; $p)$,则$a\equiv \pm 1(mod$ &nbsp; $p)$ (对于2给出一个简单的证明: 若$a^2\equiv 1(mod$ &nbsp; $p)$,那么$p\mid a^2-1$,即$p\mid (a+1)(a-1)$,这里我们不讨论$p=2$的情况，因为p是质数，所以p不可能同时整除$a-1$和$a+1$,所以要么$p\mid a-1$,要么$p\mid a+1$,即$a\equiv \pm 1(mod$ &nbsp; $p)$) 也就是说，一旦找到任何一个$a$不满足上述条件，那么$p$一定不是质数 为什么定理1不够用还要定理2呢，因为有一种数叫Carmichael数，它们都是合数，且均满足对于$\forall a$,有$a^{p-1}\equiv 1(mod$ &nbsp; $p)$,这种数在1e8范围内只有255个，但是也足够多了 所以我们考虑下面的方法： 对于$p-1$,把它写成$p-1=2^kt$的形式,其中$p\equiv 1(mod$ &nbsp; $2)$ 随机一个小于p的数a, 快速幂算出$a^t$ 当前数是$a^t$,自乘的结果是$a^{2t}$,再自乘的结果是$a^{2^2t}$,依次类推，自乘k次后这个数就会变成$a^{2^kt}$,即$a^{p-1}$ 在3的过程中，参考上面的两条定理，我们可以得到： 如果最后这个数不等于1，那么p不是质数 如果在某一个时刻，这个数在模$p$意义下等于1,而上一时刻不等于$\pm 1$，那么$p$不是质数 我们称2和3为一次测试，一个数$p$,不是质数且通过一次测试的概率约为25%,所以多随机几次失败的概率就微乎其微]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Miller_Rabin强伪素性测试</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Miller_Rabin强伪素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard_Rho分解质因数]]></title>
    <url>%2Fblog%2Fpollard_rho%2F</url>
    <content type="text"><![CDATA[Pollard_Rho的核心思想大概是两个: 生日攻击理论 假设当前要分解的数$p=a*b$，$a$和$b$很稀有，但是$a$和$b$的倍数却有很多，所以只要找到一个数$c$，使得$gcd(c,p)&gt;1$即可 所以算法大概是这样： 在[2,n-1]之间随机一些数$x_1,x_2…x_k$,$k$大概是$n^{\frac{1}{4}}$级别 判断是否存在$gcd(\mid x_i-x_j\mid ,p)&gt;1$ 但把这些x全部预处理出来的方法太傻了，事实上我们可以先造两个数出来，然后不断地生成伪随机数，pollard告诉我们,$x_{i+1}=(x_i^2+a)%N$是一个非常好的随机函数，这里的$a$是随机的，通常随机一个不会出锅如果真的出锅了就再随机一个 不过这个随机算法有一点问题：这样随机下去之后，$x_i$会重复。如果把所有的$x_i$都存下来然后哈希显然又显得烦了一些，有两种判圈算法可以帮我们在发现入圈之后跳出去 Floyd判圈法：它的核心思想是这样的：假设乌龟和兔子在某种形状的跑道上跑，兔子的速度比乌龟快，那么除了在起点的时刻，如果兔子遇到了乌龟，说明跑道上存在环，套用在pollard_rho上，就是$x_{i+1}=(x_i^2+a)%N$这个函数，准备$x$和$y$两个变量，一个每次做一下，一个每次做两下，模拟乌龟和兔子 Brent判圈法：还是用乌龟和兔子举例子，乌龟不动，兔子每跑一步，就判断一下是否和兔子相遇，一旦兔子跑的步数是2的次幂，就把乌龟移到兔子的位置。这个算法比Floyd要好一些]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Pollard_Rho分解质因数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Pollard_Rho分解质因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6437: Videos 题解]]></title>
    <url>%2Fblog%2Fhdu6437%2F</url>
    <content type="text"><![CDATA[DescriptionC-bacteria takes charge of two kinds of videos: ’The Collection of Silly Games’ and ’The Collection of Horrible Games’. For simplicity’s sake, they will be called as videoA and videoB. There are some people who want to watch videos during today, and they will be happy after watching videos of C-bacteria. There are n hours a day, m videos are going to be show, and the number of people is K. Every video has a type(videoA or videoB), a running time, and the degree of happi- ness after someone watching whole of it. People can watch videos continuous(If one video is running on 2pm to 3pm and another is 3pm to 5pm, people can watch both of them). But each video only allows one person for watching. For a single person, it’s better to watch two kinds to videos alternately, or he will lose W happiness. For example, if the order of video is ’videoA, videoB, videoA, videoB, …’ or ’B, A, B, A, B, …’, he won’t lose happiness; But if the order of video is ’A, B, B, B, A, B, A, A’, he will lose 3W happiness. Now you have to help people to maximization the sum of the degree of happiness. InputMultiple query. On the first line, there is a positive integer T, which describe the number of data. Next there are T groups of data. for each group, the first line have four positive integers n, m, K, W : n hours a day, m videos, K people, lose W happiness when watching same videos).and then, the next m line will describe m videos, four positive integers each line S, T, w, op : video is the begin at S and end at T, the happiness that people can get is w, and op describe it’s tpye(op=0 for videoA and op=1 for videoB). There is a blank line before each groups of data. T&lt;=20, n&lt;=200, m&lt;=200, K&lt;=200, W&lt;=20, 1&lt;=S&lt;T&lt;=n, W&lt;=w&lt;=1000,op=0 or op=1 OutputYour output should include T lines, for each line, output the maximum happiness for the corresponding datum. Sample Input210 3 1 101 5 1000 05 10 1000 13 9 10 010 3 1 101 5 1000 05 10 1000 03 9 10 0 Sample Output20001990 Source2018 Multi-University Training Contest 10 Solution这题一眼网络流 我们可以对每个时刻建点，给每个点一个编号(A/B,1~n)表示上一个看的电影是A/B,当前是第i个小时，把人想象成流量 首先，一个人可以在某一个时刻什么也不干，所以(A,i)应该向(A,i+1)连一条流量为INF,费用为0的边，(B,i)应该向(B,i+1)连一条流量为INF，费用为0的边 每一步电影可以看做一条边，如果是A类型的电影，时刻从a到b,那么(A,a)应该向(B,b)连一条流量为1，费用为val的边，如果是B类型的电影，时刻从a到b,那么(B,a)应该向(A,b)连一条流量为1，费用为val的边，可以看出，这样连边如果看的电影类型交替是没有额外花费的 如果连续看同样的电影会有w的代价，所以(A,i)应该向(B,i)连一条流量为INF,费用为-w的边，同时(B,i)应该向(A,i)连一条流量为INF,费用为-w的边 最后设置源点和汇点，s向(A,1)和(B,1)连流量为INF,费用为0的边，(A,n)和(B,n)向t连流量为INF，费用为0的边 最后只要跑流量为k的最小费用流即可，最后要把答案取反 因为一开始就有负权边，所以有两种解决方案： 先跑一遍spfa，再跑带势的dijkstra 先把负权边流满，重新构图再跑费用流 考场上懒直接按1做了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=1e8;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=10000;int n,m,k,w;namespace flow&#123; int head[200048],nxt[200048],to[200048],f[200048],w[200048],tot=1,t; inline void addedge(int s,int t,int l,int cost) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=l;w[tot]=cost; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;w[tot]=-cost; &#125; int prevv[200048],preve[200048]; int h[200048]; priority_queue&lt;Pair&gt; q;int dist[200048]; inline void init() &#123; t=n*2+2; for (register int i=0;i&lt;=t;i++) head[i]=0; for (register int i=0;i&lt;=t;i++) h[i]=0; tot=1; &#125; bool dijkstra() &#123; int i,x,y,dd; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;q.push(mp(0,t)); while (!q.empty()) &#123; x=q.top().y;dd=-q.top().x;q.pop(); if (dd&gt;dist[x]) continue; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]+h[x]-h[y]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]+h[x]-h[y]; prevv[y]=x;preve[y]=i; q.push(mp(-dist[y],y)); &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; int qq[MAXN+48],Head,Tail;bool inq[MAXN+48]; bool spfa() &#123; int i,x,y; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;qq[Head=Tail=1]=t;inq[t]=true; while (Head&lt;=Tail) &#123; x=qq[Head++];inq[x]=false; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]; prevv[y]=x;preve[y]=i; if (!inq[y]) inq[y]=true,qq[++Tail]=y; &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; inline int min_cost_flow() &#123; int i,u,res,minf; for (i=0;i&lt;=t;i++) h[i]+=dist[i]; minf=INF; for (u=n*2+1;u!=t;u=prevv[u]) minf=min(minf,f[preve[u]]); res=minf*h[n*2+1]; for (u=n*2+1;u!=t;u=prevv[u]) &#123; f[preve[u]]-=minf; f[preve[u]^1]+=minf; &#125; return res; &#125; inline int ek() &#123; int ans=0; if (spfa()) &#123; do &#123; ans+=min_cost_flow(); &#125; while (dijkstra()); &#125; return -ans; &#125;&#125;int main ()&#123; int i,ca,s,t,v,op;io.Get(ca); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k);io.Get(w); flow::init(); for (i=1;i&lt;=n*2;i++) flow::addedge(0,i,INF,0),flow::addedge(i,n*2+1,INF,0); flow::addedge(n*2+2,0,k,0); for (i=1;i&lt;=n;i++) flow::addedge(i,n+i,INF,w),flow::addedge(n+i,i,INF,w); for (i=1;i&lt;=n-1;i++) flow::addedge(i,i+1,INF,0),flow::addedge(n+i,n+i+1,INF,0); for (i=1;i&lt;=m;i++) &#123; io.Get(s);io.Get(t);io.Get(v);io.Get(op); flow::addedge(op*n+s,(op^1)*n+t,1,-v); &#125; io.Print(flow::ek(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6434: Count 题解]]></title>
    <url>%2Fblog%2Fhdu6434%2F</url>
    <content type="text"><![CDATA[DescriptionMultiple query, for each n, you need to get $$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)=1]$$ InputOn the first line, there is a positive integer T, which describe the number of queries. Next there are T lines, each line give a positive integer n, as mentioned above. T&lt;=1e5, n&lt;=2e7 OutputYour output should include T lines, for each line, output the answer for the corresponding n. Sample Input4978438233666 Sample Output194041389511106589963 Source2018 Multi-University Training Contest 10 Solution我刚开始的思路是：转而考虑枚举i+j和j，但发现j的范围与i+j有关，最后不好算 我们考虑枚举一个a,i+j=2i-a,i-j=a,可以看出这样的a和j是一一对应的，且a+j=n 所以我们转而求 $$\sum_{i=1}^n\sum_{a=1}^{n-1}[gcd(2i-a,a)=1]$$ 根据辗转相减求gcd的原理，我们有$gcd(a+b,b)=gcd(a,b)$，所以$gcd(2i-a,a)=gcd(2i,a)$ 于是我们转而求 $$\sum_{i=1}^n\sum_{j=1}^{n-1}[gcd(2i,a)=1]$$ 首先a肯定是奇数，然后这时可以把2扔掉，只判断i和a是否互质 如果i是偶数，那么小于i的与i互质的数必然全都是奇数，都可以作为a，所以这时答案是$phi(i)$ 如果i是奇数，考虑任意一个小于i且与i互质的数p，则i-p也和i互质，而且p和i-p必然一奇一偶，所以所有小于i且与i互质的数中，奇数偶数各占一半，所以这时答案是$\frac{phi(i)}{2}$ 所以只要线性筛一波欧拉函数，然后前缀和一下就好了，时间复杂度O(n+T) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e7;int phi[MAXN+48],prime[MAXN+48],tot;bool isprime[MAXN+48];inline void init_phi()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i,phi[i]=i-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]) phi[i*prime[j]]=phi[i]*(prime[j]-1); else phi[i*prime[j]]=phi[i]*prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;LL ans[MAXN+48];inline void init_ans()&#123; ans[1]=0; for (register int i=2;i&lt;=MAXN;i++) if (i&amp;1) ans[i]=ans[i-1]+phi[i]/2; else ans[i]=ans[i-1]+phi[i];&#125;int main ()&#123; int ca,i,n;io.Get(ca); init_phi();init_ans(); while (ca--) &#123; io.Get(n); io.Print(ans[n],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6432: Cyclic 题解]]></title>
    <url>%2Fblog%2Fhdu6432%2F</url>
    <content type="text"><![CDATA[DescriptionCount the number of cyclic permutations of length n with no continuous subsequence [i, i + 1 mod n]. Output the answer modulo 998244353. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there is a single integer n in one line, denoting the length of cyclic permutations. 1 ≤ T ≤ 20, 1 ≤ n ≤ 100000 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 998244353. Sample Input3456 Sample Output1836 Source2018 Multi-University Training Contest 10 Solution考场上我已经想到了容斥竟然还没推出式子，卑劣地使用了OEIS，太惭愧了 容斥的思路是显然的，每次要算至少包含i个[i,i+1]片段的序列有多少种(这个“至少”指的是对于任意i个片段，这个序列都被算了一次)，这个怎么算呢？ 我们考虑所有的[i,i+1]片段，一共有[1,2],[2,3]…[n-1,n],[n,1]n种 我们考虑选出其中的i种，这i种将会在序列中出现，这个是$C_n^i$，然后我们将这些片段中的数捆在一起，比如如果选中了[1,2],[3,4]就把1和2捆在一起,3和4捆在一起; 如果选中了[1,2],[2,3]就把1,2,3三个数捆在一起。显然不论怎么选，最后一定会有n-i捆数，这些捆有$(n-i)!$种排列方法，考虑到这是一个置换群，所以1必须放在第一个，所以实际上是$(n-i-1)!$排列方法 这样我们得到了至少有i个片段的序列个数是$C_n^i(n-i-1)!$，注意到这个式子只在i=0~n-1的时候适用，当i=n时，显然有n个片段的排列只有一个，即1,2,3…n 所以最后的答案是 $$ans=(-1)^n+\sum_{i=0}^{n-1}(-1)^iC_n^i(n-i-1)!$$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int inv[MAXN+48],finv[MAXN+48],fac[MAXN+48];inline void init_inv()&#123; fac[0]=fac[1]=1; for (register int i=2;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y) &#123;return 1ll*fac[x]*finv[y]%MOD*finv[x-y]%MOD;&#125;int main ()&#123; int i,n,ans,ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);ans=0; for (i=0;i&lt;=n-1;i++) &#123; int delta=1ll*C(n,i)*fac[n-i-1]%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; if (n&amp;1) ans=sub(ans-1); else ans=add(ans+1); io.Print(ans,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6412: 公共子序列 题解]]></title>
    <url>%2Fblog%2Fhdu6412%2F</url>
    <content type="text"><![CDATA[Description光羽一点都不喜欢高代，某一次高代课上，光羽特意挑了最后一排的位置，睡着睡着，他忽然想到了这道字符串水题！ 度度熊有k(k≥2)个序列s1,s2,..,sk，每个序列的长度均为n，且序列中每个数均是1到n之间某个整数，请问这k个串有多少个长度大于0的公共子序列？ 解释：在每个序列中都选出一些位置，并将这些位置对应的字符顺次拼接起来，当它们都相等时，称其为公共子序列。 答案可能很大，请对$10^9+7$取模。 Input第一行一个数，表示数据组数T。 每组数据第一行两个数k,n；接下来k行，每行一个长度为n的序列si。 数据组数T=80，分别有20组数据满足k=2,3,4,5。 每组数据均满足1≤n≤1000，且s1,s2,…,sk中每一个数在1到n之间等概率随机生成！！ 随机生成！！ 随机生成！！ 随机生成！！ Output每组数据输出一行，每行仅包含一个数，表示公共子序列个数。 Sample Input42 31 2 12 3 13 31 2 32 3 11 2 34 33 2 23 1 32 3 13 2 15 33 1 33 1 11 2 32 3 31 3 3 Sample Output4428 Source2018“百度之星”程序设计大赛 - 复赛 Solution这么naive的题我赛场没有做出来，这种随机相关的题见的太少了…… 两个串的公共子串个数有非常简单的$O(n^2)$的dp可以解决，如果没有特殊性质，那么$k=5$时的复杂度应该是$O(n^5)$的，所以必须利用好随机这个性质 我刚开始一直在往最长公共子串很短这方面想，但这并没有什么用。我们可以考虑常规dp里的每个状态，记录的第一，二，三…个串的公共子串的最后位置p1,p2,p3…pn，要满足$s1[p1]=s2[p2]=s3[p3]=…=sn[pn]$,在随机的情况下，每个数列都接近一个排列，所以这样的状态数不会很多，期望是$O(n)$的，所以只要先搜索出所有合法的状态，再做一个$O(n^2)$的dp就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,k;int a[6][MAXN+48];vector&lt;int&gt; v[6][MAXN+48];struct node&#123; int pos[6]; inline bool operator &lt; (const node &amp;other) const &#123; for (register int i=1;i&lt;=k;i++) if (pos[i]&gt;=other.pos[i]) return false; return true; &#125;&#125;sta[MAXN*10+48],ins;int tot;int dp[MAXN*10+48];inline void dfs(int step,int type)&#123; if (step==k+1) &#123; sta[++tot]=ins; return; &#125; for (register int i=0;i&lt;int(v[step][type].size());i++) ins.pos[step]=v[step][type][i],dfs(step+1,type);&#125;inline int solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=1; for (register int i=1;i&lt;=tot;i++) if (sta[i]&lt;sta[cur]) dp[cur]=add(dp[cur]+solve(i)); return dp[cur];&#125;inline void Clear()&#123; for (register int i=1;i&lt;=k;i++) for (register int j=1;j&lt;=n;j++) v[i][j].clear();&#125;int main ()&#123; int i,j,ca;io.Get(ca); while (ca--) &#123; io.Get(k);io.Get(n);Clear(); for (i=1;i&lt;=k;i++) for (j=1;j&lt;=n;j++) io.Get(a[i][j]),v[i][a[i][j]].pb(j); tot=0; for (i=1;i&lt;=n;i++) dfs(1,i); memset(dp,-1,sizeof(dp));int ans=0; for (i=1;i&lt;=tot;i++) ans=add(ans+solve(i)); io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6403: Card Game 题解]]></title>
    <url>%2Fblog%2Fhdu6403%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob are playing a card game. In this card game, a number is written on each face of the playing card. The rule of the game is described as follows: Alice arranges the cards in a row, and for each of the cards, she chooses one of its faces to place it up; Bob turns over minimum number of cards to make all numbers on the front faces unique. They play the game some times, and Bob always succeeds making the numbers unique. However, both of them are not sure whether the number of cards flipped is minimum. Moreover, they want to figure out the number of different ways of turning over minimum number of cards to make the numbers unique. Two ways are considered equal if and only if the sets of flipped cards are equal. Please write a program to help them! InputThe first line of the input is a single integer T (1≤T≤50), the number of test cases. Each test case begins with a single line of integer n (1≤n≤105), the number of cards on the table. Then follow n lines, specifying the cards that Alice arranges. Each of these n lines contains two integers x,y (1≤x,y≤2n), meaning that Alice places a card with number x on the front face and number y on the back face. It is guaranteed that the sum of n over all test cases does not exceed 106. OutputFor each test case, display two integers in a line, the minimum number of cards to turn over, and the number of different ways of flipping modulo 998244353, respectively. If it is impossible to turn over cards to make all numbers unique, display -1 -1 instead. Sample Input341 21 34 54 621 11 131 23 45 6 Sample Output2 4-1 -10 1 HintIn the first sample test case, Bob may turn over one of the first two cards and one of the last two cards, so there are four different ways of turning over two cards tomake all numbers on the front faces unique. Obviously, this can’t be done with less than two cards flipped. In the second sample test case, it is impossible to make all numbers on the front faces unique. In the third sample test case, all numbers on the front faces are already distinct. Source2018 Multi-University Training Contest 8 Solution非常赞的图论建模题 我们可以考虑把每场卡片看成一条无向边，把数字看成点，比如卡片上的数字是u和v，就在u和v之间连一条边，这样我们的任务就是给每条边定向（显然有一种方向权值是0，另外一种方向权值是1），使得每个点被不多于一条边指向（即每条边指向的点是这张卡片最后的数字），且权值和最小 我们可以发现两个重要的性质 如果出现了一个环，那么这个环只有两种定向方式：逆时针和顺时针，即环上的每个点都会被指到 如果某个联通块中有两个环，那么必然无解。因为考虑连接两个环的路径，因为路径的两头的点都属于环中，根据性质1，这两个点都在环上被指到了，那么这条路径中的边数会比点数多1，无论如何也不可能合法定向 所以每个联通块要么是基环外向树，要么是树，分情况讨论： 基环外向树：考虑环上挂的若干棵树，因为根节点在环上已经被指到了，所以树中所有连接到根节点的边必须向下定向，同理根节点的孩子们都被指到了，所以根节点的孩子们的边也要向下定向……所以说，基环树上的每棵树的定向方式都是唯一的，即所有边都向下，然后环有两种情况，分别判一下就好。尤其要注意自环的情况，自环无论如何只可能有一种情况 树：树中有n-1条边和n个点，所以必然有且仅有一个点没有被指到，考虑一旦确定了这个没有被指到的点，以它为根，那么整棵树的定向就确定了。我们可以先考虑随便抓一个点i作为根算一遍，得到一个初始答案ans,然后再做一遍深搜枚举根，设当前根为j,我们会发现这时i到j的路径上的边会反向，其他边不变，这个可以边搜边记录，可以比较轻松的解决 至此所有情况讨论完毕，时间复杂度$O(n)$，对代码能力要求稍高 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n;vector&lt;int&gt; v[MAXN+48];bool incir[MAXN+48];struct Edge&#123; int u,v; inline void input() &#123;io.Get(u);io.Get(v);&#125;&#125;edge[MAXN+48];inline int getanother(int id,int u)&#123; return edge[id].u==u?edge[id].v:edge[id].u;&#125;int cid,cnt;int depth[MAXN+48],fa[MAXN+48],vis[MAXN+48],exist[MAXN+48];//fa didn't store his father but the id of the edge to his fatherinline void dfs(int cur,int father)&#123; fa[cur]=father;int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (!depth[y]) &#123; depth[y]=depth[cur]+1; dfs(y,id); &#125; else if (id!=father &amp;&amp; depth[y]&lt;=depth[cur]) &#123; cnt++; cid=id; &#125; &#125;&#125;int minn,minmethod;namespace cycle&#123; int cirlist[MAXN+48],ctot; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father &amp;&amp; !incir[y]) &#123; if (cur==edge[id].u) minn++; dfs(y,id); &#125; &#125; &#125; inline void solve() &#123; ctot=0;int u=edge[cid].u,v=edge[cid].v; if (depth[u]&lt;depth[v]) swap(u,v); for (register int cur=u;cur!=v;cur=getanother(fa[cur],cur)) cirlist[++ctot]=cur,incir[cur]=true; cirlist[++ctot]=v;incir[v]=true; for (register int i=1;i&lt;=ctot;i++) dfs(cirlist[i],-1); if (ctot==1) return; int cnt1=0,cnt2=0; //from down to up for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].u==cirlist[i]) cnt1++; if (edge[cid].u==cirlist[ctot]) cnt1++; //from up to down for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].v==cirlist[i]) cnt2++; if (edge[cid].u==cirlist[1]) cnt2++; minn+=min(cnt1,cnt2); if (cnt1==cnt2) minmethod=add(minmethod+minmethod); &#125;&#125;namespace tree&#123; int Minn,Cnt,ans; inline void update(int curans) &#123; if (curans&lt;Minn) Minn=curans,Cnt=1; else if (curans==Minn) Cnt++; &#125; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father) &#123; if (edge[id].u==cur) ans++; dfs(y,id); &#125; &#125; &#125; inline void Dfs(int cur,int father) &#123; update(ans);int i,id,y,delta; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id==father) continue; if (edge[id].u==cur) delta=1; else delta=-1; ans-=delta;Dfs(y,id); ans+=delta; &#125; &#125; inline void solve(int root) &#123; Minn=INF;Cnt=0; ans=0;dfs(root,-1); Dfs(root,-1); minn+=Minn;minmethod=(1ll*minmethod*Cnt)%MOD; &#125;&#125;inline void Clear()&#123; for (register int i=1;i&lt;=n*2;i++) depth[i]=0,v[i].clear(),incir[i]=false,vis[i]=false; minn=0;minmethod=1;&#125;int main ()&#123; int ca;io.Get(ca);int i; while (ca--) &#123; io.Get(n);Clear(); bool f=true; for (i=1;i&lt;=n;i++) &#123; edge[i].input(); if (edge[i].u!=edge[i].v) v[edge[i].u].pb(i),v[edge[i].v].pb(i); else v[edge[i].u].pb(i); exist[edge[i].u]=true;exist[edge[i].v]=true; if (edge[i].u==edge[i].v) &#123; if (vis[edge[i].u]) f=false; vis[edge[i].u]=true; &#125; &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; for (i=1;i&lt;=n*2;i++) if (!depth[i] &amp;&amp; exist[i]) &#123; cnt=0;cid=0; depth[i]=1;dfs(i,-1); if (cnt&gt;1) &#123;f=false;break;&#125; if (cnt==1) cycle::solve(); else tree::solve(i); &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; io.Print(minn,' ');io.Print(minmethod,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6397: Character Encoding 题解]]></title>
    <url>%2Fblog%2Fhdu6397%2F</url>
    <content type="text"><![CDATA[DescriptionIn computer science, a character is a letter, a digit, a punctuation mark or some other similar symbol. Since computers can only process numbers, number codes are used to represent characters, which is known as character encoding. A character encoding system establishes a bijection between the elements of an alphabet of a certain size n and integers from 0 to n−1. Some well known character encoding systems include American Standard Code for Information Interchange (ASCII), which has an alphabet size 128, and the extended ASCII, which has an alphabet size 256. For example, in ASCII encoding system, the word wdy is encoded as [119, 100, 121], while jsw is encoded as [106, 115, 119]. It can be noticed that both 119+100+121=340 and 106+115+119=340, thus the sum of the encoded numbers of the two words are equal. In fact, there are in all 903 such words of length 3 in an encoding system of alphabet size 128 (in this example, ASCII). The problem is as follows: given an encoding system of alphabet size n where each character is encoded as a number between 0 and n−1 inclusive, how many different words of length m are there, such that the sum of the encoded numbers of all characters is equal to k? Since the answer may be large, you only need to output it modulo 998244353. InputThe first line of input is a single integer T (1≤T≤400), the number of test cases. Each test case includes a line of three integers n,m,k (1≤n,m≤$10^5$,0≤k≤$10^5$), denoting the size of the alphabet of the encoding system, the length of the word, and the required sum of the encoded numbers of all characters, respectively. It is guaranteed that the sum of n, the sum of m and the sum of k don’t exceed $5×10^6$, respectively. OutputFor each test case, display the answer modulo 998244353 in a single line. Sample Input42 3 32 3 43 3 3128 3 340 Sample Output107903 Source2018 Multi-University Training Contest 8 Solution这题我刚开始直接无脑上了多项式快速幂，然后就T飞了，于是被戴大爷教做人……真的是知识越多越反动 我们考虑如果没有每个数在0~n-1这个条件的话，那就是一个简单的盒子可空的隔板法问题，现在加上这个限制，我们考虑容斥，那么最后的方案可以写成这样 $$ans=\sum_{i=0}^{lim}(-1)^i*f(至少有i个数大于n-1)$$ 现在考虑$f(至少有i个数大于n-1)$怎么算，我们可以先钦定哪i个位置比n-1大，这个是$C_m^i$，然后剩下的依旧是一个简单的隔板法，于是就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=3e5;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD,y&gt;&gt;=1; &#125; return res;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int fac[MAXN+48],finv[MAXN+48];inline void init_inv()&#123; fac[0]=1; for (register int i=1;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || y&lt;0 || x&lt;y) return 0; return ((1ll*fac[x]*finv[y])%MOD*finv[x-y])%MOD;&#125;int n,m,k;int main ()&#123; int ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k); int ans=0; for (register int i=0;i&lt;=m &amp;&amp; n*i&lt;=k;i++) &#123; int delta=(1ll*C(m,i)*C(k-n*i+m-1,m-1))%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>容斥原理</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6406: Taotao Picks Apples 题解]]></title>
    <url>%2Fblog%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1,h2,⋯,hn, you are required to answer some independent queries. Each query is two integers p,q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1≤T≤10), the number of test cases. Each test case begins with a line of two integers n,m (1≤n,m≤105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1,h2,⋯,hn (1≤hi≤109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1≤p≤n) and q (1≤q≤109), as described in the problem statement. OutputFor each query, display the answer in a single line. Sample Input15 31 2 3 4 41 55 52 3 Sample Output153 HintFor the first query, the heights of the apples were 5, 2, 3, 4, 4, so Taotao would only pick the first apple. For the second query, the heights of the apples were 1, 2, 3, 4, 5, so Taotao would pick all these five apples. For the third query, the heights of the apples were 1, 3, 3, 4, 4, so Taotao would pick the first, the second and the fourth apples. Source2018 Multi-University Training Contest 8 Solution我们可以先预处理原数列中会摘哪些苹果，这样对于每次询问，如果这次修改的苹果是pos，那么原数列中位置在pos前的那些苹果还是会被摘，这个可以二分一下找出在它之前的苹果个数 设之前的最后一个苹果的高度是h, 位置pos的新苹果高度为nv，分两种情况讨论： h&lt;nv 则下一个苹果是nv，在往下一个苹果是pos之后的第一个比nv大的苹果 h&gt;=nv 则下一个苹果是pos之后的第一个比h大的苹果 我们可以看出两种情况都需要支持查找在某个位置p之后，第一个比某个值val大的值在什么位置，显然我们可以二分这个位置，然后查找这个区间的max，如果max&gt;val则在位置以左，否则在位置以右，静态的查询max可以用ST表，这样复杂度可以控制在一个log 找到这关键的pos以右的第一个苹果之后，我们可以发现这之后的苹果都是原始数列的苹果，所以我们可以刚开始从后往前预处理一下从某个苹果开始向后能摘多少个苹果，加一下就好了 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;int n,m;int a[MAXN+48];int maxn[MAXN+48][21],Log[MAXN+48];inline void construct_ST()&#123; int i,j; for (i=1;i&lt;=n;i++) maxn[i][0]=a[i]; for (j=1;j&lt;=20;j++) for (i=1;i&lt;=n;i++) &#123; maxn[i][j]=maxn[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=n) maxn[i][j]=max(maxn[i][j],maxn[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (i=2;i&lt;=MAXN;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return max(maxn[l][Log[k]],maxn[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int find(int pos,int cmp)&#123; int l=pos,r=n,mid,res=-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_ST(pos,mid)&gt;cmp) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int dp[MAXN+48];inline void init_dp()&#123; for (register int i=n;i&gt;=1;i--) &#123; dp[i]=1; int res=find(i+1,a[i]); if (res!=-1) dp[i]+=dp[res]; &#125;&#125;int seq[MAXN+48],tot;inline int bsearch(int cmp)&#123; int l=1,r=tot,res=0,mid; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (seq[mid]&gt;=cmp) r=mid-1; else res=mid,l=mid+1; &#125; return res;&#125;int main ()&#123; int ca;io.Get(ca);int i,pos,nv; while (ca--) &#123; io.Get(n);io.Get(m); for (i=1;i&lt;=n;i++) io.Get(a[i]); construct_ST();init_dp();tot=0; seq[++tot]=1; for (i=2;i&lt;=n;i++) if (a[i]&gt;a[seq[tot]]) seq[++tot]=i; while (m--) &#123; io.Get(pos);io.Get(nv); int pp=bsearch(pos),ans=pp; if (!pp || a[seq[pp]]&lt;nv) &#123; ans++; int res=find(pos+1,nv); if (res!=-1) ans+=dp[res]; &#125; else &#123; int res=find(pos+1,a[seq[pp]]); if (res!=-1) ans+=dp[res]; &#125; io.Print(ans); &#125; &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>常用技术</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #1019B: The hat 题解]]></title>
    <url>%2Fblog%2Fcf1019b%2F</url>
    <content type="text"><![CDATA[DescriptionThis is an interactive problem. Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice. As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists. You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. InputAt the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students. You are allowed to ask no more than 60 questions. OutputTo ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109). When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn’t exist, you should output «! -1». In both cases you should immediately terminate the program. The query that contains your answer is not counted towards the limit of 60 queries. Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language. HackingUse the following format for hacking: In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students. In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or - 1. The hacked solution will not have direct access to the sequence ai. Examplesinput 822 output ? 4? 8! 4 input 6123210 output ? 1? 2? 3? 4? 5? 6! -1 NoteInput-output in statements illustrates example interaction. In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2 In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. Solution交互题毁我青春……本人不擅长做动脑子的题，这个花了整场比赛才做出来，于是rnk在2题里面垫底。。。 既然次数只有60次，感觉每次肯定要查询相对的两个人，相当于查询30组，估计是二分相关 我们永远考虑位置相对的两个扇形，设上面的扇形上的数字从a到A,下面的扇形上的数字从b到B 通过仔细的观察，我们能发现一些结论： 如果$abs(a-b)\equiv 1(mod 2)$，那么这两个扇形区域内必然没有任何一组数相等 如果$a&gt;b$且$A&lt;B$，那这两个扇形区域内必然有一组数相等 如果(a,A),(b,B)两个区间不相交，那么这两个扇形区域内必然没有任何一组数相等 进而我们可以发现，对于相对的两个扇形，我们二分出中间的一条线，把他们切成两组扇形，这两组扇形要么有一组铁定无解，要么至少有一组铁定有解，无论是哪一种情况，我们都可以把另一半扔掉，在必定有解的那一半里继续二分 这就是大概的思路了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);inline int getint()&#123; bool f;char ch;int res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n;int a,A,b,B,m,M;inline int myabs(int x) &#123;return x&gt;=0?x:-x;&#125;inline bool check_invalid()&#123; if (myabs(a-b)%2==0) return false; if (myabs(A-B)%2==0) return false; return true;&#125;inline bool Contain(int l1,int r1,int l2,int r2)&#123; if (l1&gt;l2 &amp;&amp; r1&lt;r2) return true; if (l1&lt;l2 &amp;&amp; r1&gt;r2) return true; return false;&#125;inline bool Away(int l1,int r1,int l2,int r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return r1&lt;l2 || r2&lt;l1;&#125;int main ()&#123; n=getint(); if (n==2) &#123; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? 2\n");fflush(stdout);scanf("%d",&amp;A); if (a==A) printf("! 1\n"); else printf("! -1\n"); return 0; &#125; int la=1,lA=n/2; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? %d\n",lA);fflush(stdout);scanf("%d",&amp;A); printf("? %d\n",la+n/2);fflush(stdout);scanf("%d",&amp;b); printf("? %d\n",lA+n/2);fflush(stdout);scanf("%d",&amp;B); if (a==b) &#123; printf("! 1\n"); return 0; &#125; if (A==B) &#123; printf("! %d\n",lA); return 0; &#125; if (check_invalid()) &#123;printf("! -1\n");return 0;&#125; while (lA-la&gt;1) &#123; int mid=(la+lA)&gt;&gt;1,to=mid+n/2; printf("? %d\n",mid);fflush(stdout);scanf("%d",&amp;m); printf("? %d\n",to);fflush(stdout);scanf("%d",&amp;M); if (m==M) &#123; printf("! %d\n",mid); return 0; &#125; if (Contain(a,m,b,M)) &#123;lA=mid;A=m;B=M;continue;&#125; if (Contain(m,A,M,B)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(a,m,b,M)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(m,A,M,B)) &#123;lA=mid;A=m;B=M;continue;&#125; &#125; if (a==b) &#123;printf("! %d\n",la);return 0;&#125; if (A==B) &#123;printf("! %d\n",lA);return 0;&#125; printf("! -1\n");return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
</search>
