<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU6397: Character Encoding 题解]]></title>
    <url>%2F2018%2F08%2F16%2Fhdu6397%2F</url>
    <content type="text"><![CDATA[DescriptionIn computer science, a character is a letter, a digit, a punctuation mark or some other similar symbol. Since computers can only process numbers, number codes are used to represent characters, which is known as character encoding. A character encoding system establishes a bijection between the elements of an alphabet of a certain size n and integers from 0 to n−1. Some well known character encoding systems include American Standard Code for Information Interchange (ASCII), which has an alphabet size 128, and the extended ASCII, which has an alphabet size 256. For example, in ASCII encoding system, the word wdy is encoded as [119, 100, 121], while jsw is encoded as [106, 115, 119]. It can be noticed that both 119+100+121=340 and 106+115+119=340, thus the sum of the encoded numbers of the two words are equal. In fact, there are in all 903 such words of length 3 in an encoding system of alphabet size 128 (in this example, ASCII). The problem is as follows: given an encoding system of alphabet size n where each character is encoded as a number between 0 and n−1 inclusive, how many different words of length m are there, such that the sum of the encoded numbers of all characters is equal to k? Since the answer may be large, you only need to output it modulo 998244353. InputThe first line of input is a single integer T (1≤T≤400), the number of test cases. Each test case includes a line of three integers n,m,k (1≤n,m≤$10^5$,0≤k≤$10^5$), denoting the size of the alphabet of the encoding system, the length of the word, and the required sum of the encoded numbers of all characters, respectively. It is guaranteed that the sum of n, the sum of m and the sum of k don’t exceed $5×10^6$, respectively. OutputFor each test case, display the answer modulo 998244353 in a single line. Sample Input4 2 3 3 2 3 4 3 3 3 128 3 340 Sample Output1 0 7 903 Source2018 Multi-University Training Contest 8 Solution这题我刚开始直接无脑上了多项式快速幂，然后就T飞了，于是被戴大爷教做人……真的是知识越多越反动 我们考虑如果没有每个数在0~n-1这个条件的话，那就是一个简单的盒子可空的隔板法问题，现在加上这个限制，我们考虑容斥，那么最后的方案可以写成这样 $$ans=\sum_{i=0}^{lim}(-1)^i*f(至少有i个数大于n-1)$$ 现在考虑$f(至少有i个数大于n-1)$怎么算，我们可以先钦定哪i个位置比n-1大，这个是$C_m^i$，然后剩下的依旧是一个简单的隔板法，于是就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=3e5;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD,y&gt;&gt;=1; &#125; return res;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int fac[MAXN+48],finv[MAXN+48];inline void init_inv()&#123; fac[0]=1; for (register int i=1;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || y&lt;0 || x&lt;y) return 0; return ((1ll*fac[x]*finv[y])%MOD*finv[x-y])%MOD;&#125;int n,m,k;int main ()&#123; int ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k); int ans=0; for (register int i=0;i&lt;=m &amp;&amp; n*i&lt;=k;i++) &#123; int delta=(1ll*C(m,i)*C(k-n*i+m-1,m-1))%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>数学-容斥</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6406: Taotao Picks Apples 题解]]></title>
    <url>%2F2018%2F08%2F16%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1,h2,⋯,hn, you are required to answer some independent queries. Each query is two integers p,q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1≤T≤10), the number of test cases. Each test case begins with a line of two integers n,m (1≤n,m≤105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1,h2,⋯,hn (1≤hi≤109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1≤p≤n) and q (1≤q≤109), as described in the problem statement. OutputFor each query, display the answer in a single line. Sample Input1 5 3 1 2 3 4 4 1 5 5 5 2 3 Sample Output1 5 3 HintFor the first query, the heights of the apples were 5, 2, 3, 4, 4, so Taotao would only pick the first apple. For the second query, the heights of the apples were 1, 2, 3, 4, 5, so Taotao would pick all these five apples. For the third query, the heights of the apples were 1, 3, 3, 4, 4, so Taotao would pick the first, the second and the fourth apples. Source2018 Multi-University Training Contest 8 Solution我们可以先预处理原数列中会摘哪些苹果，这样对于每次询问，如果这次修改的苹果是pos，那么原数列中位置在pos前的那些苹果还是会被摘，这个可以二分一下找出在它之前的苹果个数 设之前的最后一个苹果的高度是h, 位置pos的新苹果高度为nv，分两种情况讨论： h&lt;nv 则下一个苹果是nv，在往下一个苹果是pos之后的第一个比nv大的苹果 h&gt;=nv 则下一个苹果是pos之后的第一个比h大的苹果 我们可以看出两种情况都需要支持查找在某个位置p之后，第一个比某个值val大的值在什么位置，显然我们可以二分这个位置，然后查找这个区间的max，如果max&gt;val则在位置以左，否则在位置以右，静态的查询max可以用ST表，这样复杂度可以控制在一个log 找到这关键的pos以右的第一个苹果之后，我们可以发现这之后的苹果都是原始数列的苹果，所以我们可以刚开始从后往前预处理一下从某个苹果开始向后能摘多少个苹果，加一下就好了 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;int n,m;int a[MAXN+48];int maxn[MAXN+48][21],Log[MAXN+48];inline void construct_ST()&#123; int i,j; for (i=1;i&lt;=n;i++) maxn[i][0]=a[i]; for (j=1;j&lt;=20;j++) for (i=1;i&lt;=n;i++) &#123; maxn[i][j]=maxn[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=n) maxn[i][j]=max(maxn[i][j],maxn[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (i=2;i&lt;=MAXN;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return max(maxn[l][Log[k]],maxn[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int find(int pos,int cmp)&#123; int l=pos,r=n,mid,res=-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_ST(pos,mid)&gt;cmp) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int dp[MAXN+48];inline void init_dp()&#123; for (register int i=n;i&gt;=1;i--) &#123; dp[i]=1; int res=find(i+1,a[i]); if (res!=-1) dp[i]+=dp[res]; &#125;&#125;int seq[MAXN+48],tot;inline int bsearch(int cmp)&#123; int l=1,r=tot,res=0,mid; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (seq[mid]&gt;=cmp) r=mid-1; else res=mid,l=mid+1; &#125; return res;&#125;int main ()&#123; int ca;io.Get(ca);int i,pos,nv; while (ca--) &#123; io.Get(n);io.Get(m); for (i=1;i&lt;=n;i++) io.Get(a[i]); construct_ST();init_dp();tot=0; seq[++tot]=1; for (i=2;i&lt;=n;i++) if (a[i]&gt;a[seq[tot]]) seq[++tot]=i; while (m--) &#123; io.Get(pos);io.Get(nv); int pp=bsearch(pos),ans=pp; if (!pp || a[seq[pp]]&lt;nv) &#123; ans++; int res=find(pos+1,nv); if (res!=-1) ans+=dp[res]; &#125; else &#123; int res=find(pos+1,a[seq[pp]]); if (res!=-1) ans+=dp[res]; &#125; io.Print(ans); &#125; &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>数据结构-ST表</category>
        <category>常用技术</category>
        <category>常用技术-二分</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #1019B: The hat 题解]]></title>
    <url>%2F2018%2F08%2F13%2Fcf1019b%2F</url>
    <content type="text"><![CDATA[DescriptionThis is an interactive problem. Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice. As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists. You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. InputAt the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students. You are allowed to ask no more than 60 questions. OutputTo ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109). When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn’t exist, you should output «! -1». In both cases you should immediately terminate the program. The query that contains your answer is not counted towards the limit of 60 queries. Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language. HackingUse the following format for hacking: In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students. In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or - 1. The hacked solution will not have direct access to the sequence ai. Examplesinput 8 2 2 output ? 4 ? 8 ! 4 input 6 1 2 3 2 1 0 output ? 1 ? 2 ? 3 ? 4 ? 5 ? 6 ! -1 NoteInput-output in statements illustrates example interaction. In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2 In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. Solution交互题毁我青春……本人不擅长做动脑子的题，这个花了整场比赛才做出来，于是rnk在2题里面垫底。。。 既然次数只有60次，感觉每次肯定要查询相对的两个人，相当于查询30组，估计是二分相关 我们永远考虑位置相对的两个扇形，设上面的扇形上的数字从a到A,下面的扇形上的数字从b到B 通过仔细的观察，我们能发现一些结论： 如果$abs(a-b)\equiv 1(mod 2)$，那么这两个扇形区域内必然没有任何一组数相等 如果$a&gt;b$且$A&lt;B$，那这两个扇形区域内必然有一组数相等 如果(a,A),(b,B)两个区间不相交，那么这两个扇形区域内必然没有任何一组数相等 进而我们可以发现，对于相对的两个扇形，我们二分出中间的一条线，把他们切成两组扇形，这两组扇形要么有一组铁定无解，要么至少有一组铁定有解，无论是哪一种情况，我们都可以把另一半扔掉，在必定有解的那一半里继续二分 这就是大概的思路了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);inline int getint()&#123; bool f;char ch;int res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n;int a,A,b,B,m,M;inline int myabs(int x) &#123;return x&gt;=0?x:-x;&#125;inline bool check_invalid()&#123; if (myabs(a-b)%2==0) return false; if (myabs(A-B)%2==0) return false; return true;&#125;inline bool Contain(int l1,int r1,int l2,int r2)&#123; if (l1&gt;l2 &amp;&amp; r1&lt;r2) return true; if (l1&lt;l2 &amp;&amp; r1&gt;r2) return true; return false;&#125;inline bool Away(int l1,int r1,int l2,int r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return r1&lt;l2 || r2&lt;l1;&#125;int main ()&#123; n=getint(); if (n==2) &#123; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? 2\n");fflush(stdout);scanf("%d",&amp;A); if (a==A) printf("! 1\n"); else printf("! -1\n"); return 0; &#125; int la=1,lA=n/2; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? %d\n",lA);fflush(stdout);scanf("%d",&amp;A); printf("? %d\n",la+n/2);fflush(stdout);scanf("%d",&amp;b); printf("? %d\n",lA+n/2);fflush(stdout);scanf("%d",&amp;B); if (a==b) &#123; printf("! 1\n"); return 0; &#125; if (A==B) &#123; printf("! %d\n",lA); return 0; &#125; if (check_invalid()) &#123;printf("! -1\n");return 0;&#125; while (lA-la&gt;1) &#123; int mid=(la+lA)&gt;&gt;1,to=mid+n/2; printf("? %d\n",mid);fflush(stdout);scanf("%d",&amp;m); printf("? %d\n",to);fflush(stdout);scanf("%d",&amp;M); if (m==M) &#123; printf("! %d\n",mid); return 0; &#125; if (Contain(a,m,b,M)) &#123;lA=mid;A=m;B=M;continue;&#125; if (Contain(m,A,M,B)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(a,m,b,M)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(m,A,M,B)) &#123;lA=mid;A=m;B=M;continue;&#125; &#125; if (a==b) &#123;printf("! %d\n",la);return 0;&#125; if (A==B) &#123;printf("! %d\n",lA);return 0;&#125; printf("! -1\n");return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6403: Card Game 题解]]></title>
    <url>%2F2008%2F08%2F19%2Fhdu6403%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob are playing a card game. In this card game, a number is written on each face of the playing card. The rule of the game is described as follows: Alice arranges the cards in a row, and for each of the cards, she chooses one of its faces to place it up; Bob turns over minimum number of cards to make all numbers on the front faces unique. They play the game some times, and Bob always succeeds making the numbers unique. However, both of them are not sure whether the number of cards flipped is minimum. Moreover, they want to figure out the number of different ways of turning over minimum number of cards to make the numbers unique. Two ways are considered equal if and only if the sets of flipped cards are equal. Please write a program to help them! InputThe first line of the input is a single integer T (1≤T≤50), the number of test cases. Each test case begins with a single line of integer n (1≤n≤105), the number of cards on the table. Then follow n lines, specifying the cards that Alice arranges. Each of these n lines contains two integers x,y (1≤x,y≤2n), meaning that Alice places a card with number x on the front face and number y on the back face. It is guaranteed that the sum of n over all test cases does not exceed 106. OutputFor each test case, display two integers in a line, the minimum number of cards to turn over, and the number of different ways of flipping modulo 998244353, respectively. If it is impossible to turn over cards to make all numbers unique, display -1 -1 instead. Sample Input3 4 1 2 1 3 4 5 4 6 2 1 1 1 1 3 1 2 3 4 5 6 Sample Output2 4 -1 -1 0 1 HintIn the first sample test case, Bob may turn over one of the first two cards and one of the last two cards, so there are four different ways of turning over two cards tomake all numbers on the front faces unique. Obviously, this can’t be done with less than two cards flipped. In the second sample test case, it is impossible to make all numbers on the front faces unique. In the third sample test case, all numbers on the front faces are already distinct. Source2018 Multi-University Training Contest 8 Solution非常赞的图论建模题 我们可以考虑把每场卡片看成一条无向边，把数字看成点，比如卡片上的数字是u和v，就在u和v之间连一条边，这样我们的任务就是给每条边定向（显然有一种方向权值是0，另外一种方向权值是1），使得每个点被不多于一条边指向（即每条边指向的点是这张卡片最后的数字），且权值和最小 我们可以发现两个重要的性质 如果出现了一个环，那么这个环只有两种定向方式：逆时针和顺时针，即环上的每个点都会被指到 如果某个联通块中有两个环，那么必然无解。因为考虑连接两个环的路径，因为路径的两头的点都属于环中，根据性质1，这两个点都在环上被指到了，那么这条路径中的边数会比点数多1，无论如何也不可能合法定向 所以每个联通块要么是基环外向树，要么是树，分情况讨论： 基环外向树：考虑环上挂的若干棵树，因为根节点在环上已经被指到了，所以树中所有连接到根节点的边必须向下定向，同理根节点的孩子们都被指到了，所以根节点的孩子们的边也要向下定向……所以说，基环树上的每棵树的定向方式都是唯一的，即所有边都向下，然后环有两种情况，分别判一下就好。尤其要注意自环的情况，自环无论如何只可能有一种情况 树：树中有n-1条边和n个点，所以必然有且仅有一个点没有被指到，考虑一旦确定了这个没有被指到的点，以它为根，那么整棵树的定向就确定了。我们可以先考虑随便抓一个点i作为根算一遍，得到一个初始答案ans,然后再做一遍深搜枚举根，设当前根为j,我们会发现这时i到j的路径上的边会反向，其他边不变，这个可以边搜边记录，可以比较轻松的解决 至此所有情况讨论完毕，时间复杂度$O(n)$，对代码能力要求稍高 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n;vector&lt;int&gt; v[MAXN+48];bool incir[MAXN+48];struct Edge&#123; int u,v; inline void input() &#123;io.Get(u);io.Get(v);&#125;&#125;edge[MAXN+48];inline int getanother(int id,int u)&#123; return edge[id].u==u?edge[id].v:edge[id].u;&#125;int cid,cnt;int depth[MAXN+48],fa[MAXN+48],vis[MAXN+48],exist[MAXN+48];//fa didn't store his father but the id of the edge to his fatherinline void dfs(int cur,int father)&#123; fa[cur]=father;int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (!depth[y]) &#123; depth[y]=depth[cur]+1; dfs(y,id); &#125; else if (id!=father &amp;&amp; depth[y]&lt;=depth[cur]) &#123; cnt++; cid=id; &#125; &#125;&#125;int minn,minmethod;namespace cycle&#123; int cirlist[MAXN+48],ctot; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father &amp;&amp; !incir[y]) &#123; if (cur==edge[id].u) minn++; dfs(y,id); &#125; &#125; &#125; inline void solve() &#123; ctot=0;int u=edge[cid].u,v=edge[cid].v; if (depth[u]&lt;depth[v]) swap(u,v); for (register int cur=u;cur!=v;cur=getanother(fa[cur],cur)) cirlist[++ctot]=cur,incir[cur]=true; cirlist[++ctot]=v;incir[v]=true; for (register int i=1;i&lt;=ctot;i++) dfs(cirlist[i],-1); if (ctot==1) return; int cnt1=0,cnt2=0; //from down to up for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].u==cirlist[i]) cnt1++; if (edge[cid].u==cirlist[ctot]) cnt1++; //from up to down for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].v==cirlist[i]) cnt2++; if (edge[cid].u==cirlist[1]) cnt2++; minn+=min(cnt1,cnt2); if (cnt1==cnt2) minmethod=add(minmethod+minmethod); &#125;&#125;namespace tree&#123; int Minn,Cnt,ans; inline void update(int curans) &#123; if (curans&lt;Minn) Minn=curans,Cnt=1; else if (curans==Minn) Cnt++; &#125; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father) &#123; if (edge[id].u==cur) ans++; dfs(y,id); &#125; &#125; &#125; inline void Dfs(int cur,int father) &#123; update(ans);int i,id,y,delta; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id==father) continue; if (edge[id].u==cur) delta=1; else delta=-1; ans-=delta;Dfs(y,id); ans+=delta; &#125; &#125; inline void solve(int root) &#123; Minn=INF;Cnt=0; ans=0;dfs(root,-1); Dfs(root,-1); minn+=Minn;minmethod=(1ll*minmethod*Cnt)%MOD; &#125;&#125;inline void Clear()&#123; for (register int i=1;i&lt;=n*2;i++) depth[i]=0,v[i].clear(),incir[i]=false,vis[i]=false; minn=0;minmethod=1;&#125;int main ()&#123; int ca;io.Get(ca);int i; while (ca--) &#123; io.Get(n);Clear(); bool f=true; for (i=1;i&lt;=n;i++) &#123; edge[i].input(); if (edge[i].u!=edge[i].v) v[edge[i].u].pb(i),v[edge[i].v].pb(i); else v[edge[i].u].pb(i); exist[edge[i].u]=true;exist[edge[i].v]=true; if (edge[i].u==edge[i].v) &#123; if (vis[edge[i].u]) f=false; vis[edge[i].u]=true; &#125; &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; for (i=1;i&lt;=n*2;i++) if (!depth[i] &amp;&amp; exist[i]) &#123; cnt=0;cid=0; depth[i]=1;dfs(i,-1); if (cnt&gt;1) &#123;f=false;break;&#125; if (cnt==1) cycle::solve(); else tree::solve(i); &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; io.Print(minn,' ');io.Print(minmethod,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>图论</tag>
      </tags>
  </entry>
</search>
