<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LOJ2537][PKUWC2018]Minimax 题解]]></title>
    <url>%2Fblog%2Floj2537%2F</url>
    <content type="text"><![CDATA[Description小 $C$ 有一棵 $n$ 个结点的有根树，根是 $1$ 号结点，且每个结点最多有两个子结点。 定义结点 $x$ 的权值为： 若 $x$ 没有子结点，那么它的权值会在输入里给出，保证这类点中每个结点的权值互不相同。 若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$ 的概率是它的子结点的权值的最小值。 现在小 $C$ 想知道，假设 $1$ 号结点的权值有 $m$ 种可能性，权值第 $i$ 小的可能性的权值是 $V_i$​，它的概率为 $D_i(D_i&gt;0)$，求： $$\sum_{i=1}^mi\cdot V_i\cdot D_i^2$$ 你需要输出答案对 $998244353$ 取模的值。 Input Format第一行一个正整数 $n$；第二行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个结点的父亲的编号，其中第 $1$ 个结点的父亲为 $0$；第三行 $n$ 个整数，若第 $i$ 个结点没有子结点，则第 $i$ 个数为它的权值，否则第 $i$ 个数为 $p_i\cdot 10000$，保证 $p_i\cdot 10000$ 是个正整数。 Output Format输出答案 Sample Input3 0 1 1 5000 1 2 Sample Output748683266 Explanation$1$号结点的权值有 $\frac{1}{2}$​ 的概率是 $1$，有 $\frac{1}{2}$​ 的概率是 $2$，所以答案是 $\frac{5}{4}$​。 Constraints对于 $10\%$ 的数据，有 $1\leq n\leq 20$ 对于 $20\%$ 的数据，有 $1\leq n\leq 400$ 对于 $40\%$ 的数据，有 $1\leq n\leq 5000$ 对于 $60\%$ 的数据，有 $1\leq n\leq 10^5$ 另有 $10\%$ 的数据保证树的形态随机。 对于 $100\%$ 的数据，有 $1\leq n \leq 3\times 10^5,1\leq W_i\leq 10^9$。 对于所有数据，满足 $0&lt; p_i\cdot 10000&lt;10000$，所以易证明所有叶子的权值都有概率被根取到。 Solution先考虑一个显然的dp 令$dp[i][j]$表示以$i$为根的子树，最后选上来的数是第$j$大的概率。 转移还是比较好转移的，因为是二叉树，所以只要维护$j$不在的那棵子树的概率的前缀和就可以转移了，复杂度是$O(n^2)$ 考虑怎么优化。先推一波式子。对于某棵子树的某个值$x$,令$Bx$表示它的兄弟子树中出现比他大的数的概率，那么$x$贡献到父亲的概率是$$(1-p)\cdot B_x+p\cdot (1-B_x)=B_x-2pB_x+p$$ 也就是说对于某一个点只要知道$B_x$就能算出它到了父亲时出现的概率。 考虑线段树合并，动态开点线段树的叶子就表示最后出现的权值是第$i$个的概率，同时维护乘法的懒标记。这样我们考虑在合并的过程中，如果一起合并左子树，那么第二棵树的右子树的和就会贡献第一棵树的左子树的$B_x$，类似的，第一棵树的右子树的和会贡献第二棵树的左子树的$B_x$。线段树merge的时候同步记录一个sum1和sum2来表示这个贡献。这样，如果碰到仅有root1的时候，就把sum2乘到root1的懒标记上，同理，仅有root2的时候把sum1乘到root2的懒标记上。 这样总复杂度只有线段树合并的复杂度，为$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3e5;const int lim=MAXN;int n;vector&lt;int&gt; v[MAXN+48];int Inv,p[MAXN+48],ans;int vv[MAXN+48],vtot;int table[MAXN+48];int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*30+48],rson[MAXN*30+48],sum[MAXN*30+48],lazy[MAXN*30+48],tot; inline int Create() &#123; ++tot;lson[tot]=rson[tot]=0; sum[tot]=0;lazy[tot]=1; return tot; &#125; inline void pushdown(int cur) &#123; if (lazy[cur]!=1) &#123; lazy[lson[cur]]=1ll*lazy[lson[cur]]*lazy[cur]%MOD;sum[lson[cur]]=1ll*sum[lson[cur]]*lazy[cur]%MOD; lazy[rson[cur]]=1ll*lazy[rson[cur]]*lazy[cur]%MOD;sum[rson[cur]]=1ll*sum[rson[cur]]*lazy[cur]%MOD; lazy[cur]=1; &#125; &#125; inline void pushup(int cur) &#123; sum[cur]=0; if (lson[cur]) Add(sum[cur],sum[lson[cur]]); if (rson[cur]) Add(sum[cur],sum[rson[cur]]); &#125; inline void insert(int &amp;cur,int pos,int val,int l,int r) &#123; if (!cur) cur=Create(); if (l==r) &#123;sum[cur]=val;lazy[cur]=1;return;&#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(lson[cur],pos,val,l,mid); else insert(rson[cur],pos,val,mid+1,r); pushup(cur); &#125; inline int merge(int root1,int root2,int sum1,int sum2,int p,int l,int r) &#123; if (!root1 &amp;&amp; !root2) return 0; if (!root2) &#123; lazy[root1]=1ll*lazy[root1]*add(sub(sum2-2ll*p*sum2%MOD)+p)%MOD; sum[root1]=1ll*sum[root1]*add(sub(sum2-2ll*p*sum2%MOD)+p)%MOD; return root1; &#125; if (!root1) &#123; lazy[root2]=1ll*lazy[root2]*add(sub(sum1-2ll*p*sum1%MOD)+p)%MOD; sum[root2]=1ll*sum[root2]*add(sub(sum1-2ll*p*sum1%MOD)+p)%MOD; return root2; &#125; pushdown(root1);pushdown(root2); int mid=(l+r)&gt;&gt;1; lson[root1]=merge(lson[root1],lson[root2],add(sum1+(rson[root1]?sum[rson[root1]]:0)),add(sum2+(rson[root2]?sum[rson[root2]]:0)),p,l,mid); rson[root1]=merge(rson[root1],rson[root2],sum1,sum2,p,mid+1,r); pushup(root1);return root1; &#125; int cnt=0; inline void solve(int cur,int l,int r) &#123; if (!cur) return; if (l==r) &#123; cnt++;Add(ans,1ll*cnt*table[l]%MOD*sum[cur]%MOD*sum[cur]%MOD); return; &#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; solve(lson[cur],l,mid);solve(rson[cur],mid+1,r); &#125;&#125;inline void dfs(int cur)&#123; if (!int(v[cur].size())) root[cur]=SegmentTree::Create(),SegmentTree::insert(root[cur],p[cur],1,1,lim); if (int(v[cur].size())==1) dfs(v[cur][0]),root[cur]=root[v[cur][0]]; if (int(v[cur].size())==2) &#123; int y1=v[cur][0],y2=v[cur][1]; dfs(y1);dfs(y2); root[cur]=SegmentTree::merge(root[y1],root[y2],0,0,p[cur],1,lim); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);int x; for (register int i=1;i&lt;=n;i++) io.Get(x),v[x].pb(i); Inv=quick_pow(10000,MOD-2); for (register int i=1;i&lt;=n;i++) &#123; io.Get(p[i]); if (int(v[i].size())) assert(p[i]&lt;=10000),p[i]=1ll*p[i]*Inv%MOD; else vv[++vtot]=p[i]; &#125; sort(vv+1,vv+vtot+1); for (register int i=1;i&lt;=n;i++) if (!int(v[i].size())) &#123; int tmp=lower_bound(vv+1,vv+vtot+1,p[i])-vv; table[tmp]=p[i];p[i]=tmp; &#125; dfs(1);SegmentTree::solve(root[1],1,lim); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线段树合并</tag>
        <tag>LOJ</tag>
        <tag>PKUWC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029C]Lexicographic constraints 题解]]></title>
    <url>%2Fblog%2Fagc029c%2F</url>
    <content type="text"><![CDATA[Problem StatementThere are $N$ strings arranged in a row. It is known that, for any two adjacent strings, the string to the left is lexicographically smaller than the string to the right. That is, $S_1&lt;S_2&lt;…&lt;S_N$ holds lexicographically, where $S_i$ is the $i$-th string from the left. At least how many different characters are contained in $S_1,S_2,…,S_N$, if the length of $S_i$ is known to be $A_i$? Constraints $1\leq N\leq 2\times 10^5$ $1\leq A_i\leq 10^9$ $A_i$ is an integer. NoteThe strings do not necessarily consist of English alphabet; there can be arbitrarily many different characters (and the lexicographic order is defined for those characters). InputInput is given from Standard Input in the following format: N A1 A2 .. An OutputPrint the minimum possible number of different characters contained in the strings. Sample Input 13 3 2 1 Sample Output 12 The number of different characters contained in $S_1,S_2,…,S_N$ would be $3$ when, for example, $S_1=$’abc‘,$S_2=$’bb‘ and $S_3=$’c‘. However, if we choose the strings properly, the number of different characters can be$2$. Sample Input 25 2 3 2 1 2 Sample Output 22 Solutions显然答案具有单调性，考虑二分答案。 接下来是怎么check，我们的目标是尽可能最小化每个串的字典序。每次考虑相邻的两个字符串，如果后一个比前一个长，那么只要copy前一个串并在后面添上一串最小字符即可。如果后一个比前一个短，那么就要将前一个长出来的部分先截掉copy过来，然后使得最后一个字符比上一个大一。那么如果上一个的最后字符已经是最大字符了呢？那么就使得倒数第二个字符大一，最后一个字符设为最小字符，以此类推。可以发现这个很像加法的进位。如果某一次进位的时候，我们“加爆了”，就是首位也要进位，那么说明答案不合法，要寻求更大的答案，否则就可以尝试更小的答案。 分析复杂度。如果我们暴力的维护进位的话，均摊到每次只会进位$O(1)$次，复杂度可以保证。因为数位个数可能达到1e9个而可能产生的进位数量是1e5级别，所以可以用map来维护当前有进位的那些位。加上二分答案的一个log,总时间复杂度$O(nlog^2n)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,a[MAXN+48];map&lt;int,int&gt; cur;int maxbit;inline bool addone(int pt,int N)&#123; while (pt&lt;=maxbit &amp;&amp; cur[pt]==N-1) cur[pt]=0,pt++; if (pt&gt;maxbit) return false; cur[pt]++;return true;&#125;inline bool check(int N)&#123; cur.clear(); if (N==1) &#123; for (register int i=2;i&lt;=n;i++) if (a[i]&lt;=a[i-1]) return false; return true; &#125; for (register int i=2;i&lt;=n;i++) &#123; if (a[i]&gt;a[i-1]) continue; int low=maxbit-a[i]+1; while (!cur.empty() &amp;&amp; cur.begin()-&gt;x&lt;low) cur.erase(cur.begin()); bool sta=addone(low,N);if (!sta) return false; &#125; return true;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n);for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),check_max(maxbit,a[i]); int l=1,r=n,mid,ans; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>思维</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029A]Irreversible operation 题解]]></title>
    <url>%2Fblog%2Fagc029a%2F</url>
    <content type="text"><![CDATA[Problem StatementThere are $N$ Reversi pieces arranged in a row. (A Reversi piece is a disc with a black side and a white side.) The state of each piece is represented by a string $S$ of length $N$. If $S_i=$’B‘, the $i$-th piece from the left isshowing black; If $S_i=$’W‘, the $i$-th piece from the left is showing white. Consider performing the following operation: Choose $i$ $(1\leq i&lt;N)$ such that the $i$-th piece from the left is showing black and the $(i+1)$-th piece from the left is showing white, then flip both of those pieces. That is, the $i$-th piece from the left is now showing white and the $(i+1)$-th piece from the left is now showing black. Find the maximum possible number of times this operation can be performed. Constraints $1\leq \mid S\mid \leq 2\times 10^5$ $S_i=$’B‘ or ‘W‘ InputInput is given from Standard Input in the following format: S OutputPrint the maximum possible number of times the operation can be performed. Sample Input 1BBW Sample Output 12 The operation can be performed twice, as follows: Flip the second and third pieces from the left. Flip the first and second pieces from the left. Sample Input 2BWBWBW Sample Output 26 Solution我们尝试考虑当没有操作能做的时候，整个序列长什么样子。我们发现一定是所有的W在左边，所有的R在右边，否则一定会出现RW的结构。 接而我们发现每次交换一个RW就将一个在某个W之前的某个R换到后面，也就是说，对于每一个R,它要和它后面的每一个W做一次交换。 于是只要算每个R后面有多少个W即可。或者换一个角度，你可以把R和W想象成1和0,然后类似冒泡排序，需要的就是逆序对个数次交换。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;char s[MAXN+48];int n;LL ans;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); for (register int i=n,cnt=0;i&gt;=1;i--) if (s[i]=='W') cnt++; else ans+=cnt; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029B]Powers of Two 题解]]></title>
    <url>%2Fblog%2Fagc029b%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi has $N$ balls with positive integers written on them. The integer written on the $i$-th ball is $A_i$. He would like to form some number of pairs such that the sum of the integers written on each pair of balls is a power of $2$. Note that a ball cannot belong to multiple pairs. Find the maximum possible number of pairs that can be formed. Here, a positive integer is said to be a power of $2$ when it can be written as $2^t$ using some non-negative integer $t$. Constraints $1\leq N\leq 2\times 10^5$ $1\leq A_i\leq 10^9$ $A_i$ is an integer. InputInput is given from Standard Input in the following format: N A1 A2 ... An OutputPrint the maximum possible number of pairs such that the sum of the integers written on each pair of balls is a power of $2$. Sample Input 13 1 2 3 Sample Output 11 We can form one pair whose sum of the written numbers is $4$ by pairing the first and third balls. Note that we cannot pair the second ball with itself. Sample Input 25 3 11 14 5 13 Sample Output 22 Solution个人认为这题甚至比当场的E还难（大雾 看上去很像一道贪心题，但不知道该怎么做。 通过奇怪的尝试，发现从大到小给每个数匹配就是对的 还是来简单证明一下正确性，尝试考虑这个2的次幂到底提供了什么性质。我们发现，能与某个数值匹配的所有数值中，只有一个比它小，所以，我们如果对于所有能匹配的数对，从大的向小的连边，那么会形成一个树的结构。原题即要求我们将这棵树划分成尽量多的不相交的二元组。对于这个问题，还是能比较显然的看出肯定是从叶子开始贪心比较优，也就是把所有的数按从大到小的顺序来匹配。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;multiset&lt;int&gt; s;LL pw[48];int a[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int n,x;scanf("%d",&amp;n); for (register int i=1;i&lt;=n;i++) scanf("%d",&amp;x),s.insert(x);int cnt=1; for (multiset&lt;int&gt;::iterator iter=s.begin();iter!=s.end();iter++,cnt++) a[cnt]=(*iter); pw[0]=1;for (register int i=1;i&lt;=41;i++) pw[i]=pw[i-1]+pw[i-1]; int ans=0; for (register int i=n;i&gt;=1;i--) &#123; if (s.find(a[i])==s.end()) continue; multiset&lt;int&gt;::iterator iter=s.find(a[i]);s.erase(iter); int pt=31;while (a[i]+a[i]&lt;pw[pt] &amp;&amp; pt) pt--; for (register int j=pt;j&gt;=1;j--) &#123; int need=pw[j]-a[i]; if (s.find(need)!=s.end()) &#123; iter=s.find(need);s.erase(iter); ++ans;break; &#125; &#125; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029D]Grid game 题解]]></title>
    <url>%2Fblog%2Fagc029d%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi and Aoki will play a game using a grid with $H$ rows and $W$ columns of square cells. There are $N$ obstacles on this grid; the $i$-th obstacle is at $(X_i,Y_i)$. Here, we represent the cell at the $i$-th row and $j$-th column $(1\leq i\leq H,1\leq j\leq W)$ by$(i,j)$ . There is no obstacle at $(1,1)$, and there is a piece placed there at $(1,1)$. Starting from Takahashi, he and Aoki alternately perform one of the following actions: Move the piece to an adjacent cell. Here, let the position of the piece be $(x,y)$. Then Takahashi can only move the piece to $(x+1,y)$, and Aoki can only move the piece to $(x,y+1)$. If the destination cell does not exist or it is occupied by an obstacle, this action cannot be taken. Do not move the piece, and end his turn without affecting the grid. The game ends when the piece does not move twice in a row. Takahashi would like to perform as many actions (including not moving the piece) as possible before the game ends, while Aoki would like to perform as few actions as possible before the game ends. How many actions will Takahashi end up performing? Constraints $1\leq H,W\leq 2\times 10^5$ $0\leq N\leq 2\times 10^5$ $1\leq X_i\leq H$ $1\leq Y_i\leq W$ if $i\neq j,(X_i,Y_i)\neq (X_j,Y_j)$ $(X_i,Y_i)\neq (1,1)$ $X_i$ and $Y_i$ are integers. InputInput is given from Standard Input in the following format: H W N X1 Y1 . . . Xn Yn OutputPrint the number of actions Takahashi will end up performing. Sample Input 13 3 1 3 2 Sample Output 12 For example, the game proceeds as follows: Takahashi moves the piece to $(2,1)$. Aoki does not move the piece. Takahashi moves the piece to $(3,1)$. Aoki does not move the piece. Takahashi does not move the piece. Takahashi performs three actions in this case, but if both players play optimally, Takahashi will perform only two actions before the game ends. Sample Input 210 10 14 4 3 2 2 7 3 9 10 7 7 8 1 10 10 5 4 3 4 2 8 6 4 4 4 5 8 9 2 Sample Output 26 Sample Input 3100000 100000 0 Sample Output 3100000 Solution感觉这题放D有点水了。 首先一个显然的性质是只要A还有路可走，他就一定会把棋子向下移，否则只要B也停下来游戏就玩完了。 那么B就有选择是否在当前这一列结束游戏的权利。 直接模拟移动的过程，如果选择在当前列结束，就找一下这一列当前点下方最靠上的障碍物（包括地图的下边界）算一下步数，否则如果可以向右走的话就向右走。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int h,w,n;vector&lt;int&gt; v[MAXN+48];int pt[MAXN+48];map&lt;Pair,int&gt; Mp;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d%d",&amp;h,&amp;w,&amp;n);int ans=h,x,y; for (register int i=1;i&lt;=n;i++) scanf("%d%d",&amp;x,&amp;y),v[y].pb(x),Mp[mp(x,y)]=1; for (register int i=1;i&lt;=w;i++) sort(v[i].begin(),v[i].end()),pt[i]=0; x=1;y=1;int cnt=0; for (;;) &#123; // cerr&lt;&lt;"*"&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;cnt&lt;&lt;endl; while (pt[y]&lt;=int(v[y].size())-1 &amp;&amp; v[y][pt[y]]&lt;x) pt[y]++; int lim=(pt[y]&lt;=int(v[y].size())-1)?v[y][pt[y]]:h+1; check_min(ans,cnt+lim-x); if (lim==x+1) break;if (y==w) break; ++x;++cnt; if (Mp.find(mp(x,y+1))==Mp.end()) ++y; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029F]Construction of a tree 题解]]></title>
    <url>%2Fblog%2Fagc029f%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given $N−1$ subsets of ${1,2,3,…,N}$. Let the $i$-th set be $E_i$. Let us choose two distinct elements $u_i$ and $v_i$ from each set $E_i$, and consider a graph $T$ with $N$ vertices and $N−1$ edges, whose vertex set is ${1,2,3,…,N}$ and whose edge set is $(u_1,v_1),(u_2,v_2),…,(u_{N-1},v_{N-1})$. Determine if $T$ can be a tree by properly deciding $u_i$ and $v_i$. If it can,additionally find one instance of $(u_1,v_1),(u_2,v_2),…,(u_{N-1},v_{N-1})$ such that $T$ is actually a tree. Constraints $2\leq N\leq 10^5$ $E_i$ is a subset of ${1,2,3,…,N}$. $\mid E_i\mid \geq 2$ The sum of $\mid E_i\mid$ is at most $2\times 10^5$. InputInput is given from Standard Input in the following format: N c1 w(1,1) w(1,2) ... w(1,c1) . . cn-1 w(n-1,1) w(n-1,2) ... w(n-1,cn-1) Here, $c_i$ stands for the number of elements in $E_i$, and $w_{i,1}…w_{i,c_i}$ are the $c_i$ elements in $c_i$. Here, $2\leq c_i\leq N,1\leq w_{i,j}\leq N$, and $w_{i,j}\neq w_{i,k}(1\leq j&lt;k\leq c_i)$ hold. OutputIf $T$ cannot be a tree, print -1; otherwise, print the choices of $(u_i,v_i)$ that satisfy the condition, in the following format: u1 v1 u2 v2 . . un-1 vn-1 Sample Input 15 2 1 2 3 1 2 3 3 3 4 5 2 4 5 Sample Output 11 2 1 3 3 4 4 5 Sample Input 26 3 1 2 3 3 2 3 4 3 1 3 4 3 1 2 4 3 4 5 6 Sample Output 2-1 Sample Input 310 5 1 2 3 4 5 5 2 3 4 5 6 5 3 4 5 6 7 5 4 5 6 7 8 5 5 6 7 8 9 5 6 7 8 9 10 5 7 8 9 10 1 5 8 9 10 1 2 5 9 10 1 2 3 Sample Output 31 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 Solution膜了wxh的博客，并没有怎么搞懂，准备以后再填坑。 考虑到每条边都连接着一个父亲和儿子，而除了根节点每个节点都有且仅有一个父亲，我们不妨令所有的$u_i$为儿子，$v_i$为父亲，那么$u_i$一定是一个2~n的排列。我们可以先用最大流来判断一下是否能分配出一个排列，只要像二分图匹配那样建图即可。 如果能给出一个排列，考虑怎么构造答案。考虑如下贪心：刚开始我们已经确定了1，然后我们把所有包含1的集合加入一个队列，给这些点都认领$1$作为父亲。之后每次从队列中取出一个集合编号$i$，就把包含$u_i$的集合加入队列中。 这个贪心显然是对的。但wxh说初始的$u_i$的选择不会影响结果，如果有解就能构造出来，如果无解选择任意一组$u_i$均无解，这个就不懂了（菜的真实 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n;vector&lt;int&gt; a[MAXN+48];vector&lt;int&gt; v[MAXN+48];int u[MAXN+48];bool inq[MAXN+48];int head,tail,q[MAXN+48];int ans[MAXN+48];namespace flow&#123; int head[800048],cur[800048],to[800048],nxt[800048],f[800048],tot,t; inline void init() &#123;memset(head,0,sizeof(head));tot=1;&#125; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[800048],Head,Tail;int depth[800048]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; if (depth[t]==-1) return false; else return true; &#125; inline int dfs(int x,int maxf) &#123; if (x==t || !maxf) return maxf; int y,minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; &#125; if (ans&gt;=maxf) return ans; &#125; if (!ans) depth[x]=0; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n);int num,x; for (register int i=1;i&lt;=n-1;i++) &#123; scanf("%d",&amp;num); while (num--) &#123; scanf("%d",&amp;x); a[i].pb(x);v[x].pb(i); &#125; &#125; flow::init();flow::t=n+n+1; for (register int i=1;i&lt;=n-1;i++) flow::addedge(0,i,1); for (register int i=2;i&lt;=n;i++) flow::addedge(n+i,flow::t,1); for (register int i=1;i&lt;=n-1;i++) for (auto to : a[i]) if (to!=1) flow::addedge(i,n+to,1); int res=flow::dinic(); if (res!=n-1) &#123;puts("-1");return 0;&#125; for (register int i=1;i&lt;=n-1;i++) for (register int j=flow::head[i];j;j=flow::nxt[j]) &#123; int y=flow::to[j]; if (n+2&lt;=y &amp;&amp; y&lt;=n+n &amp;&amp; flow::f[j]==0) &#123;u[i]=y-n;break;&#125; &#125; memset(inq,false,sizeof(inq));head=1;tail=0; for (auto item : v[1]) q[++tail]=item,q[++tail]=1,inq[item]=true; while (head&lt;=tail) &#123; int cur=q[head++],father=q[head++]; ans[cur]=father; for (auto item : v[u[cur]]) if (!inq[item]) inq[item]=true,q[++tail]=item,q[++tail]=u[cur]; &#125; for (register int i=1;i&lt;=n-1;i++) if (!ans[i]) &#123;puts("-1");return 0;&#125; for (register int i=1;i&lt;=n-1;i++) printf("%d %d\n",u[i],ans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029E]Wandering TKHS 题解]]></title>
    <url>%2Fblog%2Fagc029e%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi’s office has $N$ rooms. Each room has an ID from $1$ to $N$. There are also $N−1$ corridors, and the $i$-th corridor connects Room $a_i$ and Room $b_i$. It is known that we can travel between any two rooms using only these corridors. Takahashi has got lost in one of the rooms. Let this room be $r$. He decides to get back to his room, Room $1$, by repeatedly traveling in the following manner: Travel to the room with the smallest ID among the rooms that are adjacent to the rooms already visited, but not visited yet.Let $c_r$ be the number of travels required to get back to Room $1$. Find all of $c_2,c_3,…,c_N$ . Note that, no matter how many corridors he passes through in a travel, it still counts as one travel. Constraints $2\leq N\leq 2\times 10^5$ $1\leq a_i,b_i\leq N$ $a_i\neq b_i$ The graph given as input is a tree. InputInput is given from Standard Input in the following format: N a1 b1 . . . an-1 bn-1 OutputPrint $c_r$ for each $r$, in the following format: c2 c3 ... cn Sample Input 16 1 5 5 6 6 2 6 3 6 4 Sample Output 15 5 5 1 5 For example, if Takahashi was lost in Room $2$, he will travel as follows: Travel to Room $6$. Travel to Room $3$. Travel to Room $4$. Travel to Room $5$. Travel to Room $1$. Sample Input 26 1 2 2 3 3 4 4 5 5 6 Sample Output 21 2 3 4 5 Sample Input 310 1 5 5 6 6 10 6 4 10 3 10 8 8 2 4 7 4 9 Sample Output 37 5 3 1 3 4 7 4 5 Solution首先一个显然的性质是我们最后经过的所有的点是树上的一个联通块。 考虑对于任意一个点的c值该怎么求。我们发现一个点要到达根节点，至少要做的事情是打通从它到1的这条路径。 然后考虑这条链上挂的若干棵子树。我们发现对于每棵子树，与子树根连通的所有小于从1到子树根祖父的max的节点会访问到，其他的不会访问到（有点拗口）。 如果我们提前求好了每个节点的上述东西的答案。那我们只要一边搜索一边把各个子树的答案加起来，就可以得到所有的c了。 接下来考虑怎么算之前的那个东西。因为是祖父，跨过了父亲，所以有些难算。考虑离线。我们把所有的点按照1~祖父的max从小到大排序。这样我们可以按照编号去依次“点亮”一些节点，然后每次来统计某棵子树内和根节点相连的“点亮”的节点的个数。一个显然的想法是每次点亮一个节点后用LCT来维护子树和，但太难写了，没有很好的运用树的结构是固定的这个性质。 考虑这样一个做法：事实上我们要支持的是一些link操作。每次link会影响的节点是从被link的节点向上的一条被点亮的链的子树和。这样我们可以在树上打差分标记，在链的最下端加，在链的最上端的父亲减，这样把树映射到dfs序上之后只要查一个子树在dfs序上的和就行了。至于怎么找最上端的点，可以考虑并查集。定义一个联通块的代表元是深度最小的节点即可。 因为有一个BIT，所以总时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,maxn[MAXN+48],fa[MAXN+48];vector&lt;int&gt; v[MAXN+48];int dp[MAXN+48],ans[MAXN+48];int L[MAXN+48],R[MAXN+48],ind;int id[MAXN+48];inline bool cmp(int x,int y)&#123; int xx=fa[fa[x]],yy=fa[fa[y]]; return maxn[xx]&lt;maxn[yy];&#125;bool exist[MAXN+48];namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=1;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;namespace BIT&#123; int c[MAXN+48]; inline void init() &#123;memset(c,0,sizeof(c));&#125; inline void update(int x,int delta) &#123;if (!x) return;while (x&lt;=n) c[x]+=delta,x+=LOWBIT(x);&#125; inline int query(int x) &#123;int res=0;while (x) res+=c[x],x^=LOWBIT(x);return res;&#125; inline int calc(int x,int y) &#123;return query(y)-query(x-1);&#125;&#125;inline void dfs(int cur,int father)&#123; L[cur]=++ind;fa[cur]=father; for (auto y : v[cur]) if (y!=father) maxn[y]=max(maxn[cur],y),dfs(y,cur); R[cur]=ind;&#125;inline void Dfs(int cur,int father,int curans)&#123; int cursum=0; for (auto y : v[cur]) if (y!=father) cursum+=dp[y]; ans[cur]=curans+1+cursum; for (auto y : v[cur]) if (y!=father) Dfs(y,cur,curans+1+cursum-dp[y]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n); for (register int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); v[x].pb(y);v[y].pb(x); &#125; maxn[1]=1;dfs(1,0); for (register int i=1;i&lt;=n;i++) id[i]=i; maxn[0]=INF;sort(id+1,id+n+1,cmp); DSU::init();BIT::init();int curpt=0; for (register int i=1;i&lt;=n;i++) &#123; if (fa[fa[id[i]]]==0) continue; int need=maxn[fa[fa[id[i]]]]; while (curpt&lt;need-1) &#123; ++curpt;exist[curpt]=true; BIT::update(L[curpt],1);BIT::update(L[fa[curpt]],-1); for (auto y : v[curpt]) if (exist[y]) &#123; int xx=curpt,yy=y;if (fa[xx]==yy) swap(xx,yy); int ynum=BIT::calc(L[yy],R[yy]),anc=DSU::find_anc(xx); BIT::update(L[xx],ynum);BIT::update(L[fa[anc]],-ynum); DSU::update(yy,xx); &#125; &#125; dp[id[i]]=BIT::calc(L[id[i]],R[id[i]]); &#125; Dfs(1,0,0); for (register int i=2;i&lt;=n;i++) printf("%d ",ans[i]-1); puts(""); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>BIT</category>
        <category>dfs序</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>并查集</tag>
        <tag>BIT</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #3][NOI2014]魔法森林 题解]]></title>
    <url>%2Fblog%2Fuoj3%2F</url>
    <content type="text"><![CDATA[Description为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个$N$节点$M$条边的无向图，节点标号为 $1…n$，边标号为$1…m$。初始时小E同学在 $1$ 号节点，隐士则住在 $n$ 号节点。小E需要通过这一片魔法森林，才能够拜访到隐士。 魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。 只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$。若身上携带的A型守护精灵个数不少于 $a_i$，且B型守护精灵个数不少于 $b_i$，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。 由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。 Input Format第$1$行包含两个整数 $n$,$m$，表示无向图共有 $n$ 个节点，$m$ 条边。 接下来 $m$ 行，第 $i+1$ 行包含4个正整数 $x_i$,$y_i$,$a_i$,$b_i$，描述第 $i$ 条无向边。其中 $x_i$ 与 $y_i$ 为该边两个端点的标号，$a_i$ 与 $b_i$的含义如题所述。 注意数据中可能包含重边与自环。 Output Format输出一行一个整数：如果小E可以成功拜访到隐士，输出小E最少需要携带的守护精灵的总个数；如果无论如何小E都无法拜访到隐士，输出“$-1$”（不含引号）。 Sample Input 14 5 1 2 19 1 2 3 8 12 2 4 12 15 1 3 17 8 3 4 1 17 Sample Output 132 Explanation 1如果小E走路径1→2→4，需要携带 $19+15=34$ 个守护精灵； 如果小E走路径1→3→4，需要携带 $17+17=34$ 个守护精灵； 如果小E走路径1→2→3→4，需要携带 $19+17=36$ 个守护精灵； 如果小E走路径1→3→2→4，需要携带 $17+15=32$ 个守护精灵。 综上所述，小E最少需要携带 $32$ 个守护精灵。 Sample Input 23 1 1 2 1 1 Sample Output 2-1 Explanation 2小E无法从$1$号节点到达$3$号节点，故输出$-1$。 Constraints 对于$100\%$的数据，$2\leq n\leq 50000$,$0\leq m\leq 100000$,$1\leq a_i,b_i\leq 50000$ Solution将所有的边按照$a_i$为关键字升序从小到大排序，这样我们之后可以从小到大枚举最后的$A$，随着$A$的增大，我们可用的边也就逐渐增多，要在这个不断加边的图中找到让$B$最小的方案。 不难发现，对于图中的任意两点，使得他们之间的路径的最大值最小，这条路径一定在图的最小生成树上，因此我们只要动态的维护以$b_i$为边权的图的最小生成树即可。 考虑用LCT维护最小生成树。对于当前的一条新边$(x,y)$，如果$x$,$y$不连通就直接link。否则我们找到$x$到$y$的路径上的最大边，如果最大边的权值大于当前边，就cut掉最大边，link上当前边，否则直接丢掉当前边。 PS: 注意LCT判断两个点是否连通的条件:应该都find_root之后判断根是否相同。 Code这份代码在UOJ上97pts,可能常数大了点，洛谷是能过的2333123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,m;struct Edge&#123; int u,v,a,b; inline void input() &#123;scanf("%d%d%d%d",&amp;u,&amp;v,&amp;a,&amp;b);&#125; inline bool operator &lt; (const Edge &amp;other) const &#123;return a&lt;other.a;&#125;&#125;edge[MAXN+48];namespace LCT&#123; struct node &#123; int ch[2],val,maxn,maxind,flip,father; &#125;tree[MAXN+48]; inline void update(int x,int y) &#123; if (!y) return; if (tree[y].maxn&gt;tree[x].maxn) tree[x].maxn=tree[y].maxn,tree[x].maxind=tree[y].maxind; &#125; inline void pushup(int cur) &#123; tree[cur].maxn=tree[cur].val;tree[cur].maxind=cur; update(cur,tree[cur].ch[0]);update(cur,tree[cur].ch[1]); &#125; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].ch[0]].flip^=1; tree[tree[cur].ch[1]].flip^=1; tree[cur].flip=0;swap(tree[cur].ch[0],tree[cur].ch[1]); &#125; &#125; inline void Create(int cur,int val) &#123; tree[cur].val=val;tree[cur].ch[0]=tree[cur].ch[1]=tree[cur].flip=tree[cur].father=0; pushup(cur); &#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; pushdown(y);pushdown(x); int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; pushdown(x); while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void makeroot(int cur) &#123; access(cur);splay(cur); tree[cur].flip^=1; &#125; inline int find_root(int x) &#123; access(x);splay(x); while (tree[x].ch[0]) x=tree[x].ch[0]; return x; &#125; inline bool issame(int x,int y) &#123; return find_root(x)==find_root(y); &#125; inline void link(int x,int y) &#123; makeroot(x); tree[x].father=y; &#125; inline void cut(int x,int y) &#123; makeroot(x);access(y);splay(y); tree[x].father=0;tree[y].ch[0]=0;pushup(y); &#125; inline Pair query(int x,int y) &#123; makeroot(x);access(y);splay(y); return mp(tree[y].maxn,tree[y].maxind); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m); for (register int i=1;i&lt;=m;i++) edge[i].input(); sort(edge+1,edge+m+1); for (register int i=1;i&lt;=n;i++) LCT::Create(i,0); for (register int i=1;i&lt;=m;i++) LCT::Create(n+i,edge[i].b); int ans=INF; for (register int i=1;i&lt;=m;i++) &#123; if (edge[i].a&gt;=ans) break; if (edge[i].u!=edge[i].v) &#123; if (!LCT::issame(edge[i].u,edge[i].v)) LCT::link(n+i,edge[i].u),LCT::link(n+i,edge[i].v); else &#123; Pair res=LCT::query(edge[i].u,edge[i].v); if (res.x&gt;edge[i].b) &#123; LCT::cut(res.y,edge[res.y-n].u);LCT::cut(res.y,edge[res.y-n].v); LCT::link(n+i,edge[i].u);LCT::link(n+i,edge[i].v); &#125; &#125; &#125; if (LCT::issame(1,n)) check_min(ans,edge[i].a+LCT::query(1,n).x); &#125; if (ans&gt;=INF) ans=-1; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数据结构</category>
        <category>最小生成树</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>LCT</tag>
        <tag>UOJ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4530][BJOI2014]大融合 题解]]></title>
    <url>%2Fblog%2Fbzoj4530%2F</url>
    <content type="text"><![CDATA[Description小强要在$N$个孤立的星球上建立起一套通信系统。这套通信系统就是连接$N$个点的一个树。这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。 例如，在上图中，现在一共有了$5$条边。其中，$(3,8)$这条边的负载是$6$，因为有六条简单路径$2$-$3$-$8$,$2$-$3$-$8$-$7$,$3$-$8$,$3$-$8$-$7$,$4$-$3$-$8$,$4$-$3$-$8$-$7$路过了$(3,8)$。 现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。 Input第一行包含两个整数$N$,$Q$，表示星球的数量和操作的数量。星球从$1$开始编号。 接下来的$Q$行，每行是如下两种格式之一： A x y 表示在$x$和$y$之间连一条边。保证之前$x$和$y$是不联通的。 Q x y 表示询问$(x,y)$这条边上的负载。保证$x$和$y$之间有一条边。 Output对每个查询操作，输出被查询的边的负载。 Sample Input8 6 A 2 3 A 3 4 A 3 8 A 8 7 A 6 5 Q 3 8 Sample Output6 Constraints$1\leq N,Q\leq 100000$ Solution一条边的访问个数就是他两端的子树大小之积。所以只要用LCT维护子树大小即可。 经典的LCT是维护链上信息的。考虑如何用LCT维护子树信息。我们定义一个节点在splay中的儿子为实儿子，只由儿子指向父亲，父亲不指向儿子的儿子为虚儿子。 我们考虑某个节点$x$在LCT中对应的点，在$x$子树内的节点在LCT中有以下两种： 和当前点在同一棵splay中且中序遍历之后在$z$之后。因为splay是以深度为关键字维护一条重链，同在一条链中且深度比$x$大自然在$x$的子树内。 $x$的所有虚儿子的子树和。 于是我们考虑对于LCT中的每个节点，多维护一个vsum表示所有虚儿子的子树和,一个sum表示所有虚儿子的子树和加上splay中他的子树的和。我们发现LCT的所有操作中只有access和link两种操作和虚儿子有关。 对于link操作，有一个动作是将$x$挂到$y$的下方作为$y$的虚儿子，此时我们只要将$y$的vsum加上$x$的sum即可。 对于access操作，本质上它是修改了一串节点的实儿子，相当于废掉一个实儿子，又从虚儿子中拎了一个出来作为实儿子。我们只要对于vsum加上前实儿子（现虚儿子）的sum,减去前虚儿子（现实儿子）的sum即可。 查询的时候按照上面的两点统计答案即可。其他操作都和经典LCT一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,q;namespace LCT&#123; struct node &#123; int ch[2],vsum,sum,Sum,father; int flip; &#125;tree[MAXN+48]; inline void init() &#123; for (register int i=1;i&lt;=n;i++) tree[i].ch[0]=tree[i].ch[1]=tree[i].flip=0,tree[i].vsum=0,tree[i].sum=tree[i].Sum=1,tree[i].father=0; &#125; inline void pushup(int cur) &#123; tree[cur].sum=tree[tree[cur].ch[0]].sum+tree[tree[cur].ch[1]].sum+tree[cur].vsum+1; tree[cur].Sum=tree[tree[cur].ch[1]].sum+tree[cur].vsum+1; &#125; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].ch[0]].flip^=1; tree[tree[cur].ch[1]].flip^=1; swap(tree[cur].ch[0],tree[cur].ch[1]); tree[cur].flip=0; &#125; &#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; pushdown(y);pushdown(x); int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; pushdown(x); while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].vsum+=tree[tree[cur].ch[1]].sum; tree[cur].vsum-=tree[pre].sum; tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void makeroot(int cur) &#123; access(cur);splay(cur);tree[cur].flip^=1; pushdown(cur);pushup(cur); &#125; inline void link(int x,int y) &#123; makeroot(x);access(y);splay(y); tree[x].father=y;tree[y].vsum+=tree[x].sum; pushup(y); &#125; inline LL query(int x,int y) &#123; makeroot(x);makeroot(y); return 1ll*tree[x].Sum*(tree[y].Sum-tree[x].Sum); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q);char op[5];int x,y; LCT::init();int cnt=0; while (q--) &#123; ++cnt; scanf("%s%d%d",op+1,&amp;x,&amp;y); if (op[1]=='A') LCT::link(x,y); else printf("%lld\n",LCT::query(x,y)); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder4415][JAGSC2018]ADD DIV MAX RESTORE 题解]]></title>
    <url>%2Fblog%2Fatcoder4415%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given an integer sequence $a_0,a_1,…,a_{N−1}$. You have to perform $Q$ queries, each query is one of the following: ADD QUERY(t=0 l r x) : for each $i$ between $l$ and $r$, inclusive, replace $a_i$ with $a_i+x$. DIV QUERY(t=1 l r x) : for each i between $l$ and $r$, inclusive, replace ai with $floor(a_i⁄x)$, where $floor(y)$ is the biggest integer that is not greater than $y$. MAX QUERY(t=2 l r x=0) : print $max(a_l,a_{l+1},…,a_r)$. RESTORE QUERY(t=3 l r x=0) : for each $i$ between $l$ and $r$, inclusive, set $a_i$ to the initial value of $a_i$, that is, the value given in the input. Constraints All input values are integers. $1\leq N,Q\leq 200,000$ $0\leq a_i\leq 10^8$ $t_i=0,1,2,3$ $0\leq l_i\leq r_i\leq N−1$ $1\leq x_i\leq 1000$(when $t_i\neq 2,3$) InputInput is given from Standard Input in the following format: N Q a0 a1 ... aN−1 t1 l1 r1 x1 t2 l2 r2 x2 : tQ lQ rQ xQ OutputFor each MAX QUERY, print $max(a_l,a_{l+1},…,a_r)$, one per line. Sample Input 15 9 1 2 3 4 5 2 0 4 0 0 0 1 10 2 0 4 0 2 2 2 0 1 0 1 4 2 0 0 0 2 1 1 0 3 0 4 0 2 0 1 0 Sample Output 15 12 3 2 3 2 $max(1,2,3,4,5)=5$ $1,2,3,4,5\rightarrow 11,12,3,4,5$ $max(11,12,3,4,5)=12$ $max(3)=3$ $11,12,3,4,5\rightarrow 2,3,3,4,5$ $max(2)=2$ $max(3)=3$ The array is restored to $1,2,3,4,5$ $max(1,2)=2$ Sample Input 24 7 0 1 0 1 2 0 3 0 0 0 3 1 1 0 3 2 2 0 3 0 0 0 3 1 1 0 3 2 2 0 3 0 Sample Output 21 1 1 Sample Input 310 23 13 1 22 8 28 18 23 9 22 27 1 3 4 5 1 8 8 8 0 3 9 5 0 2 6 3 3 0 4 0 1 1 3 7 2 2 2 0 2 3 5 0 0 1 4 2 3 0 9 0 2 0 1 0 0 3 9 8 2 1 9 0 0 8 9 5 1 5 7 7 0 3 5 7 0 7 9 7 3 3 6 0 2 1 6 0 0 1 1 7 1 4 8 10 2 0 9 0 1 5 6 1 Sample Output 33 28 13 36 28 47 Solution看到这个除法的时候以为是吉司机线段树相关，但又有RESTORE操作，不知道该怎么弄。 听了题解发现很神。除法难就难在不知道该怎么在线段树上维护懒标记。我们可以像这样维护标记：$$x\rightarrow \frac{x+d-a}{d}+e$$ 这里的$a\in [0,d-1]$,否则可以除出去加到$e$上 首先考虑加法操作，这个比较简单，直接在$e$上加就可以了 然后考虑除法操作，设要除以x,我们先通分：$$\frac{d-a}{d}+e=\frac{d-a+de}{d}$$ 现在新的除数变成了$dx$,我们拿$d-a+de$整除$dx$的结果作为新的$e$，拿$dx$减模数作为新的$a$即可。 这里要注意的是$dx$一直乘下去可能会爆long long，但因为加法操作的和不会超过$10^8$,所以$dx$和$1e9$取一个min就可以了。 最后考虑标记的合并。因为每次都会有pushdown操作，所以父节点的标记一定是后于子节点的，所以拿着父节点的标记对着子节点先加，再除，最后加即可。 这样这题剩下的部分就是基本的线段树操作了。至于RESTORE操作，可以额外维护一个flushed标记表示是否被清空。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct Tag &#123; LL a,d,e; Tag () &#123;&#125; inline void clear() &#123;a=1;d=1;e=0;&#125; inline Tag(LL _a,LL _d,LL _e) &#123;a=_a;d=_d;e=_e;&#125; inline Tag operator + (LL other) &#123;return Tag(a,d,e+other);&#125; inline Tag operator / (LL other) &#123; LL tmp=d-a+d*e,nd=d*other; LL ne=tmp/nd,na=nd-tmp%nd; check_min(nd,1ll*INF);check_min(na,1ll*INF); return Tag(na,nd,ne); &#125; inline void merge(Tag other) &#123; Tag tmp=(*this); tmp=(tmp+(other.d-other.a))/other.d+other.e; (*this)=tmp; &#125; inline int getval(int x) &#123;return (x+d-a)/d+e;&#125; &#125;; Tag lazy[MAXN*4];int ori[MAXN*4],maxn[MAXN*4];bool flushed[MAXN*4]; inline void pushup(int cur) &#123; maxn[cur]=max(maxn[cur&lt;&lt;1],maxn[cur&lt;&lt;1|1]); &#125; inline void pushdown(int cur) &#123; if (flushed[cur]) &#123; flushed[cur&lt;&lt;1]=flushed[cur&lt;&lt;1|1]=true; lazy[cur&lt;&lt;1].clear();lazy[cur&lt;&lt;1|1].clear(); maxn[cur&lt;&lt;1]=ori[cur&lt;&lt;1];maxn[cur&lt;&lt;1|1]=ori[cur&lt;&lt;1|1]; flushed[cur]=false; &#125; lazy[cur&lt;&lt;1].merge(lazy[cur]);lazy[cur&lt;&lt;1|1].merge(lazy[cur]); maxn[cur&lt;&lt;1]=lazy[cur].getval(maxn[cur&lt;&lt;1]); maxn[cur&lt;&lt;1|1]=lazy[cur].getval(maxn[cur&lt;&lt;1|1]); lazy[cur].clear(); &#125; inline void build(int cur,int l,int r) &#123; lazy[cur].clear();flushed[cur]=false; if (l!=r) &#123; int mid=(l+r)&gt;&gt;1; build(cur&lt;&lt;1,l,mid);build(cur&lt;&lt;1|1,mid+1,r); pushup(cur);ori[cur]=maxn[cur]; &#125; else &#123; maxn[cur]=ori[cur]=a[l]; &#125; &#125; inline void modify(int op,int cur,int left,int right,int x,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; if (!op) &#123;lazy[cur]=lazy[cur]+x;maxn[cur]+=x;return;&#125; if (op==1) &#123;lazy[cur]=lazy[cur]/x;maxn[cur]/=x;return;&#125; if (op==3) &#123;flushed[cur]=true;maxn[cur]=ori[cur];lazy[cur].clear();return;&#125; &#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) modify(op,cur&lt;&lt;1,left,right,x,l,mid); if (mid+1&lt;=right) modify(op,cur&lt;&lt;1|1,left,right,x,mid+1,r); pushup(cur); &#125; inline int query(int cur,int left,int right,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) return maxn[cur]; pushdown(cur);int mid=(l+r)&gt;&gt;1,res=-1; if (left&lt;=mid) check_max(res,query(cur&lt;&lt;1,left,right,l,mid)); if (mid+1&lt;=right) check_max(res,query(cur&lt;&lt;1|1,left,right,mid+1,r)); pushup(cur);return res; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q); for (register int i=1;i&lt;=n;i++) scanf("%d",a+i); SegmentTree::build(1,1,n); int op,l,r,x; while (q--) &#123; scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;x);++l;++r; if (op!=2) SegmentTree::modify(op,1,l,r,x,1,n); else printf("%d\n",SegmentTree::query(1,l,r,1,n)); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces GYM 101955A]Sockpuppets 题解]]></title>
    <url>%2Fblog%2Fgym101955a%2F</url>
    <content type="text"><![CDATA[DescriptionPheatr has a lot of accounts competing in online programming contests such as contests on TopForces. Sometimes when Pheatr participates in a contest on TopForces but cannot attain a good score directly, he takes advantage of some extra accounts applied for cheating (i. e. sockpuppets) to achieve a higher score: Initially, he builds some wrong codes which can pass the pre-system tests and submits them through the sockpuppets. After that, he uses his main account to challenge these sockpuppets immediately, since a successful challenge provides him 100 more score points. Actually, Pheatr is not the only one who cheats in the contests. Many competitors use the same strategy during online programming contests. It is well known that everyone has only one account as the main account. If one’s cheating is revealed, the main account of the one will be banned forever. To prevent the notorious fact from being exposed, each competitor would not register more than two sockpuppets. In spite of great peril, when they register their sockpuppets, these competitors always follow the same rule that the username of a sockpuppet belonging to one competitor should be a prefix of that of the competitor’s main account, otherwise the username of the main account should be a prefix of that of the sockpuppet. Recently, a leak from TopForces provided a list of verified cheaters who have used sockpuppets for cheating, containing the usernames of their main accounts. Besides, TopForces also published a list of suspicious accounts, implying some of them may be sockpuppets. In order to differentiate these suspicious accounts and point out their owners, Pheatr intends to describe all the possibilities according to the published information. Certainly, one should notice that some of the suspicious accounts may be wronged and do not belong to any known cheaters. After recognizing your outstanding programming skills, Pheatr asks you to count the number of distinct possibilities in total for claiming the affiliations between verified cheaters and suspicious accounts. Two possibilities are considered the same if each suspicious account is wronged simultaneously or belongs to the same competitor in both possibilities. Since the answer can be pretty large, you are only asked to report the answer modulo $(10^9+7)$. InputThe input contains several test cases, and the first line contains a positive integer $T$ indicating the number of test cases which is up to $100$. For each test case, the first line contains two integers $n$ and $m$ indicating the number of known cheaters in the leak and the number of suspicious accounts provided by TopForces respectively, where $1\leq n,m\leq 1000$. Each of the following $n$ lines contains a non-empty string $s$ in all lowercase letters representing the username of the main account for a known cheater, where the length of $s$ is up to $10$. And each of the following $m$ lines contains a non-empty string $t$ in all lowercase letters representing the username of a suspicious account, where the length of $t$ is up to $10$. We guarantee that all usernames appeared in the same test case are distinct. OutputFor each test case, output a line containing “Case #x: y” (without quotes), where $x$ is the test case number starting from $1$, and $y$ is the answer modulo $(10^9+7)$ to this test case. Exampleinput 3 1 2 a aa aaa 1 2 aa a ab 5 5 a ah ahd ahdo ahdoc ahdoca ahdocah ahdocahd ahdocahdo ahdocahdoc output Case #1: 4 Case #2: 2 Case #3: 6396 NoteIn the first sample case, both sockpuppets $aa$ and $aaa$ can belong to the owner of $a$. In the second sample case, the sockpuppet $ab$ cannot belong to the owner of $aa$, while $a$ can. In the third sample case, each sockpuppet can belong to anyone in the list leaked from TopForces. Solution刚开始我的思路没有很好的运用这个前缀后缀匹配的性质，这样即使直接给你一张二分图，告诉你哪些点之间有边，求匹配的方案，也是不好求的。 事实上前缀后缀匹配的优良性质是：与一个串匹配的且比他短的串不会超过10个，因为$\mid s\mid \leq 10$。 我们先对所有的大号和小号合起来建一棵Trie。我们称大号的结尾节点为1类节点，小号的结尾节点为2类节点。这样对于一个串来说，能和它匹配的是结尾节点所在子树内节点和结尾节点的所有祖先。 考虑树型$dp$,$dp[i][j][k]$表示考虑Trie树上以$i$为根的子树，在子树内匹配完后大号们对祖先还有$a$个匹配需求，小号们对祖先还有$b$个匹配需求的方案数。我们的答案显然是$dp[root][0][0]$。考虑一下$j$和$k$的范围。即使祖先们全是小号最多再匹配$10$个大号，即使祖先们全是大号最多再匹配$20$个小号，所以$j\leq 10,k\leq 20$。 对于从子树转移而来的部分，只要简单的做一个树上背包即可。接下来考虑根节点。如果根节点是一个1类节点，就要分它向下匹配几个，向上需求几个来讨论，并不复杂，只有一个要特别注意一下：如果该节点选择向上需求两个，我们的$j$会加2，但事实上这两份需求来自同一个节点，是一样的，所以我们可以提前除以一个2，这样后面匹配的时候就可以为所欲为了。如果是一个2类节点，同样是分类讨论。 时间复杂度$O(T(n\mid s\mid )\mid s\mid ^2)$,不过我在树上背包的时候直接强上没有和size取min竟然也过了？（大雾 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=24848;int n,m,inv2;char s[48];int dp[MAXN+48][11][21],dp2[11][21];/*------ Trie begin ------*/int nxt[MAXN+48][27],type[MAXN+48],tot,root;inline int Create() &#123;++tot;type[tot]=0;memset(nxt[tot],0,sizeof(nxt[tot]));return tot;&#125;inline void init() &#123;tot=0;root=Create();&#125;inline void insert(char s[],int t)&#123; int cur=root,len=strlen(s+1); for (register int i=1;i&lt;=len;i++) &#123; int w=s[i]-'a'+1; if (!nxt[cur][w]) nxt[cur][w]=Create(); cur=nxt[cur][w]; &#125; type[cur]=t;&#125;/*------ Trie end ------*/inline void dfs(int cur)&#123; for (register int i=1;i&lt;=26;i++) if (nxt[cur][i]) dfs(nxt[cur][i]); memset(dp[cur],0,sizeof(dp[cur]));dp[cur][0][0]=1; for (register int i=1;i&lt;=26;i++) if (nxt[cur][i]) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) if (dp[cur][anum][bnum]) for (register int toanum=0;anum+toanum&lt;=10;toanum++) for (register int tobnum=0;bnum+tobnum&lt;=20;tobnum++) Add(dp2[anum+toanum][bnum+tobnum],1ll*dp[cur][anum][bnum]*dp[nxt[cur][i]][toanum][tobnum]%MOD); for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125; if (type[cur]==1) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) if (dp[cur][anum][bnum]) &#123; //up: 0;down: 0; Add(dp2[anum][bnum],dp[cur][anum][bnum]); //up: 1;down: 0; if (anum+1&lt;=10) Add(dp2[anum+1][bnum],dp[cur][anum][bnum]); //up: 2;down 0; if (anum+2&lt;=10) Add(dp2[anum+2][bnum],1ll*dp[cur][anum][bnum]*inv2%MOD); //up: 0;down 1; if (bnum-1&gt;=0) Add(dp2[anum][bnum-1],1ll*dp[cur][anum][bnum]*bnum%MOD); //up: 1;down 1; if (anum+1&lt;=10 &amp;&amp; bnum-1&gt;=0) Add(dp2[anum+1][bnum-1],1ll*dp[cur][anum][bnum]*bnum%MOD); //up: 0;down 2; if (bnum-2&gt;=0) Add(dp2[anum][bnum-2],1ll*dp[cur][anum][bnum]*(bnum*(bnum-1)/2)%MOD); &#125; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125; if (type[cur]==2) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=10;bnum++) if (dp[cur][anum][bnum]) &#123; //up: 0;down 0; Add(dp2[anum][bnum],dp[cur][anum][bnum]); //up: 1;down 0; if (bnum+1&lt;=20) Add(dp2[anum][bnum+1],dp[cur][anum][bnum]); //up: 0;down 1; if (anum-1&gt;=0) Add(dp2[anum-1][bnum],1ll*dp[cur][anum][bnum]*anum%MOD); &#125; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;scanf("%d",&amp;ca);inv2=(MOD+1)&gt;&gt;1; for (register int casenum=1;casenum&lt;=ca;casenum++) &#123; scanf("%d%d",&amp;n,&amp;m);init(); for (register int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); insert(s,1); &#125; for (register int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); insert(s,2); &#125; dfs(root); printf("Case #%d: %d\n",casenum,dp[root][0][0]); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>字符串</category>
        <category>树型dp</category>
        <category>背包</category>
        <category>Trie树</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>GYM</tag>
        <tag>树型dp</tag>
        <tag>Trie树</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder4417][JAGSC2018]Short LIS 题解]]></title>
    <url>%2Fblog%2Fatcoder4417%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given three integers N, A, and B. Let $P=(P_0,P_1,…,P_{N−1})$ be a permutation of $(0,1,…,N−1)$. $P$ is said good if and only if it satisfies all of the following conditions: The length of a longest increasing subsequence of $P$ is at most $2$. $P_A$=$B$ Count the number of good permutations modulo 1e9+7. Constraints $1\leq N \leq 10^6$ $0\leq A\leq N-1$ $0\leq B\leq N-1$ InputInput is given from Standard Input in the following format: N A B OutputPrint the number of good permutations modulo 1e9+7. Sample Input 13 0 0 Sample Output 11 The only good permutation is $(0,2,1)$. Sample Input 212 2 3 Sample Output 25390 Sample Input 310000 9875 5431 Sample Output 3135608808 Solution非常神的一道题 我们考虑一个permutation, 把所有是前缀最小值的点拎出来，我们会发现剩下的数列也一定是一个下降序列，因为任意两个前缀最小值之间如果有一对升序的点，和前面的前缀最小值合起来就形成了一个长度为3的上升序列从而不合法。 设这些前缀最小值为$(a_1,p_{a_1}),(a_2,p_{a_2})\dots(a_k,p_{a_k})$,我们将这些点在平面上画出来，然后两两之间先向下走再向右走，我们我们可以得到一条从$(0,n)$到$(n,0)$的路径，这条路径始终在正方形左上-右下对角线的下方。我们发现，这种路径和原序列是一一对应的。因而我们只要对这样的路径进行计数即可。 如果我们将坐标轴旋转$45^。$,可以把问题变成这样：从$(0,0)$出发，每次位移的向量是$(1,1)$或$(1,-1)$且任意时刻必须在$x$轴上方，最终到达$(n,0)$，求路径条数。 这是非常著名的Dyck Path,在不加限制的情况下路径的条数是卡特兰数的第$n$项。 现在考虑$P_A=B$的限制。我们比较希望$P_A$是一个前缀最小值，这样我们就能在路径上明确的找到他。注意到如果$A+B&gt;n-1$的话$P_A$肯定不是前缀最小值，此时我们可以做变换$a=n-1-a,b=n-1-b$，相当于将整个序列reverse之后再将每个数取补。 如果$A+B\leq n-1$的话我们可以证明合法的序列$P_A$一定是前缀最小值。考虑反证法，假设存在一个$C&lt;A$使得$P_C&lt;P_A$,那么可以得到$P_A$后面的数必须都比$P_A$小。因此序列中比$P_A$小的数至少有$(n-1)-A+1=n-A$个，因为$P_A=B$,所以有$n-A\leq B$，即$A+B\geq n$，与之前的$A+B\leq n-1$矛盾。 于是我们只要求过点$(A,P_A)$的Dyck Path有多少条。考虑到$P_A$是前缀最小值，所以一定有这样一个局部$(A,P_A+1)\Rightarrow(A,P_A)\Rightarrow(A+1,P_A)$，所以我们只要分别统计从$(0,n)$到$(A,P_A+1)$和从$(A+1,P_A)$到$(n,0)$的Dyck Path即可。 这种变种的Dyck Path有一种经典优美的求法： 根据终点的横纵坐标差，我们可以得到有多少次向上，多少次向下。不妨设$n$次向上,$m$次向下$(n\geq m)$。先不考虑必须在$x$轴上方的条件，这就是在$n+m$次中选择$n$次向上，$C_{n+m}^n$。再考虑扣除那些到过$x$轴以下的路径。这些路径必然和$y=-1$相交。考虑该路径和$y=-1$的第一个交点以左的部分，我们将这个部分关于$y=-1$对称，可以得到一条从$(0,-2)$出发的路径。接而我们发现刚才那些不合法的路径和这些从$(0,-2)$到目标点的路径一一对应。从$(0,-2)$到目标点，纵坐标多了2，相当于向上$n+1$次，向下$m-1$次，所以这部分有$C_{n+m}^{n+1}$条。综上，合法的Dyck Path共有$C_{n+m}^n-C_{n+m}^{n+1}$ 完结撒花 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3e6;int fac[MAXN+48],ifac[MAXN+48];inline void init_inv()&#123; fac[0]=1;for (register int i=1;i&lt;=MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;y) return 0; return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;&#125;int n,a,b;inline int calc(int x,int y)&#123; if (x&lt;y) return 0; return C(x,(x+y)&gt;&gt;1);&#125;inline int solve(int x,int y)&#123; int xx=n-(y-x),yy=n-(x+y); return sub(calc(xx,yy)-calc(xx,yy+2));&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif init_inv(); scanf("%d%d%d",&amp;n,&amp;a,&amp;b); if (a+b&gt;n-1) a=n-1-a,b=n-1-b; printf("%d\n",1ll*solve(a,b+1)*solve(b,a+1)%MOD); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2555]SubString 题解]]></title>
    <url>%2Fblog%2Fbzoj2555%2F</url>
    <content type="text"><![CDATA[Description懒得写背景了，给你一个字符串init，要求你支持两个操作 (1):在当前字符串的后面插入一个字符串 (2):询问字符串s在当前字符串中出现了几次？(作为连续子串) 你必须在线支持这些操作。 Input第一行一个数Q表示操作个数 第二行一个字符串表示初始字符串init 接下来Q行，每行2个字符串Type,Str Type是ADD的话表示在后面插入字符串。 Type是QUERY的话表示询问某字符串在当前字符串中出现了几次。 为了体现在线操作，你需要维护一个变量mask，初始值为0 读入串Str之后，使用这个过程将之解码成真正询问的串TrueStr。 询问的时候，对TrueStr询问后输出一行答案Result 然后mask=maskxorResult 插入的时候，将TrueStr插到当前字符串后面即可。 HINT:ADD和QUERY操作的字符串都需要解压 新加数据一组–2015.05.20 Sample Input2 A QUERY B ADD BBABBBBAAB Sample Output0 Constraints长度 &lt;= 600000，询问次数&lt;= 10000,询问总长度&lt;= 3000000 Solution要求在线的向后面添加字符，这个SAM很支持。要查询某个字符串在母串中出现了多少次，只要在SAM上跑一边，然后统计一下子树的right集合的大小即可。但考虑到SAM的结构在不断变化，为了快速统计所有节点的size，我们应该用LCT来维护SAM的parent树。 PS：题目中的Mask很鬼畜，正确的做法见代码，大概是decode的时候传值进去，异或result的时候才真正改变mask的值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1200000;int q;char s[4000048];namespace LCT&#123; struct node &#123; int ch[2],vsum,sum,val,father; &#125;tree[MAXN+48]; inline void Create(int cur,int val) &#123;tree[cur].val=tree[cur].sum=val;tree[cur].vsum=tree[cur].ch[0]=tree[cur].ch[1]=tree[cur].father=0;&#125; inline void pushup(int cur) &#123;tree[cur].sum=tree[cur].vsum+tree[tree[cur].ch[0]].sum+tree[tree[cur].ch[1]].sum+tree[cur].val;&#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].vsum+=tree[tree[cur].ch[1]].sum; tree[cur].vsum-=tree[pre].sum; tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void link(int x,int y) &#123; access(x);splay(x);access(y);splay(y); tree[x].father=y;tree[y].vsum+=tree[x].sum;pushup(y); &#125; inline void cut(int x) &#123; access(x);splay(x); tree[tree[x].ch[0]].father=0;tree[x].ch[0]=0;pushup(x); &#125; inline int query(int x) &#123; access(x);splay(x); return tree[x].vsum+tree[tree[x].ch[1]].sum+tree[x].val; &#125;&#125;namespace SAM&#123; int nxt[MAXN*2][27],par[MAXN*2],maxn[MAXN*2],root,last,tot; inline void init() &#123;tot=1;root=last=1;LCT::Create(root,0);&#125; inline void extend(char ch) &#123; int p=last,np=++tot,w=ch-'A'+1;maxn[np]=maxn[p]+1;LCT::Create(np,1); while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;LCT::link(np,root);last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;LCT::link(np,q);last=np;return;&#125; int nq=++tot;LCT::Create(nq,0); maxn[nq]=maxn[p]+1;memcpy(nxt[nq]+1,nxt[q]+1,26*sizeof(int)); par[nq]=par[q];LCT::link(nq,par[nq]); LCT::cut(q);par[q]=nq;LCT::link(q,nq); par[np]=nq;LCT::link(np,nq); while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline int go(int cur,char ch) &#123;return nxt[cur][ch-'A'+1]?nxt[cur][ch-'A'+1]:-1;&#125;&#125;int mask;inline void decodeWithMask(int mask)&#123; int len=strlen(s); for (register int j=0;j&lt;len;j++) &#123; mask=(mask*131+j)%len; char t=s[j]; s[j]=s[mask]; s[mask]=t; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(q);io.getstring(s);int len=strlen(s);char op[10]; SAM::init();for (register int i=0;i&lt;len;i++) SAM::extend(s[i]); while (q--) &#123; io.getstring(op+1);io.getstring(s); decodeWithMask(mask);len=strlen(s); if (op[1]=='A') &#123; for (register int i=0;i&lt;len;i++) SAM::extend(s[i]); &#125; else &#123; int ans=0,cur=SAM::root; for (register int i=0;i&lt;len;i++) &#123; cur=SAM::go(cur,s[i]); if (cur==-1) break; &#125; if (cur!=-1) ans=LCT::query(cur); printf("%d\n",ans); mask^=ans; &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #28][CTSC2010]珠宝商 题解]]></title>
    <url>%2Fblog%2Fnflsoj28%2F</url>
    <content type="text"><![CDATA[Description给出无根树 $T$，每个节点有一个字符。另给出字符串 $S$。求 $\sum_{u,v}occur(u,v)$。其中 $occur(u,v)$ 为 $T$ 中节点 $u$ 到节点 $v$ 的有向最短路径上的节点连成的字符串在 $S$ 中的出现次数。 Input Format第一行包含两个整数 $N$,$M$，表示 $T$ 的节点个数及 $S$ 的长度。 接下来的 $N−1$ 行，每行两个整数 $x$,$y$，表示节点 $x$ 与节点 $y$ 有无向边相连。 节点由 $1$ ~ $N$ 进行编号。 接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在节点 $i$ 的字符。 最后一行，包含一个长度为 $M$，仅包含小写字母的字符串，表示 $S$。 Output Format一行一个整数为答案。 Sample Input3 5 1 2 1 3 aab abaab Sample Output15 Constraints $100\%$的数据满足，$N,M\leq 50000$ Solution容易想到一个暴力的做法其实也不是很暴力：对字符串$S$建出SAM，枚举树中的每一个点作为根对整棵树进行搜索，搜索移动的同时在SAM上移动，这样树上路径在$S$中出现的次数就是SAM中对应点的right集合大小。在SAM上移动是$O(1)$的，所以该算法时间复杂度为$O(n^2)$ 考虑另外一个不显然的暴力：我们考虑枚举路径的$LCA$，设$LCA$为$z$，那么一条以$z$为转折点的路径$(x,y)$就可以拆成$(x,z)$和$(z,y)$。我们从$z$出发搜索，在一个正串的后缀树上和一个反串的后缀树上移动并打标记，做完之后将两棵后缀树上的标记都下放到叶子，这样从$z$出发的正串和反串都会在$z$上打到标记，最后只要枚举$S$的每一位，将正标记和反标记乘一下即可。至于为什么用后缀树不用SAM，因为如果在SAM上打标记标记会落在子串的两头，在后缀树上打标记才能都落在$z$上。（这个部分讲的很混乱，看代码吧）这个暴力的复杂度是$O(n^2+nm)$ 稍稍优化一下第二个暴力，考虑点分治，每次考虑以重心为$LCA$的情况，这样搜索的总复杂度是$O(nlogn)$,因为每个点都会作为一次重心且每次都要遍历一遍$S$，所以复杂度是$O(nlogn+nm)$ 考虑这个暴力的瓶颈，我们发现有一些很小的子树，我们最后仍然要遍历整个$S$，使得效率下降。 考虑将两个暴力结合，在点分治的过程中，如果剩下的树大小小于$\sqrt m$则使用第一个暴力直接结束。这样的话大小不超过$\sqrt m$的子树个数是$O(\sqrt m)$个，所以这部分是$O(n\sqrt m)$,大于$\sqrt n$的子树也不超过$O(\sqrt m)$个，所以这部分复杂度是$O(m \sqrt m)$,从而时间复杂度为$O((n+m)\sqrt m)$这段复杂度证明非常假 最后要注意一点，点分治的时候要在子树内去重，去重的时候要根据子树的大小选择合适的去重方法，不能只用第二种方法，否则会被菊花图卡掉。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=5e4;int n,m,MAGIC;LL ans;vector&lt;int&gt; v[MAXN+48];char a[MAXN+48],s[2][MAXN+48];bool visited[MAXN+48];int sz[MAXN+48];struct SAM&#123; int maxn[MAXN*2],par[MAXN*2],nxt[MAXN*2][27],to[MAXN*2][27],root,last,tot; int mark[MAXN*2],sz[MAXN*2],ind[MAXN*2],pos[MAXN*2];Pair ord[MAXN*2]; inline int Create() &#123; ++tot; maxn[tot]=par[tot]=mark[tot]=sz[tot]=ind[tot]=0; memset(nxt[tot],0,sizeof(nxt[tot])); return tot; &#125; inline void init() &#123;tot=0;root=last=Create();&#125; inline void extend(char ch,int id) &#123; int p=last,np=Create();maxn[np]=maxn[p]+1;sz[np]=1;ind[np]=id;pos[id]=np; int w=ch-'a'+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=Create();maxn[nq]=maxn[p]+1;memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[np]=nq;par[q]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline int go(int cur,int w) &#123;return nxt[cur][w]?nxt[cur][w]:-1;&#125; inline void build(char s[]) &#123; for (register int i=1;i&lt;=tot;i++) ord[i]=mp(maxn[i],i); sort(ord+1,ord+tot+1); for (register int i=tot;i&gt;=1;i--) &#123; int x=ord[i].y; ind[par[x]]=ind[x];sz[par[x]]+=sz[x]; to[par[x]][s[ind[par[x]]-maxn[par[x]]]-'a'+1]=x; &#125; &#125; inline void pushdown() &#123; for (register int i=1;i&lt;=tot;i++) &#123; int x=ord[i].y; if (par[x]) mark[x]+=mark[par[x]]; &#125; &#125; inline void clear_mark() &#123;for (register int i=1;i&lt;=tot;i++) mark[i]=0;&#125;&#125;sam[2];inline void getsz(int cur,int father)&#123; sz[cur]=1; for (auto y : v[cur]) if (!visited[y] &amp;&amp; y!=father) getsz(y,cur),sz[cur]+=sz[y];&#125;inline void dfs(int cur,int scur,int father,int op)&#123; scur=sam[op].go(scur,a[cur]-'a'+1);if (scur==-1) return; if (!op || father!=-1) ans+=sam[op].sz[scur]; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) dfs(y,scur,cur,op);&#125;inline void swork(int cur,int father)&#123; dfs(cur,sam[0].root,-1,0); for (auto y : v[cur]) if (!visited[y] &amp;&amp; y!=father) swork(y,cur);&#125;inline int getrt(int cur,int father,int Sz)&#123; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y] &amp;&amp; sz[y]&gt;=Sz/2) return getrt(y,cur,Sz); return cur;&#125;inline Pair trans(Pair tmp,int op,int x)&#123; int cur=tmp.x,cnt=tmp.y; if (cnt&lt;sam[op].maxn[cur]) &#123; if (s[op][sam[op].ind[cur]-cnt]!=a[x]) return mp(-1,-1); &#125; else &#123; if (!sam[op].to[cur][a[x]-'a'+1]) return mp(-1,-1); cur=sam[op].to[cur][a[x]-'a'+1]; &#125; return mp(cur,cnt+1);&#125;inline void dfs_sam(int cur,int father,Pair scur,int op)&#123; scur=trans(scur,op,cur); if (scur.x==-1) return; sam[op].mark[scur.x]++; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) dfs_sam(y,cur,scur,op);&#125;vector&lt;int&gt; tree_list,List;int fa[MAXN+48],depth[MAXN+48];inline void dfs_small(int cur,int father)&#123; tree_list.pb(cur);fa[cur]=father; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) depth[y]=depth[cur]+1,dfs_small(y,cur);&#125;inline int getlca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); while (depth[u]&gt;depth[v]) u=fa[u]; if (u==v) return u; while (u!=v) u=fa[u],v=fa[v]; return u;&#125;inline void solve(int cur)&#123; getsz(cur,-1); if (sz[cur]&lt;=MAGIC) &#123;swork(cur,-1);return;&#125; int rt=getrt(cur,-1,sz[cur]);getsz(rt,-1);visited[rt]=true; for (auto y : v[rt]) if (!visited[y]) &#123; if (sz[y]&gt;=MAGIC) &#123; dfs_sam(y,rt,mp(1,0),0);dfs_sam(y,rt,trans(mp(1,0),1,rt),1); sam[0].pushdown();sam[1].pushdown(); for (register int i=2;i&lt;=m;i++) ans-=1ll*sam[0].mark[sam[0].pos[i-1]]*sam[1].mark[sam[1].pos[m+1-i]]; sam[0].clear_mark();sam[1].clear_mark(); &#125; else &#123; tree_list.clear();depth[y]=1;dfs_small(y,-1); for (register int i=0;i&lt;int(tree_list.size());i++) for (register int j=0;j&lt;int(tree_list.size());j++) &#123; int pt1=tree_list[i],pt2=tree_list[j]; int LCA=getlca(pt1,pt2);int scur=sam[0].root; while (pt1!=LCA) &#123; scur=sam[0].go(scur,a[pt1]-'a'+1); if (scur==-1) break; pt1=fa[pt1]; &#125; if (scur==-1) continue; List.clear(); do &#123; List.pb(pt1); if (pt1==y) break; pt1=fa[pt1]; &#125; while (true); for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; reverse(List.begin(),List.end()); scur=sam[0].go(scur,a[rt]-'a'+1); if (scur==-1) continue; for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; List.clear();while (pt2!=LCA) List.pb(pt2),pt2=fa[pt2]; reverse(List.begin(),List.end()); for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; ans-=sam[0].sz[scur]; &#125; &#125; &#125; for (auto y : v[rt]) if (!visited[y]) dfs_sam(y,rt,mp(1,0),0),dfs_sam(y,rt,trans(mp(1,0),1,rt),1); sam[0].pushdown();sam[1].pushdown(); for (register int i=2;i&lt;=m;i++) ans+=1ll*sam[0].mark[sam[0].pos[i-1]]*sam[1].mark[sam[1].pos[m-i+1]]; sam[0].clear_mark();sam[1].clear_mark(); dfs(rt,sam[0].root,-1,0);dfs(rt,sam[1].root,-1,1); vector&lt;int&gt; sonlist;sonlist.clear(); for (auto y : v[rt]) if (!visited[y]) sonlist.pb(y); for (auto y : sonlist) solve(y);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m);int x,y; for (register int i=1;i&lt;=n-1;i++) scanf("%d%d",&amp;x,&amp;y),v[x].pb(y),v[y].pb(x); scanf("%s%s",a+1,s[0]+1); for (register int i=1;i&lt;=m;i++) s[1][i]=s[0][m-i+1]; for (register int op=0;op&lt;=1;op++) &#123; sam[op].init(); for (register int i=1;i&lt;=m;i++) sam[op].extend(s[op][i],i); sam[op].build(s[op]); &#125; for (MAGIC=0;1ll*MAGIC*MAGIC&lt;=m;MAGIC++); ans=0;solve(1); printf("%lld\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>后缀树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>根号暴力</tag>
        <tag>NFLSoj</tag>
        <tag>SAM</tag>
        <tag>字符串</tag>
        <tag>CTSC</tag>
        <tag>后缀树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Regular Contest #096E]Everything on It 题解]]></title>
    <url>%2Fblog%2Farc096e%2F</url>
    <content type="text"><![CDATA[Problem StatementIn “Takahashi-ya”, a ramen restaurant, basically they have one menu: “ramen”, but N kinds of toppings are also offered. When a customer orders a bowl of ramen, for each kind of topping, he/she can choose whether to put it on top of his/her ramen or not. There is no limit on the number of toppings, and it is allowed to have all kinds of toppings or no topping at all. That is, considering the combination of the toppings, $2^N$ types of ramen can be ordered. Akaki entered Takahashi-ya. She is thinking of ordering some bowls of ramen that satisfy both of the following two conditions: Do not order multiple bowls of ramen with the exactly same set of toppings.Each of the N kinds of toppings is on two or more bowls of ramen ordered.You are given N and a prime number M. Find the number of the sets of bowls of ramen that satisfy these conditions, disregarding order, modulo M. Since she is in extreme hunger, ordering any number of bowls of ramen is fine. Constraints 2≤N≤3000 1e8≤M≤1e9+9 N is an integer. M is a prime number. Subscores600 points will be awarded for passing the test set satisfying N≤50. InputInput is given from Standard Input in the following format: N M OutputPrint the number of the sets of bowls of ramen that satisfy the conditions, disregarding order, modulo M. Sample Input 12 1000000007 Sample Output 12 Let the two kinds of toppings be A and B. Four types of ramen can be ordered: “no toppings”, “with A”, “with B” and “with A, B”. There are two sets of ramen that satisfy the conditions: The following three ramen: “with A”, “with B”, “with A, B”. Four ramen, one for each type. Sample Input 23 1000000009 Sample Output 2118 Let the three kinds of toppings be A, B and C. In addition to the four types of ramen above, four more types of ramen can be ordered, where C is added to the above four. There are 118 sets of ramen that satisfy the conditions, and here are some of them: The following three ramen: “with A, B”, “with A, C”, “with B, C”. The following five ramen: “no toppings”, “with A”, “with A, B”, “with B, C”, “with A, B, C”. Eight ramen, one for each type. Note that the set of the following three does not satisfy the condition: “‘with A’, ‘with B’, ‘with A, B’”, because C is not on any of them. Sample Input 350 111111113 Sample Output 31456748 Remember to print the number of the sets modulo M. Note that these three sample inputs above are included in the test set for the partial score. Sample Input 43000 123456791 Sample Output 416369789 This sample input is not included in the test set for the partial score. Solution注意到拉面的碗数是不固定的，所以从拉面的碗数的角度考虑不好做。 考虑根据每种配料容斥。由题意得，一种配料是坏的，当且仅当它只出现了0或1次，我们枚举有几种配料是坏的，则$$ans=\sum_{i=0}^n(-1)^iC_n^if(i)$$其中$f(i)$表示有$i$种配料是坏的，其他的随意的方案数。 考虑如何计算$f(i)$。枚举这$i$种配料一共加到了$j$碗面中，则$$f(i)=2^{2^{n-i}}\sum_{j=0}^{i}g[i][j]*(2^{j})^{n-i}$$其中$g[i][j]$表示将$i$中坏的配料加入$j$碗面的方案数,考虑剩下的$n-i$中配料如何加入面中，对于每种配料来说，每一碗面都可以放或者不放，是$2^j$种方案，$(n-i)$种配料就是$(2^j)^{n-i}$,再考虑这$j$碗面以外的面，这些面中除了$j$中坏的配料其他的配料都可以放或不放，所以一共有$2^{n-i}$种可行的面，每一种面都可以选择加入或者不加入我的集合当中，所以共有$2^{2^{n-i}}$种情况。 最后考虑$g[i][j]$怎么求，我们发现是将$i$种配料放入$j$碗面中且要求没有面非空，这个定义非常像第二类斯特林数，但这里每种配料还可以选择不在任意一碗中出现，所以稍稍魔改一下第二类斯特林数的递推式，得到$$g[i][j]=g[i-1][j-1]+g[i-1][j]*(j+1)$$注意和第二类斯特林数不一样的是最后乘的是$(j+1)$而不是$j$，因为如果$j$碗面中都有配料了，最后一种配料可以选择不加，多一种情况。 总时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3000;int n,M;int s[MAXN+48][MAXN+48];inline void init_stirling()&#123; s[0][0]=1; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=i;j++) s[i][j]=add(s[i-1][j-1]+1ll*j*s[i-1][j]%M,M);&#125;int c[MAXN+48][MAXN+48];inline void init_c()&#123; c[0][0]=1; for (register int i=1;i&lt;=n;i++) &#123; c[i][0]=c[i][i]=1; for (register int j=1;j&lt;=i-1;j++) c[i][j]=add(c[i-1][j-1]+c[i-1][j],M); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(M); init_stirling();init_c();int ans=0; for (register int i=0;i&lt;=n;i++) &#123; int pw1=quick_pow(2,quick_pow(2,n-i,M-1),M); int pw2=quick_pow(2,n-i,M),pw=1; for (register int j=0;j&lt;=i;j++) &#123; int res=1ll*add(1ll*(j+1)*s[i][j+1]%M+s[i][j],M)*pw%M*pw1%M*c[n][i]%M; if (i&amp;1) Sub(ans,res,M); else Add(ans,res,M); pw=1ll*pw*pw2%M; &#125; &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>斯特林数</category>
        <category>第二类斯特林数</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>第二类斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2541][PKUWC2018]猎人杀 题解]]></title>
    <url>%2Fblog%2Floj2541%2F</url>
    <content type="text"><![CDATA[Description猎人杀是一款风靡一时的游戏“狼人杀”的民间版本，他的规则是这样的： 一开始有 $n$ 个猎人，第 $i$ 个猎人有仇恨度 $w_i$，每个猎人只有一个固定的技能：死亡后必须开一枪，且被射中的人也会死亡。 然而向谁开枪也是有讲究的，假设当前还活着的猎人有 $[i_1\ldots i_m]$[i ，那么有 $\frac{w_{i_k}}{\sum\limits_{j = 1}^{m} w_{i_j}}$的概率是向猎人 $i_k$ 开枪。 一开始第一枪由你打响，目标的选择方法和猎人一样（即有 $\frac{w_i}{\sum\limits_{j=1}^{n}w_j}$ 的概率射中第 $i$ 个猎人）。由于开枪导致的连锁反应，所有猎人最终都会死亡，现在 $1$ 号猎人想知道它是最后一个死的的概率。 答案对 $998244353$ 取模。 Constraints$w_i&gt;0,1\leq \sum_{i=1}^nw_i\leq 100000$ Solution考虑容斥，每次钦定一个集合$S$,令$p(S)$表示要求$S$内的猎人必须在$1$之后死亡，容斥系数显然是$(-1)^{\mid S\mid}$，则$$ans=\sum_S(-1)^{\mid S\mid}p(S)$$ 考虑怎么算$p(S)$,首先有一个很烦的点是每次击杀一个猎人之后，概率的分母会变，从而很不好算。 令$W=\sum_{i=1}^nw_i$,$B=\sum_{i\in dead}w_i$,则第$i$个人下一轮被射杀的概率是$p_i=\frac{w_i}{W-B}$。考虑一个新的规则，每次猎人可以打活人也可以打死人，如打到了死人就可以免费再打一次，直到打到活人为止。设这种情况下$p_i’$表示第$i$个人下一轮被射杀的概率，则$p_i’=\frac{B}{W}p_i’+\frac{w_i}{W}$,其中第一项表示如果打到死人概率还是$p_i’$。解这个方程得$p_i’=\frac{w_i}{W-B}$,所以这两个规则是等价的。 这样我们每次的分母都是一样的，令$sum(S)=\sum_{i\in S}w_i$,写出$p(S)$的表达式：$$p(S)=\sum_{i=0}^{\infty}(1-\frac{w_1+sum(S)}{W})^{i}\cdot \frac{w_1}{W}$$ 把$\frac{w_1}{W}$提出来，剩余部分是一个无穷级数。考虑到$1-\frac{w_1+sum(S)}{W}\in(0,1)$，所以它是收敛的，根据$\sum_{i=0}^{\infty}x^i=\frac{1}{1-x}$，得到$$p(S)=\frac{w_1}{W}\frac{1}{1-(1-\frac{w_1+sum(S)}{W})}=\frac{w_1}{w_1+sum(S)}$$ $$ans=w_1\sum_S\frac{(-1)^{\mid S\mid}}{w_1+sum(S)}$$ 我们已经极大地化简了此式，注意到范围中$\sum w_i$较小，考虑背包。$dp[i][j][0/1]$表示当前考虑到第$i$个数字，选择的$sum(S)=j$,当前选择的数字个数是奇数还是偶数的情况下的方案数。 这样做复杂度是$O(nW)$的，不足以通过。但是01背包有喜闻乐见的基于生成函数的优化方法。 对于第$i$个物品，考虑令$f_i(x)=1-x^{w_i}$，注意这个负号很好地模拟了容斥，奇数个-1相乘是-1，偶数个则是1。所以$\Pi_{i=1}^nf_i(x)$这个多项式中,$x^i$的系数就是所有满足$sum(S)=i$的$S$的容斥系数的和。 上述的$\Pi$可以用分治NTT优化，从而复杂度降到$O(nlognlogW)$，可以通过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;const int NTT_MAX=8e5;int n,w[MAXN+48],sum[MAXN+48];namespace polynomial&#123; const int G=3; int wpos[NTT_MAX+48],wneg[NTT_MAX+48];bool done=false; inline void poly_init() &#123; done=true; for (register int clen=2;clen&lt;=262144*2;clen&lt;&lt;=1) wpos[clen]=quick_pow(G,(MOD-1)/clen),wneg[clen]=quick_pow(G,(MOD-1)-(MOD-1)/clen); &#125; int w[NTT_MAX+48]; inline void poly_ntt(int c[],int len,int fl) &#123; int i,j,k; for (i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; int wn=(fl==1?wpos[clen]:wneg[clen]); w[0]=1;for (register int i=1;i&lt;=(clen&gt;&gt;1);i++) w[i]=1ll*w[i-1]*wn%MOD; for (j=0;j&lt;len;j+=clen) for (k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; int tmp1=c[k],tmp2=1ll*c[k+(clen&gt;&gt;1)]*w[k-j]%MOD; c[k]=add(tmp1+tmp2);c[k+(clen&gt;&gt;1)]=sub(tmp1-tmp2); &#125; &#125; if (fl==-1) &#123; int ilen=quick_pow(len,MOD-2); for (i=0;i&lt;len;i++) c[i]=1ll*c[i]*ilen%MOD; &#125; &#125; inline void poly_mul(int A[],int B[],int n,int m) &#123; if (!done) poly_init(); int len=1;while (len&lt;=n+m) len&lt;&lt;=1; memset(A+n,0,(len-n)*sizeof(int)); memset(B+m,0,(len-m)*sizeof(int)); poly_ntt(A,len,1);poly_ntt(B,len,1); for (register int i=0;i&lt;len;i++) A[i]=1ll*A[i]*B[i]%MOD; poly_ntt(A,len,-1); &#125;&#125;int tmp[NTT_MAX+48],A[NTT_MAX+48],B[NTT_MAX+48];inline void solve(int left,int right)&#123; if (left==right) &#123; memset(tmp,0,(w[left]+1)*sizeof(int)); tmp[0]=1;tmp[w[left]]=MOD-1;return; &#125; int mid=(left+right)&gt;&gt;1,N=sum[mid]-sum[left-1]+1,M=sum[right]-sum[mid]+1; int len=1;while (len&lt;=N+M) len&lt;&lt;=1; int Tmp[len+48]; solve(left,mid);memcpy(Tmp,tmp,N*sizeof(int)); solve(mid+1,right); memcpy(A,Tmp,N*sizeof(int));memcpy(B,tmp,M*sizeof(int)); polynomial::poly_mul(A,B,N,M); memcpy(tmp,A,len*sizeof(int));&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(w[i]); sum[1]=0;for (register int i=2;i&lt;=n;i++) sum[i]=sum[i-1]+w[i]; solve(2,n);int ans=0; for (register int i=0;i&lt;=sum[n];i++) Add(ans,1ll*A[i]*quick_pow(w[1]+i,MOD-2)%MOD); ans=1ll*ans*w[1]%MOD;printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>生成函数</category>
        <category>多项式</category>
        <category>NTT</category>
        <category>分治NTT</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>LOJ</tag>
        <tag>PKUWC</tag>
        <tag>分治NTT</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min-Max容斥]]></title>
    <url>%2Fblog%2Fmin-max%2F</url>
    <content type="text"><![CDATA[规定$Max(S)$表示集合$S$中最大的元素，$Min(S)$表示集合$S$中最小的元素，$\mid S\mid$表示集合$S$的大小。 Min-Max容斥的公式如下：$$Max(S)=\sum_{T\subseteq S}(-1)^{\mid T\mid +1}Min(T)$$ 证明： 首先证明一个引理：对于$\forall n&gt;0$，$\sum_{i=0}^n(-1)^iC_n^i=0$ 证明：$\sum_{i=0}^n(-1)^iC_n^i=C_n^0+C_n^n+\sum_{i=1}^{n-1}(-1)^i(C_{n-1}^{i-1}+C_{n-1}^i)=C_n^0+C_n^n-C_{n-1}^0-C_{n-1}^{n-1}=0$ &nbsp; $\blacktriangle$ 不妨设$S$中的元素是有序的，即对于$\forall i&lt;j$,有$a_i&lt;=a_j$ 考虑每个元素作为最小值的贡献，可以将Min-Max容斥的结果写成$$\sum_{i=1}^na_i\sum_{j=0}^{n-i}(-1)^jC_{n-i}^j$$ 注意$j$和$\mid T\mid$正好相差2(最小值$a_i$被单独拎了出来),所以直接写$(-1)^j$是对的。 根据引理，只有当$n-i=0$，即$i=n$时后面一半不是0,所以原式等于$a_n$ &nbsp; $\blacktriangle$]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>Min-Max容斥</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM664DIV1A]BearPlays 题解]]></title>
    <url>%2Fblog%2Ftcsrm664div1a%2F</url>
    <content type="text"><![CDATA[Problem StatementLimak is a little bear who loves to play. Today he is playing by moving some stones between two piles of stones. Initially, one of the piles has A and the other has B stones in it. Limak has decided to perform a sequence of K operations. In each operation he will double the size of the currently smaller pile. Formally, if the current pile sizes are labeled X and Y in such a way that X &lt;= Y, he will move X stones from the second pile to the first one. After this move the new pile sizes will be X+X and Y-X. You are given the ints A, B, and K. Determine the pile sizes after Limak finishes all his operations. Return the size of the smaller of those piles. Formally, suppose that the final pile sizes are labeled P and Q in such a way that P &lt;= Q. Return P. DefinitionClass: BearPlays Method: pileSize Parameters: int, int, int Returns: int Method signature: int pileSize(int A, int B, int K)(be sure your method is public) Notes Pay attention to the unusual time limit. Constraints A and B will be between 1 and 1,000,000,000, inclusive. K will be between 1 and 2,000,000,000, inclusive. Examples0) 4 7 2 Returns: 5 The process will look as follows: Initially, the pile sizes are 4 and 7. First operation: Limak doubles the pile of size 4 by moving 4 stones from the other pile to this pile. The new pile sizes are 8 and 3. Second operation: Limak doubles the pile of size 3. The final pile sizes are 5 and 6. As 5 &lt;= 6, the correct return value is 5. 1) 5 5 3 Returns: 0 The initial pile sizes are 5 and 5. In the first operation Limak will double one of them, so after the operation the new pile sizes will be 10 and 0. The second and third operation do nothing: in each of them Limak doubles the size of an empty pile. As 0 ≤ 10, the correct return value is 0. 2) 2 6 1 Returns: 4 After the only operation the pile sizes will be 4 and 4, hence the correct return value is 4. 3) 2 8 2000000000 Returns: 2 4) 900000000 350000000 3 Returns: 300000000 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution数学神思维题 首先的性质是$x+y$的和不会变，设$x+y=n$ 考虑如果当前$x\leq y$,则$x=2x$ 如果当前$x\ge y$,则$x=x-y=2x-(x+y)=2x-n\equiv 2x(mod$ &nbsp; $n)$ 综上，进行$k$轮之后,$x\equiv x*2^k(mod$ &nbsp; $n)$ 所以算出这个，返回$min(x,n-x)$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;class BearPlays&#123; int n; inline int quick_pow(int x,int y) &#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%n,y--; x=(1ll*x*x)%n;y&gt;&gt;=1; &#125; return res; &#125; public: inline int pileSize(int x,int y,int k) &#123; n=x+y; x=(1ll*x*quick_pow(2,k))%n; return min(x,n-x); &#125;&#125;;#ifdef LOCALint main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); BearPlays A; int nn,mm,kk; while (cin&gt;&gt;nn&gt;&gt;mm&gt;&gt;kk) cout&lt;&lt;A.pileSize(nn,mm,kk)&lt;&lt;endl; return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #270][六校联合训练 #9]菊凯的疑惑 题解]]></title>
    <url>%2Fblog%2Fnflsoj270%2F</url>
    <content type="text"><![CDATA[Description有一棵 $n$ 个节点的树，你将从任意一个点出发开始随机游走。具体来说，在点 $u$ 的每个单位时间内，你将会有 $p_u$ 的概率留在原地，有 $1−p_u$ 的概率等概率的向相邻的点移动，直到移动到 $1$ 号点才停下。 现在询问从每个点出发直至停下，所花费的时间的 $k$ 次方的期望。 可以证明，答案可以被表示成 $q\times p^{−1}$ 的形式，你需要输出一个正整数 $ans$，使得 $ans\equiv q\times p^{−1}(mod$&nbsp; $998244353)$。保证 $p$ 将不会是 $998244353$ 的倍数。 Input Format第一行两个整数 $n$ 和 $k$，含义如题目所示。 接下来 $n−1$ 行，每行两个整数 $u$,$v$,代表一条树边。 接下来一行，$n−1$ 个整数，第 $i$ 个数为 $p′{i+1}$。$p{i+1}=p′_{i+1}\times 10^{−6}$ ,代表留在原地的概率。 Output Format输出 $n−1$ 行，第 $i$ 个输出表示从 $i+1$ 号点出发直至停下，所花费的时间的 $k$ 次方的期望。 Constraints 对于 15% 的数据，n,k≤10。 对于 30% 的数据，n,k≤50。 对于 50% 的数据，n≤1000，k≤100。 对于另外 5% 的数据，保证 k=0。 对于另外 15% 的数据，保证 k=1。 对于另外 15% 的数据，保证 pi=0。 对于 95% 的数据，k≤1000。 对于 100% 的数据，保证 1≤n≤1e5，0≤k≤1e5，n⋅k≤1e6，0≤p′i&lt;1e60。 Solution这果真是noip模拟题 一个显然的思路是树型dp,我们令$f_{u,i}$表示从$u$出发到根的路径长度的$i$次方的期望。(注意这个和长度期望的$i$次方是两码事) 我们先考虑简单的情况，$i=1$时怎么做。 可以轻易地列出状态转移方程(其中$deg_u$表示节点$u$的度数)$$f_{u,1}=p_u(f_{u,1}+1)+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}(f_{v,1}+1)$$ 注意到这个方程既要从孩子转移来也要从父亲转移来，所以没有明显的阶段性，需要高斯消元。针对树上的高斯消元有树上高消的黑科技可以在线性时间内解出所有的变量，后面再讲。 接下来考虑一般的情况，一个比较显然的想法是利用二项式定理展开，就是暴力展开$(f_{u,i}+1)^k$类似的东西，注意展开后的每一项都要用对应的次方的期望。这样我们可以得到状态转移方程$$f_{u,i}=\sum_{j=0}^i\binom{i}{j}(p_uf_{u,j}+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,j})$$ 这样我们可以$O(k)$的转移，加上$O(nk)$个状态，总时间复杂度是$O(nk^2)$，大概可以拿70分。 然后就不会了 接下来的部分比较神奇 考虑如下等式 $$x^k=\sum_{j=0}^{k}\binom{x}{j}S(k,j)j!$$ 其中$S(k,j)$表示第二类斯特林数。 可以这样简证上述等式的正确性：等式的左边可以看做将$k$个不同的球放入$x$个不同的盒子中,每个球都有$x$种放法所以是$x^k$，右边可以看做先枚举有$j$个盒子是有球的，从$x$个盒子中先选出$j$个盒子保证非空，然后假装这$j$个盒子是不可分辨的，那么将球放入的方案数就是第二类斯特林数，最后再乘上$j$个盒子的排列数。 有了这个式子我们发现，我们令$x^k$表示从某一点出发到根的时间的$k$次方的期望，我们只要求出所有的$\binom{x}{i}$的期望就可以了。 我们修改之前定义的状态，令$f_{u,i}$表示从$u$出发到根，所用时间$t$的$\binom{t}{i}$的期望。我们发现组合数有一个非常好的性质：$\binom{t}{i}=\binom{t-1}{i}+\binom{t-1}{i-1}$，这就比二项式定理的递推要很多，因为我们的递推式只有两项，转移的复杂度从$O(k)$降到了$O(1)$。 写出新的状态转移方程：$$f_{u,i}=p_u(f_{u,i}+f_{u,i-1})+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E} (f_{v,i}+f_{v,i-1})$$ 是时候来化成可以树上高消的形式了我们先拆拆括号移项整理，可得$$(1-p_u)f_{u,i}=\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,i}+p_uf_{u,i-1}+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,i-1}$$$$f_{u,i}=\frac{\sum_{(u,v)\in E}f_{v,i}}{deg_u}+\frac{p_u}{1-p_u}f_{u,i-1}+\frac{\sum_{(u,v)\in E}f_{v,i-1}}{deg_u}$$ 由于我们是按$i$从小到大递推的，所以所有下标为$i-1$的项都是已知项，为了简化表达，我们令$$g_{u,i}=\frac{p_u}{1-p_u}f_{u,i-1}+\frac{\sum_{(u,v)\in E}f_{v,i-1}}{deg_u}$$ 则原式可以写成$$f_{u,i}=\frac{\sum_{(u,v)\in E}f_{v,i}}{deg_u}+g_{u,i}$$ 上式中所有的$v$里面有一个是$u$的父亲(我们暂时不考虑根节点),其他的都是$u$的儿子，我们把父亲单独提出来:$$f_{u,i}=\frac{\sum_{v\in son_u}f_{v,i}}{deg_u}+\frac{f_{fa_u,i}}{deg_u}+g_{u,i}$$ 稍微想一下可以知道，所有的叶节点是没有儿子的，所以它们的$f$值只和父亲相关，倒数第二层的节点，它们的孩子都是叶子节点，可以用它们自己来表示，所以它们也只和父亲相关……依次类推，每个节点的$f$值都是关于父亲的$f$值的一次函数，设$f_{u,i}=k_uf_{fa_u,i}+b_u$，我们要推出$k_u$和$b_u$的表达式。 对于上式，我们把所有的$f_{v,i}$换成$k_vf_{u,i}+b_v$,有$$f_{u,i}=\frac{\sum_{v\in son_u}(k_vf_{u,i}+b_v)}{deg_u}+\frac{f_{fa_u,i}}{deg_u}+g_{u,i}$$ $$(1-\frac{\sum_{v\in son_u}k_v}{deg_u})f_{u,i}=\frac{f_{fa_u,i}}{deg_u}+g_{u,i}+\frac{\sum_{v\in son_u}b_v}{deg_u}$$ $$f_{u,i}=\frac{1}{deg_u-\sum_{v\in son_u}k_v}f_{fa_u,i}+\frac{\sum_{v\in son_u}b_v+deg_ug_{u,i}}{deg_u-\sum_{v\in son_u}k_v}$$ 所以$$ k_u = \frac{1}{deg_u-\sum_{v\in son_u}k_v}$$$$ b_u = \frac{\sum_{v\in son_u}b_v+deg_ug_{u,i}}{deg_u-\sum_{v\in son_u}k_v}$$ 这样只要从下到上算一遍$k_u$和$b_u$，再根据$f_{root,i}=0$从上到下推一遍就解出了所有的未知数。 这样可以得到95分，还有一个问题是暴力推第二类斯特林数是$O(n^2)$的。这里有一个喜闻乐见的多项式做法。 考虑第二类斯特林数的通项公式:$$S(n,k)=\frac{1}{k!}\sum_{i=0}^k(-1)^i\binom{k}{i}(k-i)^n$$ 这个公式是基于容斥的，考虑枚举至少有$i$个盒子是空的，从$k$个盒子中选出$i$个空盒子是$\binom{k}{i}$，$n$个球每个球有$(k-i)$种放置方案，可得到上式。 对式子做一些变换$$S(n,k) = \frac{1}{k!}\sum_{i=0}^k(-1)^i(k-i)^n\frac{k!}{i!(k-i)!}= \sum_{i=0}^k\frac{(k-i)^n}{(k-i)!}\frac{(-1)^i}{i!}$$ 这显然是一个卷积的形式，用$NTT$加速即可做到$O(klogk)$ 总时间复杂度$O(nk+klogk)$ 终于完结撒花了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=4e5;namespace polynomial&#123; const int G=3; const int NTT_MAX=8e5; int wn_pos[NTT_MAX+48],wn_neg[NTT_MAX+48]; inline void poly_init() &#123; for (register int clen=2;clen&lt;=524288;clen&lt;&lt;=1) wn_pos[clen]=quick_pow(G,(MOD-1)/clen),wn_neg[clen]=quick_pow(G,(MOD-1)-(MOD-1)/clen); &#125; inline void poly_ntt(int c[],int len,int fl) &#123; int i,j,k; for (i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; int wn=(fl==1?wn_pos[clen]:wn_neg[clen]); for (j=0;j&lt;len;j+=clen) &#123; int w=1; for (k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; int tmp1=c[k],tmp2=1ll*c[k+(clen&gt;&gt;1)]*w%MOD; c[k]=add(tmp1+tmp2);c[k+(clen&gt;&gt;1)]=sub(tmp1-tmp2); w=1ll*w*wn%MOD; &#125; &#125; &#125; if (fl==-1) &#123; int ilen=quick_pow(len,MOD-2); for (i=0;i&lt;len;i++) c[i]=1ll*c[i]*ilen%MOD; &#125; &#125; inline void poly_mul(int A[],int B[],int n,int m,int C[]) &#123; int len=1;while (len&lt;=n+m) len&lt;&lt;=1; memset(A+n,0,(len-n)*sizeof(int)); memset(B+m,0,(len-m)*sizeof(int)); poly_ntt(A,len,1);poly_ntt(B,len,1); for (register int i=0;i&lt;len;i++) C[i]=1ll*A[i]*B[i]%MOD; poly_ntt(C,len,-1); &#125;&#125;int fac[MAXN+48],ifac[MAXN+48];inline void init_fac()&#123; fac[0]=1;for (register int i=1;i&lt;=MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;int A[MAXN+48],B[MAXN+48],s[MAXN+48];int n,k;vector&lt;int&gt; v[MAXN+48];int d[MAXN+48],p[MAXN+48],dinv[MAXN+48],pinv[MAXN+48];vector&lt;int&gt; f[MAXN+48];int g[MAXN+48];int K[MAXN+48],b[MAXN+48];inline void dfs(int cur,int father)&#123; int ksum=0,bsum=0; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) dfs(y,cur),Add(ksum,K[y]),Add(bsum,b[y]); &#125; K[cur]=quick_pow(sub(d[cur]-ksum),MOD-2); b[cur]=add(1ll*K[cur]*bsum%MOD+1ll*K[cur]*d[cur]%MOD*g[cur]%MOD);&#125;inline void Dfs(int cur,int father,int step)&#123; if (cur==1) f[cur][step]=0; else f[cur][step]=add(b[cur]+1ll*K[cur]*f[father][step]%MOD); for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) Dfs(y,cur,step); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif polynomial::poly_init();init_fac(); io.Get(n);io.Get(k);int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x);d[x]++;d[y]++; &#125; int Inv=quick_pow(int(1e6),MOD-2); for (register int i=2;i&lt;=n;i++) io.Get(p[i]),p[i]=1ll*p[i]*Inv%MOD; for (register int i=1;i&lt;=n;i++) dinv[i]=quick_pow(d[i],MOD-2),pinv[i]=quick_pow(p[i],MOD-2); for (register int i=1;i&lt;=n;i++) f[i].resize(k+10,0),f[i][0]=1; for (register int i=1;i&lt;=k;i++) &#123; for (register int j=2;j&lt;=n;j++) &#123; g[j]=1ll*p[j]*quick_pow(sub(1-p[j]),MOD-2)%MOD*f[j][i-1]%MOD; for (auto y : v[j]) Add(g[j],1ll*f[y][i-1]*dinv[j]%MOD); &#125; dfs(1,-1);Dfs(1,-1,i); &#125; for (register int i=0;i&lt;=k;i++) A[i]=1ll*ifac[i]*((i&amp;1)?(MOD-1):1)%MOD; for (register int i=0;i&lt;=k;i++) B[i]=1ll*ifac[i]*quick_pow(i,k)%MOD; polynomial::poly_mul(A,B,k+1,k+1,s); for (register int i=0;i&lt;=k;i++) s[i]=1ll*s[i]*fac[i]%MOD; for (register int i=2;i&lt;=n;i++) &#123; int ans=0; for (register int j=0;j&lt;=k;j++) Add(ans,1ll*f[i][j]*s[j]%MOD); printf("%d\n",ans); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>树型dp</category>
        <category>多项式</category>
        <category>高斯消元</category>
        <category>NTT</category>
        <category>树上高消</category>
        <category>斯特林数</category>
        <category>第二类斯特林数</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>第二类斯特林数</tag>
        <tag>NFLSoj</tag>
        <tag>树型dp</tag>
        <tag>树上高消</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 011E]Increasing Numbers 题解]]></title>
    <url>%2Fblog%2Fagc011e%2F</url>
    <content type="text"><![CDATA[Problem StatementWe will call a non-negative integer increasing if, for any two adjacent digits in its decimal representation, the digit to the right is greater than or equal to the digit to the left. For example, 1558, 11, 3 and 0 are all increasing; 10 and 20170312 are not. Snuke has an integer N. Find the minimum number of increasing integers that can represent N as their sum. Constraints $1 \leq N \leq 10500000$ InputThe input is given from Standard Input in the following format: N OutputPrint the minimum number of increasing integers that can represent N as their sum. Sample Input 180 Sample Output 12 One possible representation is 80=77+3. Sample Input 2123456789 Sample Output 21 123456789 in itself is increasing, and thus it can be represented as the sum of one increasing integer. Sample Input 320170312 Sample Output 34 Sample Input 47204647845201772120166980358816078279571541735614841625060678056933503 Sample Output 431 Solution很神的一道题 首先我们可以发现一个性质：任何一个好数都可以拆成不超过9个全1数的和，更贴切地说，任何一个好数可以拆成它个位数个全1数的和。 因此我们想到一个方向：我们试图将原数$N$分解成尽可能少的全1数的和，然后每9个全1数我们都能将其合成一个好数，这样就能用最少的好数组成$N$。换句话来说，一个数$N$能表示成$k$个好数的和，当且仅当它能被表示成$9k$个全1数的和。 接下来是非常关键神奇的一步 对于一个全1数$\underbrace{11\dots 1}_{x个}$，我们可以将其表示为$\frac{10^x-1}{9}$ 这样假设$N$可以被表示成$k$个全1数，第$i$个数的长度是$a_i$，我们有如下等式：$$\sum_{i=1}^{9k}\frac{10^{a_i}-1}{9}=N$$ 移项，可得$$\sum_{i=1}^{9k}10^{a_i}=9N+9k$$ 我们发现左边的东西是一些10的次幂相加，而一个数要分解成若干个10的次幂相加的形式，最少需要的就是数字和个10的次幂。因此我们判断一个数$N$能否表示成$k$个全1数的和，只要判断$9N+9k$的数字和是否小于等于$9k$。 记$N$的位数是$L$,这样我们可以在$O(L)$的时间内check一个答案，注意到答案具有单调性，所以可以二分答案，这样复杂度是$O(LlogL)$。 事实上有一个更简单的线性做法：我们不用二分答案，只要从小到大枚举答案即可，每次我们给目标数+9即可，这样每轮均摊的进位次数是$O(1)$的，在进位的时候动态更新一下数字和即可，复杂度$O(L)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e6;int len;char s[MAXN+48];int b[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);len=strlen(s+1); for (register int i=len,j=1;i&gt;=1;i--,j++) b[j]=s[i]-'0'; for (register int i=1;i&lt;=len;i++) b[i]*=9; for (register int i=1;i&lt;=len;i++) b[i+1]+=b[i]/10,b[i]%=10; if (b[len+1]) len++; int sum=0;for (register int i=1;i&lt;=len;i++) sum+=b[i]; for (register int ans=1;;++ans) &#123; sum-=b[1];b[1]+=9;int pt=1; while (b[pt]&gt;9) sum-=b[pt+1],b[pt+1]+=b[pt]/10,b[pt]%=10,pt++; for (register int i=1;i&lt;=pt;i++) sum+=b[i]; if (sum&lt;=9*ans) &#123;printf("%d\n",ans);return 0;&#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #294]c 题解]]></title>
    <url>%2Fblog%2Fnflsoj294%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点,带边权的树。 有$m$次询问,每次给出$x$, $y$,求最小的非负整数$s$,满足树上$x$到$y$路径上的边权都不等于$s$。 Input Format第一行共两个正整数$n$, $m$,分别表示点数和询问数。 接下来$n − 1$行,每行共3个正整数$x$, $y$, $v$,分别表示有一条连接$x$,$y$,边权为$v$的边。 接下来$m$行,每行共2个正整数$x$, $y$,表示询问的两个顶点。 Output Format对于每一个询问输出一行,共一个非负整数表示这次询问的答案。 Sample Input 7 6 2 1 1 3 1 2 1 4 0 4 5 1 5 6 3 5 7 4 1 3 4 1 2 4 2 5 3 5 3 7 Sample Output 0 1 2 2 3 3 Constraints 对于$40\%$ 的数据,$n, m \leq 1000$, $0 \leq v \leq 100$。 另有$20\%$ 的数据,满足输入的树是一条链。 另有$30\%$ 的数据,满足$0 \leq v \leq 1$。 对于$100\%$ 的数据,$n, m \leq 100000$, $0 \leq v \leq 100000$。 Solution这种求$mex$的问题无法高效地用数据结构维护，考虑莫队。 我们先考虑如果树是一条链的情况。这时就是一个普通的序列莫队。一个朴素的想法是用一个BIT来维护每种数是否出现过，如果增加操作中$cnt=1$就加入BIT,如果减少操作中$cnt=0$就从BIT中删掉。查询的时候只要在BIT中二分就可以了，用类似线段树二分的方法这部分可以做到一个log,通过合理选取块的大小，该算法的复杂度可以做到$O(n\sqrt{nlogn}+mlogn)$ 这个做法有一定几率被卡常，考虑如何把根号下的log去掉。我们注意到在莫队的端点移动过程中，总共会有$n\sqrt n$次加入和删除操作，而查询操作只有$m$次，所以我们应该设法用减少插入删除的复杂度，增加查询复杂度的方式来平衡两边的复杂度。 考虑分块，我们对每一个块，记录$bucket[i]$表示第$i$个块中有多少个数存在。插入删除的时候我们只要维护cnt和对应的bucket即可，复杂度为$O(1)$，查询的时候，我们先找到第一个有空缺的bucket,再在bucket中暴力查找第一个空缺的数，时间复杂度$O(\sqrt n)$，这样总复杂度降到$O((m+n)\sqrt n)$,可以比较轻松地通过。 现在考虑树上的情况，我们可以把序列莫队变成树上莫队。有关路径查询的树上莫队有一种非常神的做法。 我们考虑维护这棵树的欧拉dfs序（即进入子树和出子树的时候都加入序列）,这样对于每个节点$i$我们有一个$st[i]$表示它在序列中的第一次出现位置和一个$ed[i]$表示它在序列中的第二次出现位置。我们注意到对于树上的一条链$(u,v)$，不妨设$st[u]&lt;st[v]$，则dfs序中的$[ed[u],st[v]]$这个区间，$(u,v)$上的点会在区间中出现1次，之外的点会出现0次或两次，所以我们在dfs序上莫队的时候只要记录一个每个点的visited数组，如果没有visited就insert,否则就delete即可。 注意几个特殊情况： 当$u$是$v$的祖先的时候，上述的区间是不对的，显然我们应该用$[st[u],st[v]]$这个区间。 当$u$不是$v$的祖先的时候，上述的做法没有包含$lca(u,v)$，所以最后要单独将$lca(u,v)$加入一下。 本题中可以将边权赋给对应的儿子节点，从而在查询一条链的时候$lca$的权值不在路径内，上述的情况2就不用考虑了，情况一要注意将区间改为$[st[u]+1,st[v]]$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];int st[MAXN+48],ed[MAXN+48],seq[MAXN*2+48],val[MAXN+48],ind;int anc[MAXN+48][21],depth[MAXN+48];int cnt[MAXN+48],bucket[MAXN+48],N;inline int calc()&#123; int tar=N; for (register int i=1;i&lt;=N-1;i++) if (bucket[i]&lt;magic) &#123;tar=i;break;&#125; for (register int i=(tar-1)*magic;i&lt;=tar*magic-1;i++) if (!cnt[i]) return i;&#125;inline void dfs(int cur,int father)&#123; st[cur]=++ind;seq[ind]=cur; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i].x; if (y!=father) &#123; depth[y]=depth[cur]+1;val[y]=v[cur][i].y; anc[y][0]=cur; for (register int j=1;j&lt;=17;j++) anc[y][j]=anc[anc[y][j-1]][j-1]; dfs(y,cur); &#125; &#125; ed[cur]=++ind;seq[ind]=cur;&#125;inline int getlca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); for (register int i=17;i&gt;=0;i--) if (depth[anc[u][i]]&gt;=depth[v]) u=anc[u][i]; if (u==v) return u; for (register int i=17;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) u=anc[u][i],v=anc[v][i]; return anc[u][0];&#125;struct node&#123; int u,v,ind; inline void input() &#123;io.Get(u);io.Get(v);&#125; inline bool operator &lt; (const node &amp;other) const &#123; if (u/magic!=other.u/magic) return u/magic&lt;other.u/magic; return v&lt;other.v; &#125;&#125;q[MAXN+48];bool visited[MAXN+48];int fans[MAXN+48];inline void ins(int cur)&#123; cnt[val[cur]]++; if (cnt[val[cur]]==1) bucket[val[cur]/magic+1]++;&#125;inline void del(int cur)&#123; cnt[val[cur]]--; if (!cnt[val[cur]]) bucket[val[cur]/magic+1]--;&#125;inline void doit(int pos)&#123; if (!visited[seq[pos]]) visited[seq[pos]]=true,ins(seq[pos]); else visited[seq[pos]]=false,del(seq[pos]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int x,y,c; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y);io.Get(c); v[x].pb(mp(y,c));v[y].pb(mp(x,c)); &#125; depth[1]=1;dfs(1,-1); for (register int i=1;i&lt;=m;i++) &#123; q[i].input();q[i].ind=i; if (st[q[i].u]&gt;st[q[i].v]) swap(q[i].u,q[i].v); if (getlca(q[i].u,q[i].v)==q[i].u) q[i].u=st[q[i].u]+1,q[i].v=st[q[i].v]; else q[i].u=ed[q[i].u],q[i].v=st[q[i].v]; &#125; sort(q+1,q+m+1);N=100000/magic+1; memset(cnt,0,sizeof(cnt));memset(visited,false,sizeof(visited)); for (register int i=q[1].u;i&lt;=q[1].v;i++) doit(i); fans[q[1].ind]=calc();int L=q[1].u,R=q[1].v; for (register int i=2;i&lt;=m;i++) &#123; while (L&lt;q[i].u) doit(L++); while (L&gt;q[i].u) doit(--L); while (R&lt;q[i].v) doit(++R); while (R&gt;q[i].v) doit(R--); fans[q[i].ind]=calc(); &#125; for (register int i=1;i&lt;=m;i++) printf("%d\n",fans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>莫队</category>
        <category>树上莫队</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>分块</tag>
        <tag>树上莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #458C]Elections 题解]]></title>
    <url>%2Fblog%2Fcf458c%2F</url>
    <content type="text"><![CDATA[DescriptionYou are running for a governor in a small city in Russia. You ran some polls and did some research, and for every person in the city you know whom he will vote for, and how much it will cost to bribe that person to vote for you instead of whomever he wants to vote for right now. You are curious, what is the smallest amount of money you need to spend on bribing to win the elections. To win elections you need to have strictly more votes than any other candidate. InputFirst line contains one integer n (1 ≤ n ≤ 1e5) — number of voters in the city. Each of the next n lines describes one voter and contains two integers ai and bi (0 ≤ ai ≤ 1e5; 0 ≤ bi ≤ 1e4) — number of the candidate that voter is going to vote for and amount of money you need to pay him to change his mind. You are the candidate 0 (so if a voter wants to vote for you, ai is equal to zero, in which case bi will also be equal to zero). OutputPrint one integer — smallest amount of money you need to spend to win the elections. ExamplesInput 5 1 2 1 2 1 2 2 1 0 0 Output 3 Input 4 1 2 1 2 2 1 0 0 Output 2 Input 1 100000 0 Output 0 Solution我们考虑对于一个数$x$,如果将其他政党的支持人数压到不超过$x$，且保证自己政党的人数超过$x$从而获得胜利，最小的花费$f(x)$是多少。 刚开始我以为这个东西是有单调性的，但后来发现不是。我们可以略微感性地理解一下$f(x)$的变化趋势：当$x$很小时，我们要将其他政党的很多人都拉到我们这边来，这样是一笔很大的花费，而此时我的人数其实已经远超过$x$了，所以其实我并不需要拉这么多人来，因此在一个阶段内，随着$x$的递增,$f(x)$的值会减小。但考虑在某个时刻之后，当$x$变得很大时，为了让我的政党的人数超过$x$，我需要从别的政党那里挖大量的墙脚，当我终于超过$x$的时候却发现别的政党其实剩的人已经很少了，所以其实我并不需要拉那么多人，因此在过了一个临界值之后我拉更多的人显得没有必要。通过上面的论述，应该能感觉到$f(x)$有一个转折点，即$f(x)$是单峰函数（其实应该叫单谷？），我们就是要找到那个最小的点。 找单峰函数的极值点的喜闻乐见的做法是三分。现在我们要解决的问题是对于一个$x$如何快速的求出$f(x)$ 考虑贪心，我们对每个政党的所有投票人，将他们的价格从小到大排序，然后考虑每一个政党，如果它的人数大于$x$,那么就至少要从其中挖掉一定数量的人，显然挖掉那些价格比较小的人会比较好。保证每个政党的人数都不大于$x$之后，如果我们政党的人加上刚才挖来的人数量仍然够不到$x$，就需要从别的政党继续挖人，此时应该取其他所有政党剩下的人中价格最小的，考虑到所有的$b_i\leq 10^4$，我们可以将其他政党剩下的人的价格进行桶排序。 这样单独计算一个$f(x)$的时间复杂度是$O(n)$，所以总时间复杂度是$O(nlog_3n)$，但注意到三分有一个2的常数，所以三分是没有二分快的这不是显然的吗 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int #define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:-res);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;template&lt;typename T&gt; inline void gcd(T x,T y) &#123;return ((!y)?x:gcd(y,x%y));&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e5;int n;vector&lt;int&gt; v[MAXN+48];int cc[MAXN+48];inline int calc(int cmp)&#123; if (cmp==n) return INF; int cnt=int(v[0].size()),res=0; for (register int i=0;i&lt;=10000;i++) cc[i]=0; for (register int i=1;i&lt;=MAXN;i++) &#123; if (int(v[i].size())&gt;cmp) &#123; for (register int j=0;j&lt;int(v[i].size())-cmp;j++) res+=v[i][j]; cnt+=int(v[i].size())-cmp; &#125; int st=((int(v[i].size())&gt;cmp)?int(v[i].size())-cmp:0); for (register int j=st;j&lt;int(v[i].size());j++) cc[v[i][j]]++; &#125; int pt=0; while (cnt&lt;=cmp) &#123; while (!cc[pt]) pt++; res+=pt;cnt++;cc[pt]--; &#125; return res;&#125;int main ()&#123; Get(n);int x,y; for (register int i=1;i&lt;=n;i++) Get(x),Get(y),v[x].pb(y); for (register int i=0;i&lt;=MAXN;i++) sort(v[i].begin(),v[i].end()); int l=0,r=n,mid1,mid2; while (r-l+1&gt;10) &#123; mid1=(l+l+r)/3;mid2=(l+r+r)/3; if (calc(mid1)&gt;calc(mid2)) l=mid1; else r=mid2; &#125; int ans=INF; for (register int i=l;i&lt;=r;i++) check_min(ans,calc(i)); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>三分</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>三分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #115D]Unambiguous Arithmetic Expression 题解]]></title>
    <url>%2Fblog%2Fcf115d%2F</url>
    <content type="text"><![CDATA[DescriptionLet’s define an unambiguous arithmetic expression (UAE) as follows. All non-negative integers are UAE’s. Integers may have leading zeroes (for example, 0000 and 0010 are considered valid integers). If X and Y are two UAE’s, then “(X) + (Y)”, “(X) - (Y)”, “(X) * (Y)”, and “(X) / (Y)” (all without the double quotes) are UAE’s. If X is an UAE, then “ - (X)” and “ + (X)” (both without the double quotes) are UAE’s. You are given a string consisting only of digits (“0” - “9”) and characters “-“, “+”, “*”, and “/“. Your task is to compute the number of different possible unambiguous arithmetic expressions such that if all brackets (characters “(“ and “)”) of that unambiguous arithmetic expression are removed, it becomes the input string. Since the answer may be very large, print it modulo 1000003 (1e6 + 3). InputThe first line is a non-empty string consisting of digits (‘0’-‘9’) and characters ‘-‘, ‘+’, ‘*’, and/or ‘/‘. Its length will not exceed 2000. The line doesn’t contain any spaces. OutputPrint a single integer representing the number of different unambiguous arithmetic expressions modulo 1000003 (106 + 3) such that if all its brackets are removed, it becomes equal to the input string (character-by-character). ExamplesInput 1+2*3 Output 2 Input 03+-30+40 Output 3 Input 5//4 Output 0 Input 5/0 Output 1 Input 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 Output 100728 NoteFor the first example, the two possible unambiguous arithmetic expressions are: ((1) + (2)) * (3) (1) + ((2) * (3)) For the second example, the three possible unambiguous arithmetic expressions are: (03) + (( - (30)) + (40)) (03) + ( - ((30) + (40))) ((03) + ( - (30))) + (40) Solution一道神dp题。 首先一个$O(n^3)$的dp是非常好想的，直接考虑区间dp，然后枚举中间断点转移即可。 然后就不会了 我们先把一些必定无解的情况判掉，有两种： 乘号和除号必须作为连接运算符而不能作为符号位，所以如果乘号和除号的前面不是数字必然无解 如果最后一个字符不是数字必然无解 其他的情况都有解。与此同时，我们还能判断出每个加号和减号是什么类型的：对于一串连续的符号，只有第一个符号是连接运算符，其他的都是符号位。 我们考虑这样的一个例子： (+(233))−(8) 这其中的加减运算符有的是连接运算符，有的是符号位，我们考虑统一一下，对于所有的符号位，我们看做是一个空括号和后面的东西相加，这样所有的符号就都是连接运算符了，上述的例子变成了这样 (()+(233))-(8) 这时每个符号作为连接运算符，都对应着左边的一对括号和右边的一对括号，我们把每个运算符右边对应的括号去掉，上述例子变成这样 (()+233)-8 再把所有的数字去掉，得到 (()) 以此为例，我们发现一个UAE可以对应到一个括号序列上，而且所有括号对的右括号按照运算符的出现顺序出现。这里的括号之间的嵌套和并列关系本质上刻画了UAE运算过程中左边和右边谁包含谁的关系，比如上面的例子中是一对嵌套的括号，就意味着加号所连接的东西以一个整体作为减号的左边部分，即右边包含了左边。 我们再看一个例子，还是上面的数字和符号，另一个UAE +((233)-(8)) 按照规则对应的括号序列是 ()() 这样并列的括号刻画的是右边的减号所连接的东西以一个整体作为加号的右边部分，即左边包含了右边。 因此一个括号序列可以非常严密的刻画UAE所有运算的顺序，从而与UAE中符号个数相等的括号形成的括号序列和UAE成一一对应关系。另外要注意的是，所有在先前作为符号位出现的运算符，因为我们是给它人为地加了一对括号，所以它对应的括号不能包含任何其他的括号。 现在我们只要计算符合上述条件的括号序列个数即可，到了这一步就很容易了。令$dp[i][j]$表示当前考虑到第$i$个运算符，当前序列由$j$个并列的括号构成的方案数。转移考虑最后一对括号的左括号放在哪里。如果第$i$个运算符是一个符号位，那么它只能是在原序列的基础上在结尾加一对空括号形成，$dp[i][j]$从$dp[i-1][j-1]$转移而来，否则当前的这对括号可以包住之前的0对，1对，2对…括号，那些被包在里面的括号将不能继续用于转移。$dp[i][j]$从$dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]…$转移而来，这个可以在dp的过程中维护一个后缀和。 总时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e6+3;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2000;char s[MAXN+48];int len;int n,type[MAXN+48];int dp[MAXN+48][MAXN+48],sum[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);len=strlen(s+1); for (register int i=1;i&lt;=len;i++) &#123; if (isdigit(s[i])) continue; if (s[i]=='*' || s[i]=='/') &#123; type[++n]=0; if (i==1 || !isdigit(s[i-1])) &#123;printf("0\n");return 0;&#125; &#125; if (s[i]=='+' || s[i]=='-') &#123; ++n; if (i&gt;1 &amp;&amp; !isdigit(s[i-1])) type[n]=1; &#125; &#125; if (!isdigit(s[len])) &#123;printf("0\n");return 0;&#125; dp[0][0]=1;sum[0][0]=1; for (register int i=1;i&lt;=n;i++) for (register int j=i;j&gt;=1;j--) &#123; Add(dp[i][j],dp[i-1][j-1]); if (!type[i]) Add(dp[i][j],sum[i-1][j]); sum[i][j]=add(sum[i][j+1]+dp[i][j]); &#125; int ans=0; for (register int i=0;i&lt;=n;i++) Add(ans,dp[n][i]); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #19E]Fairy 题解]]></title>
    <url>%2Fblog%2Fcf19e%2F</url>
    <content type="text"><![CDATA[DescriptionOnce upon a time there lived a good fairy A. One day a fine young man B came to her and asked to predict his future. The fairy looked into her magic ball and said that soon the fine young man will meet the most beautiful princess ever and will marry her. Then she drew on a sheet of paper n points and joined some of them with segments, each of the segments starts in some point and ends in some other point. Having drawn that picture, she asked the young man to erase one of the segments from the sheet. Then she tries to colour each point red or blue so, that there is no segment having points of the same colour as its ends. If she manages to do so, the prediction will come true. B wants to meet the most beautiful princess, that’s why he asks you to help him. Find all the segments that will help him to meet the princess. InputThe first input line contains two integer numbers: n — amount of the drawn points and m — amount of the drawn segments (1 ≤ n ≤ 1e4, 0 ≤ m ≤ 1e4). The following m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v, u (1 ≤ v ≤ n, 1 ≤ u ≤ n) — indexes of the points, joined by this segment. No segment is met in the description twice. OutputIn the first line output number k — amount of the segments in the answer. In the second line output k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order. ExamplesInput 4 4 1 2 1 3 2 4 3 4 Output 4 1 2 3 4 Input 4 5 1 2 2 3 3 4 4 1 1 3 Output 1 5 Solution 1简单来说就是从图中删掉一条边，使得图中没有奇环。 考虑对原图求出dfs树，则此时我们的边只有树边和返祖边两种（因为这是一个无向图）。根据返祖边连接的两个点的深度差的奇偶性可以判断所有返祖边所在的环长的奇偶性。 如果原图中没有奇环，那么任意删去一条边以后肯定也没有奇环，这种平凡的情况以下不讨论。 否则分两种情况讨论： 删去一条非树边：则原图中必须只有一个奇环，这显然是必要的。 删去一条树边，则该树边必须为所有奇环的公共边，这也是必要的。 接下来考虑要使得条件充分还需要什么。我们考虑到如果一个奇环和一个偶环相交的话，那么这两个环的复合环肯定是一个奇环，如果删除的是奇环和偶环的公共部分的话仍然会有奇环。 那么删除不在任意一个偶环中且在所有奇环中的一条边是否是该问题的充要条件呢？答案是肯定的。轻微玄学，仔细yy若干情况感觉很对 考虑到这里这个问题就有很多做法了，比如比较暴力的做法可以直接树链剖分，对奇环所在的树链和偶环所在的树链打标记。 但这样就完全没有利用无向图的dfs树只有返祖边的这个优良性质，考虑一个简单的差分打标记做法，对于奇环,在y+1,x-1，这样从上到下做一个前缀和就能得到每条边被多少个奇环覆盖，再判断一下有没有被偶环覆盖，做法是相当的 还有一个比较神奇的做法，我们令奇环对应的非树边是坏边，偶环对应的非树边是好边，那么要判断一条边是否被偶环覆盖，我们可以考虑扔掉坏边对剩下的图求一个边双联通分量，如果某一条边是桥的话那么它没有被偶环覆盖，否则被偶环覆盖。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327// 树链剖分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];int ansnum;vector&lt;int&gt; ans;struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntgedge,ntbedge;int fa[10048],fa_ind[10048];bool visited[10048];int num[10048];vector&lt;int&gt; vv[10048];int tot;int dep[10048],depth[10048],sz[10048],son[10048],ffa[10048];int tpos[10048],ind=0,top[10048];int anc[10048][21];void dfs(int cur)&#123; visited[cur]=true; if (!fa[cur]) num[fa_ind[cur]]=++tot; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); num[v[cur][i].y]=++tot; anc[to][0]=cur;dep[to]=dep[cur]+1; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; dfs(to); vv[num[fa_ind[cur]]].pb(num[v[cur][i].y]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; dep[cur]&gt;dep[to]) &#123; if (!((dep[cur]-dep[to])&amp;1)) ntbedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); else ntgedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125; &#125;&#125;void dfs1(int cur,int father)&#123; ffa[cur]=father;sz[cur]=1;son[cur]=0; int i,to,max_size=-1; for (i=0;i&lt;int(vv[cur].size());i++) &#123; to=vv[cur][i];depth[to]=depth[cur]+1; dfs1(to,cur); sz[cur]+=sz[to]; if (sz[to]&gt;max_size) &#123; max_size=sz[to]; son[cur]=to; &#125; &#125;&#125;void dfs2(int cur,int tp)&#123; top[cur]=tp;tpos[cur]=++ind; if (son[cur]) dfs2(son[cur],tp); int i; for (i=0;i&lt;int(vv[cur].size());i++) if (vv[cur][i]!=son[cur]) dfs2(vv[cur][i],vv[cur][i]);&#125;struct node&#123; int left,right; int cnt;&#125;tree_good[40048],tree_bad[40048];void build_good(int cur,int left,int right)&#123; tree_good[cur].left=left;tree_good[cur].right=right;tree_good[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_good(cur&lt;&lt;1,left,mid); build_good(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void build_bad(int cur,int left,int right)&#123; tree_bad[cur].left=left;tree_bad[cur].right=right;tree_bad[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_bad(cur&lt;&lt;1,left,mid); build_bad(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void update_good(int cur,int left,int right)&#123; if (left&lt;=tree_good[cur].left &amp;&amp; tree_good[cur].right&lt;=right) &#123; tree_good[cur].cnt++; return; &#125; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (left&lt;=mid) update_good(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_good(cur&lt;&lt;1|1,left,right);&#125;void update_bad(int cur,int left,int right)&#123; if (left&lt;=tree_bad[cur].left &amp;&amp; tree_bad[cur].right&lt;=right) &#123; tree_bad[cur].cnt++; return; &#125; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (left&lt;=mid) update_bad(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_bad(cur&lt;&lt;1|1,left,right);&#125;int query_good(int cur,int pos)&#123; if (tree_good[cur].left==tree_good[cur].right) return tree_good[cur].cnt; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_good(cur&lt;&lt;1,pos)+tree_good[cur].cnt; else return query_good(cur&lt;&lt;1|1,pos)+tree_good[cur].cnt;&#125;int query_bad(int cur,int pos)&#123; if (tree_bad[cur].left==tree_bad[cur].right) return tree_bad[cur].cnt; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_bad(cur&lt;&lt;1,pos)+tree_bad[cur].cnt; else return query_bad(cur&lt;&lt;1|1,pos)+tree_bad[cur].cnt;&#125;void doit_good(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_good(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_good(1,tpos[v],tpos[u]);&#125;void doit_bad(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_bad(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_bad(1,tpos[v],tpos[u]);&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int getbelow(int u,int v)&#123; int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;dep[v]) u=anc[u][i]; return u;&#125;Pair query_node(int u,int v)&#123; int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return mp(num[fa_ind[u]],num[fa_ind[v]]); if (dep[u]&lt;dep[v]) swap(u,v); int tmp=getbelow(u,v); return mp(num[fa_ind[u]],num[fa_ind[tmp]]);&#125;int main ()&#123; int i,j,cur,x,y;int wei; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); if (i==1) wei=x; edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0;ansnum=0; for (cur=1;cur&lt;=n;cur++) if (!visited[cur]) &#123; for (j=1;j&lt;=tot;j++) vv[j].clear(); tot=0;fa[cur]=fa_ind[cur]=0;dep[cur]=1; tedge.clear();ntgedge.clear();ntbedge.clear(); dfs(cur); depth[cur]=1;dfs1(1,0); ind=0;dfs2(1,1); if (!int(ntbedge.size())) continue; all_cnt++; if (int(ntbedge.size())==1) &#123; ansnum++; ans.pb(ntbedge[0].ind); &#125; build_good(1,1,ind);build_bad(1,1,ind); for (i=0;i&lt;int(ntgedge.size());i++) &#123; Pair res=query_node(ntgedge[i].x,ntgedge[i].y); doit_good(res.x,res.y); &#125; for (i=0;i&lt;int(ntbedge.size());i++) &#123; Pair res=query_node(ntbedge[i].x,ntbedge[i].y); doit_bad(res.x,res.y); &#125; for (i=0;i&lt;int(tedge.size());i++) &#123; if (dep[tedge[i].x]&gt;dep[tedge[i].y]) swap(tedge[i].x,tedge[i].y); if (query_good(1,tpos[num[fa_ind[tedge[i].y]]])==0 &amp;&amp; query_bad(1,tpos[num[fa_ind[tedge[i].y]]])==int(ntbedge.size())) &#123; ansnum++; ans.pb(tedge[i].ind); &#125; &#125; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// 差分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+9;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;bool istree[10048];int L[10048],R[10048];int a[10048],pos[10048],ind;bool visited[10048];int depth[10048];int sum1[10048],sum2[10048];bool col[10048];int node[10048],tot=0;vector&lt;int&gt; ans;int ansnum;bool ins[10048];void dfs(int cur)&#123; node[++tot]=cur; visited[cur]=true; a[++ind]=cur;pos[cur]=ind; L[cur]=ind; int i,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; istree[v[cur][i].y]=true; depth[to]=depth[cur]+1; col[to]=col[cur]^1; dfs(to); &#125; &#125; R[cur]=ind;&#125;int main ()&#123; int i,j,k,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0,cnt; bool hasbaned=false; ansnum=0; for (i=1;i&lt;=n;i++) if (!visited[i]) &#123; cnt=0; depth[i]=1;col[i]=false; ind=0;tot=0; dfs(i); //for (i=1;i&lt;=n;i++) cout&lt;&lt;visited[i]&lt;&lt;' '; //cout&lt;&lt;endl; bool f=false; for (j=1;j&lt;=tot;j++) for (k=0;k&lt;int(v[node[j]].size());k++) &#123; int eind=v[node[j]][k].y; if (depth[edge[eind].x]&gt;depth[edge[eind].y]) swap(edge[eind].x,edge[eind].y); if (!ins[eind]) &#123; ins[eind]=true; if (!istree[eind]) &#123; ntedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); if (col[edge[eind].x]^col[edge[eind].y]) &#123; sum1[pos[edge[eind].x]]--; sum1[pos[edge[eind].y]]++; &#125; else &#123; hasbaned=true;f=true;cnt++; sum2[pos[edge[eind].x]]--; sum2[pos[edge[eind].y]]++; &#125; &#125; else tedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); &#125; &#125; if (f) all_cnt++; if (!cnt) continue; if (cnt==1) &#123; ansnum=1; for (j=0;j&lt;int(ntedge.size());j++) if (!(col[ntedge[j].x]^col[ntedge[j].y])) &#123; ans.pb(ntedge[j].ind); break; &#125; &#125; for (j=1;j&lt;=tot;j++) sum1[j]+=sum1[j-1],sum2[j]+=sum2[j-1]; for (j=0;j&lt;int(tedge.size());j++) if (sum2[R[tedge[j].y]]-sum2[L[tedge[j].y]-1]==cnt &amp;&amp; sum1[R[tedge[j].y]]-sum1[L[tedge[j].y]-1]==0) &#123; ansnum++; ans.pb(tedge[j].ind); &#125; for (i=1;i&lt;=tot;i++) sum1[i]=sum2[i]=0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; if (!hasbaned) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (j=0;j&lt;int(ans.size());j++) printf("%d ",ans[j]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// 边双联通分量#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;int ansnum;vector&lt;int&gt; ans;vector&lt;Pair&gt; v[10048];int dfn[10048],low[10048],ind;int depth[10048],fa[10048],fa_ind[10048];bool iseven[10048];int anc[10048][21];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;Pair edge[10048];void Tarjan(int cur)&#123; dfn[cur]=low[cur]=++ind; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!dfn[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; depth[to]=depth[cur]+1; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); anc[to][0]=cur; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; Tarjan(to); low[cur]=min(low[cur],low[to]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; (depth[cur]-depth[to])&amp;1) low[cur]=min(low[cur],dfn[to]); if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; !((depth[cur]-depth[to])&amp;1)) ntedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125;&#125;int lca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (depth[anc[u][i]]&gt;=depth[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int Low(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return -1; return u;&#125;bool isanc(int u,int v)&#123; if (u==v) return false; return lca(u,v)==u;&#125;int main ()&#123; int i,cur,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; int all_cnt=0,superf=true; for (cur=1;cur&lt;=n;cur++) if (!dfn[cur]) &#123; tedge.clear();ntedge.clear(); fa[cur]=0;ind=0;depth[cur]=1; Tarjan(cur); for (i=0;i&lt;int(tedge.size());i++) &#123; if (depth[tedge[i].x]&gt;depth[tedge[i].y]) swap(edge[i].x,edge[i].y); if (low[tedge[i].y]!=dfn[tedge[i].y]) iseven[tedge[i].ind]=true; &#125; if (int(ntedge.size())) all_cnt++; if (int(ntedge.size())==1) &#123; ansnum++; ans.pb(ntedge[0].ind); &#125; int curu=-2,curv=-2; for (i=0;i&lt;int(ntedge.size());i++) &#123; if (depth[ntedge[i].x]&gt;depth[ntedge[i].y]) swap(ntedge[i].x,ntedge[i].y); if (curu==-2) &#123; curu=ntedge[i].x; curv=ntedge[i].y; continue; &#125; curu=Low(ntedge[i].x,curu); if (curu==-1) &#123; superf=false; break; &#125; curv=lca(ntedge[i].y,curv); if (!isanc(curu,curv)) &#123; superf=false; break; &#125; &#125; if (!superf) break; for (;curv!=curu;curv=fa[curv]) if (!iseven[fa_ind[curv]]) &#123; ansnum++; ans.pb(fa_ind[curv]); &#125; &#125; if (!superf) &#123; printf("0\n"); return 0; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); &#125; return 0;&#125; Solution 2如果你没有yy出那个非常好用的充要条件，我们仍然有一个非常好的基于分治和可撤销并查集的做法。 首先判断一个图是否存在奇环等价于判断一个图是否是二分图，这个有一个喜闻乐见的并查集做法： 对于一个点$i$，令编号为$i$的点表示它是白色，令编号是$n+i$的点表示它是黑色。如果图中有一条边$(u,v)$，那么$u$和$n+v$连边，$n+u$和$v$连边，表示如果一个是黑的另一个一定是白的。最后对于每一个$i$判断$i$和$n+i$是否连通，如果连通说明导出了矛盾，从而原图不是二分图。 现在对于每一条边，我们希望得到删除它之后的并查集，如果暴力的把其他剩余的边加入并查集就是$O(m^2)$的。考虑分治,$solve(l,r)$表示当前我要解决最后删除的边编号在$l$到$r$之间的情况。如果那么流程如下: 如果$l==r$，说明这条边可以删除，返回 令$mid=(l+r)/2$ 将$[mid+1,r]$之间的边加入并查集，如果仍然合法，递归$solve(l,mid)$ 将$[mid+1,r]$之间的边从并查集中撤销 将$[l,mid]$之间的边加入并查集，如果仍然合法，递归$solve(mid+1,r)$ 将$[l,mid]$之间的边从并查集中撤销，返回 注意判断是否合法的时候不需要check所有的点，只需要check当前加入的这些边所相连的点就可以了。 因为这里的并查集要支持撤销，所以只按秩合并不路径压缩，从而总时间复杂度$O(nlog^2n)$ Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;struct Ope&#123; int x,y; bool type;&#125;ope[100048];int tot=0;int pre[20048],rnk[20048];int find_anc(int x)&#123; while (pre[x]!=x) x=pre[x]; return x;&#125;void update(int x,int y)&#123; x=find_anc(x);y=find_anc(y); if (x==y) &#123; ope[++tot]=Ope&#123;x,y,false&#125;; return; &#125; if (rnk[x]&gt;=rnk[y]) &#123; pre[y]=x; ope[++tot]=Ope&#123;x,y,false&#125;; if (rnk[x]==rnk[y]) rnk[x]++,ope[tot].type=true; &#125; else &#123; ope[++tot]=Ope&#123;y,x,false&#125;; pre[x]=y; &#125;&#125;void undo()&#123; int x=ope[tot].x,y=ope[tot].y; pre[y]=y; if (ope[tot].type) rnk[x]--; tot--;&#125;int n,e;Pair edge[10048];int ansnum;vector&lt;int&gt; ans;bool Conflict=false;void Add(int x,int y)&#123; //if (find_anc(x)==find_anc(y+n)) Conflict=true; update(x,y+n); //if (find_anc(x+n)==find_anc(y)) Conflict=true; update(x+n,y); if (find_anc(x)==find_anc(x+n) || find_anc(y)==find_anc(y+n)) Conflict=true;&#125;void solve(int left,int right)&#123; if (left==right) &#123; ansnum++; ans.pb(left); return; &#125; int i,mid=(left+right)&gt;&gt;1; Conflict=false; for (i=left;i&lt;=mid;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(mid+1,right); for (i=left;i&lt;=mid;i++) undo(),undo(); Conflict=false; for (i=mid+1;i&lt;=right;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(left,mid); for (i=mid+1;i&lt;=right;i++) undo(),undo(); Conflict=false;&#125;int main ()&#123; int i; n=getint();e=getint(); if (e==0) &#123; printf("0\n"); return 0; &#125; for (i=1;i&lt;=e;i++) edge[i].x=getint(),edge[i].y=getint(); for (i=1;i&lt;=n*2;i++) pre[i]=i,rnk[i]=1; solve(1,e); printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>图论</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>分治</category>
        <category>可撤销并查集</category>
        <category>dfs树</category>
        <category>Tarjan求边双联通分量</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>分治</tag>
        <tag>可撤销并查集</tag>
        <tag>dfs树</tag>
        <tag>Tarjan求边双联通分量</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #490F]Treeland Tour 题解]]></title>
    <url>%2Fblog%2Fcf490f%2F</url>
    <content type="text"><![CDATA[DescriptionThe “Road Accident” band is planning an unprecedented tour around Treeland. The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have. Treeland consists of n cities, some pairs of cities are connected by bidirectional roads. Overall the country has n - 1 roads. We know that it is possible to get to any city from any other one. The cities are numbered by integers from 1 to n. For every city we know its value ri — the number of people in it. We know that the band will travel along some path, having concerts in some cities along the path. The band’s path will not pass one city twice, each time they move to the city that hasn’t been previously visited. Thus, the musicians will travel along some path (without visiting any city twice) and in some (not necessarily all) cities along the way they will have concerts. The band plans to gather all the big stadiums and concert halls during the tour, so every time they will perform in a city which population is larger than the population of the previously visited with concert city. In other words, the sequence of population in the cities where the concerts will be held is strictly increasing. In a recent interview with the leader of the “road accident” band promised to the fans that the band will give concert in the largest possible number of cities! Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities, so that the population number will increase, and the number of concerts will be the largest possible. The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland. Looks like they can’t manage without some help from a real programmer! Help the fans find the sought number of concerts. InputThe first line of the input contains integer n (2 ≤ n ≤ 6000) — the number of cities in Treeland. The next line contains n integers r1, r2, …, rn (1 ≤ ri ≤ 106), where ri is the population of the i-th city. The next n - 1 lines contain the descriptions of the roads, one road per line. Each road is defined by a pair of integers aj, bj (1 ≤ aj, bj ≤ n) — the pair of the numbers of the cities that are connected by the j-th road. All numbers in the lines are separated by spaces. OutputPrint the number of cities where the “Road Accident” band will have concerts. Examplesinput 6 1 2 3 4 5 1 1 2 2 3 3 4 3 5 3 6 output 4 input 5 1 2 3 4 5 1 2 1 3 2 4 3 5 output 3 Solution 1这题一眼看上去感觉数据范围出小了，但是还是先想一个$O(n^2)$的算法比较好。 考虑$dp1[i]$表示以$i$为根的子树，且选择了$i$的最长上升序列长度(从下往上看)，$dp2[i]$表示以$i$为根的子树，且选择了$i$的最长下降序列长度(从下往上看)，这两个dp非常好转移，只要枚举子树内的下一个状态就可以了，这个部分显然是$O(n^2)$的。 接下来考虑如何计算答案。一方面，如果这条链在树上没有“拐弯”，那么一定被$dp1[i]$和$dp2[i]$统计到了，将这些dp值取一个max;另一方面，如果拐弯了，考虑枚举转折点$i$，再枚举一对$lca$为$i$的点$(u,v)$作为接下去的状态，那么在$u$和$v$的$r$值符合条件的情况下，用$dp1[u]+dp2[v]$和$dp1[v]+dp2[u]$更新答案，如果转折点$i$的$r$值介于$u$和$v$之间，用上述两个值+1去更新答案。 因为每个点对只会在它们的$lca$处被枚举，所以总时间复杂度$O(n^2)$，枚举$lca$为某个点的点对可以用dfs序作为小技巧。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=6000;int n;int dp1[MAXN+48],dp2[MAXN+48],r[MAXN+48];vector&lt;int&gt; v[MAXN+48];int ans=0;int L[MAXN+48],R[MAXN+48],seq[MAXN+48],link[MAXN+48],ind;inline void dfs(int cur,int father)&#123; seq[++ind]=cur;L[cur]=ind;dp1[cur]=dp2[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) dfs(y,cur); &#125; R[cur]=ind;int maxn1=0,maxn2=0; for (register int i=L[cur]+1;i&lt;=R[cur];i++) &#123; if (r[seq[i]]&lt;r[cur]) check_max(maxn1,dp1[seq[i]]); if (r[seq[i]]&gt;r[cur]) check_max(maxn2,dp2[seq[i]]); &#125; dp1[cur]+=maxn1;dp2[cur]+=maxn2; check_max(ans,dp1[cur]);check_max(ans,dp2[cur]); for (register int i=L[cur]+1;i&lt;=R[cur];i=R[seq[i]]+1) for (register int j=i;j&lt;=R[seq[i]];j++) link[j]=R[seq[i]]+1; for (register int i=L[cur]+1;i&lt;=R[cur];i++) for (register int j=link[i];j&lt;=R[cur];j++) &#123; if (r[seq[i]]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]); if (r[seq[i]]&gt;r[seq[j]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]); if (r[seq[i]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]+1); if (r[seq[j]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[i]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]+1); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]); int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); dfs(1,-1); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125; Solution 2这个过程显然是可以优化的，首先考虑该dp的第一部分，在子树内找$r$值比根节点$r$值大的点中的$lid$和$lds$的长度，显然可以用一个BIT或者权值线段树来解决，这样这个部分可以做到$O(nlogn)$ 第二个部分涉及两个子树之间的合并，考虑线段树合并，在合并两个子树的权值线段树的过程中，我们可以借助线段树本身的分治性来帮我们统计答案，对于线段树合并的每一层，我们只要拿着第一棵树的左孩子的$lis$加上第二棵树的右孩子的$lds$,以及第二棵树的左孩子的$lis$和第一棵树的右孩子的$lds$来更新答案，这样相当于将小于$mid$和大于$mid$的部分进行了合并，再左右分治下去就完成了所有的子树信息的合并。 Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n;vector&lt;int&gt; v[MAXN+48];int r[MAXN+48],val[MAXN+48],cnt;int ans=0;int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*4],rson[MAXN*4],lis[MAXN*4],lds[MAXN*4],tot; inline void init() &#123; memset(root,0,sizeof(root)); memset(lson,0,sizeof(lson)); memset(rson,0,sizeof(rson)); memset(lis,0,sizeof(lis)); memset(lds,0,sizeof(lds)); tot=0; &#125; inline void pushup(int cur) &#123; lis[cur]=lds[cur]=0; if (lson[cur]) check_max(lis[cur],lis[lson[cur]]),check_max(lds[cur],lds[lson[cur]]); if (rson[cur]) check_max(lis[cur],lis[rson[cur]]),check_max(lds[cur],lds[rson[cur]]); &#125; inline int merge(int root1,int root2) &#123; if (!root1 || !root2) return root1^root2; check_max(ans,lis[lson[root1]]+lds[rson[root2]]); check_max(ans,lis[lson[root2]]+lds[rson[root1]]); lson[root1]=merge(lson[root1],lson[root2]);rson[root1]=merge(rson[root1],rson[root2]); pushup(root1);return root1; &#125; inline void modify(int &amp;cur,int pos,int nv,int l,int r,int type) &#123; if (!cur) cur=++tot; if (l==r) &#123; if (type==1) check_max(lis[cur],nv); else check_max(lds[cur],nv); return; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) modify(lson[cur],pos,nv,l,mid,type); else modify(rson[cur],pos,nv,mid+1,r,type); pushup(cur); &#125; inline int query(int &amp;cur,int left,int right,int l,int r,int type) &#123; if (!cur) return 0; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;if (type==1) return lis[cur]; else return lds[cur];&#125; int mid=(l+r)&gt;&gt;1,res=0; if (left&lt;=mid) check_max(res,query(lson[cur],left,right,l,mid,type)); if (mid+1&lt;=right) check_max(res,query(rson[cur],left,right,mid+1,r,type)); return res; &#125;&#125;inline void dfs(int cur,int father)&#123; int maxn1=0,maxn2=0,cmaxn1,cmaxn2; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); cmaxn1=SegmentTree::query(root[y],1,r[cur]-1,1,cnt,1); cmaxn2=SegmentTree::query(root[y],r[cur]+1,cnt,1,cnt,2); check_max(ans,maxn1+cmaxn2+1);check_max(ans,cmaxn1+maxn2+1); check_max(maxn1,cmaxn1);check_max(maxn2,cmaxn2); root[cur]=SegmentTree::merge(root[cur],root[y]); &#125; &#125; SegmentTree::modify(root[cur],r[cur],maxn1+1,1,cnt,1); SegmentTree::modify(root[cur],r[cur],maxn2+1,1,cnt,2);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]),val[i]=r[i]; int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); sort(val+1,val+n+1);cnt=unique(val+1,val+n+1)-(val+1); for (register int i=1;i&lt;=n;i++) r[i]=lower_bound(val+1,val+cnt+1,r[i])-val; SegmentTree::init(); dfs(1,-1);printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树型dp</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #70E]Information Reform 题解]]></title>
    <url>%2Fblog%2Fcf70e%2F</url>
    <content type="text"><![CDATA[DescriptionThought it is already the XXI century, the Mass Media isn’t very popular in Walrusland. The cities get news from messengers who can only travel along roads. The network of roads in Walrusland is built so that it is possible to get to any city from any other one in exactly one way, and the roads’ lengths are equal. The North Pole governor decided to carry out an information reform. Several cities were decided to be chosen and made regional centers. Maintaining a region center takes k fishlars (which is a local currency) per year. It is assumed that a regional center always has information on the latest news. For every city which is not a regional center, it was decided to appoint a regional center which will be responsible for keeping this city informed. In that case the maintenance costs will be equal to dlen fishlars per year, where len is the distance from a city to the corresponding regional center, measured in the number of roads along which one needs to go. Your task is to minimize the costs to carry out the reform. InputThe first line contains two given numbers n and k (1 ≤ n ≤ 180, 1 ≤ k ≤ 105). The second line contains n - 1 integers di, numbered starting with 1 (di ≤ di + 1, 0 ≤ di ≤ 105). Next n - 1 lines contain the pairs of cities connected by a road. OutputOn the first line print the minimum number of fishlars needed for a year’s maintenance. On the second line print n numbers, where the i-th number will represent the number of the regional center, appointed to the i-th city. If the i-th city is a regional center itself, then you should print number i. If there are several solutions to that problem, print any of them. Examplesinput 8 10 2 5 9 11 15 19 20 1 4 1 3 1 7 4 6 2 8 2 3 3 5 output 38 3 3 3 4 3 4 3 3 Solution一道非常神的dp题。 我们可以考虑如下性质：对于任意一棵子树，其中所有被子树外的regional center控制的点，一定都是被同一个regional center控制的，否则如果被多个regional center控制，到子树的根节点最近的regional center一定比其他的优。 考虑如下dp状态：$dp[i][j]$表示考虑以$i$为根的子树，在$j$一定是regional center且$i$被$j$控制的情况下，所有点都被控制的最小花费，其中建立$j$的费用$k$也被计算在内。另外记录$best[i]$表示令$dp[i][j]$取得最小值的$j$。 转移不是非常复杂，考虑$i$的每一个孩子$v$，如果$v$选择和$i$共用一个regional center,则$v$子树的贡献是$dp[v][j]-k$，注意建立$j$的费用在$i$处已经算过了所以要扣除。另外一种情况是$v$没有选择和$i$共用一个regional center，这时$v$子树的贡献是$dp[v][best[v]]$，注意根据上面考虑的性质，$v$选择的regional center必定在$v$子树内才是最优的，所以不用考虑子树$i$向外勾连两个regional center从而导致建立费用算重的情况。更深入的来说,这个dp的转移中有一部分可能是错误的，但只有正确的部分可能是正确答案。 综上，状态转移方程为$dp[i][j]=\sum_{v\in son_i}min(dp[v][best[v]],dp[v][j]-k)$,最终$dp[1][best[1]]$的值就是第一问的答案。 考虑第二问。我们可以倒着考虑$dp[1][best[1]]$的组成，顺着树dfs一遍，每个孩子的$dp[v][j]-k$和$dp[v][best[v]]$比较一下大小就可以得出它是被哪个节点控制的了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=200;int n,k;int dp[MAXN+48][MAXN+48],best[MAXN+48];int d[MAXN+48],dist[MAXN+48][MAXN+48];vector&lt;int&gt; v[MAXN+48];inline void floyd()&#123; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) dist[i][j]=(i==j?0:INF); for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;int(v[i].size());j++) dist[i][v[i][j]]=1; for (register int k=1;k&lt;=n;k++) for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) if (k!=i &amp;&amp; k!=j &amp;&amp; i!=j) check_min(dist[i][j],dist[i][k]+dist[k][j]);&#125;inline void dfs(int cur,int father)&#123; for (register int i=1;i&lt;=n;i++) dp[cur][i]=k+d[dist[cur][i]]; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); for (register int j=1;j&lt;=n;j++) dp[cur][j]+=min(dp[y][j]-k,dp[y][best[y]]); &#125; &#125; best[cur]=1;for (register int i=2;i&lt;=n;i++) if (dp[cur][i]&lt;dp[cur][best[cur]]) best[cur]=i;&#125;int ans[MAXN+48];inline void getans(int cur,int father,int tar)&#123; ans[cur]=tar; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) getans(y,cur,dp[y][tar]-k&lt;=dp[y][best[y]]?tar:best[y]); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);int x,y; for (register int i=1;i&lt;=n-1;i++) io.Get(d[i]); for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; floyd();dfs(1,-1); printf("%d\n",dp[1][best[1]]); getans(1,-1,best[1]); for (register int i=1;i&lt;=n;i++) printf("%d ",ans[i]);printf("\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟赛]b 题解]]></title>
    <url>%2Fblog%2Fb%2F</url>
    <content type="text"><![CDATA[Description给定一个二分图，统计满足$1\leq x&lt;y\leq n,1\leq a&lt;b\leq m$且$(x,a),(x,b),(y,a),(y,b)$之间均有边的四元组(x,y,a,b)的个数 Constraint $1\leq n,m \leq 200,000,1\leq k \leq min(n*m,300,000)$ Solution考虑根号暴力，对于二分图左边的点，如果出边大于$\sqrt{m}$称之为大点，否则称之为小点。 考虑左边两个小点，两个大点和一小一大两个点三种匹配情况。 对于小点和小点的情况，我们考虑对于每个小点$x$向右边的出边集合，枚举所有可能的$(a,b)$，其中$a&lt;b$,这样我们只要统计右边的每一个点对$(a,b)$被覆盖了多少次即可计算。 这个部分可以无脑的用map做，但会多一个log,考虑一种比较精巧的做法，对于每个点对$(a,b)$,我们在下标为a的vector里面添加b,之后我们统计每个vector内每种相同的数有多少个，再$C_x^2$一下就好了。 接下来考虑左边的两个点中有一个是大点的情况，我们枚举每个大点，将它的出边所到达的右边的点标记为１，然后枚举左边的每一个点，看看当前点的出边所到达的右边的点有多少个被标记了，假设第$i$个点有$x_i$个，那么当前大点的贡献就是$\sum_{i=1}^nC_{x_i}^2$，注意扣除一下重复计算的情况。 计算一下时间复杂度。第二部分的时间复杂度比较容易证明，考虑到大点的个数不会超过$\sqrt m$个，所有大点的出边条数的和是$O(m)$的，所以第二部分的时间复杂度是$O(m\sqrt m)$ 第一部分的时间复杂度比较难算，我们尝试抽象这个问题：有一个整数集合${a_n}$，要求$\sum a_i\leq m$且$\forall a_i\leq \sqrt m$，我们要证明$\sum {a_i}^2$的最大值是$O(m\sqrt m)$级别的。 我们发现如下性质：如果集合${a_i}$中存在两个元素$a_1$,$a_2$满足$a_1,a_2\leq \frac{\sqrt m}{2}$，则删除这两个元素将这两个元素的和放入，目标函数的值一定更大，因为$a^2+b^2&lt;{(a+b)}^2$。所以满足目标函数最大的集合，一定对于$\forall i$有$\frac{\sqrt m}{2}\leq a_i\leq \sqrt m$，所以集合的大小$n\leq 2\sqrt m$，从而$\sum {a_i}^2$是$O(m\sqrt m)$级别的。 综上总时间复杂度$O(m\sqrt m)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=448;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,m,k;bool type[MAXN+48];vector&lt;int&gt; v[MAXN+48];vector&lt;int&gt; ed[MAXN+48];int cnt[MAXN+48];inline LL doit_small()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (!type[i]) &#123; for (register int p1=0;p1&lt;int(v[i].size())-1;p1++) for (register int p2=p1+1;p2&lt;int(v[i].size());p2++) &#123; int v1=v[i][p1],v2=v[i][p2]; if (v1&gt;v2) swap(v1,v2); ed[v1].pb(v2); &#125; &#125; for (register int i=1;i&lt;=m;i++) &#123; for (register int j=0;j&lt;int(ed[i].size());j++) res+=cnt[ed[i][j]],cnt[ed[i][j]]++; for (register int j=0;j&lt;int(ed[i].size());j++) cnt[ed[i][j]]--; &#125; return res;&#125;int mark[MAXN+48];inline LL doit_big()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (type[i]) &#123; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=1; for (register int j=1;j&lt;=n;j++) &#123; if (type[j] &amp;&amp; j&lt;=i) continue; int cnt=0; for (register int p=0;p&lt;int(v[j].size());p++) cnt+=mark[v[j][p]]; res+=1ll*cnt*(cnt-1)/2; &#125; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=0; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("b.in","r",stdin); freopen ("b.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int x,y;io.Get(n);io.Get(m);io.Get(k); for (register int i=1;i&lt;=k;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y); &#125; for (register int i=1;i&lt;=n;i++) if (int(v[i].size())&lt;=magic) type[i]=false; else type[i]=true; printf("%lld\n",doit_small()+doit_big()); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
      </categories>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>根号暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces GYM 100518F]Funny Card Game 题解]]></title>
    <url>%2Fblog%2Fgym100518f%2F</url>
    <content type="text"><![CDATA[DescriptionAndrew and his k friends are playing a funny card game. They have a deck of n cards, each one contains a single integer $a_i$ . Andrew is a dealer. His friends are sitting in a circle around him and he deals cards to them. Andrew chooses one of his friends and starts dealing cards to him, one after another. After each card a player can either say “stop”, or say “more”. If the player says “more” he is dealt another card. After he says”stop”, he gets no more cards and his score is equal to the maximal number of times some value occursamong his cards. For example, if the player is dealt cards with values 2, 3, 4, 3, 2, 1, 2 and 5, his score is 3, because 2 occurs 3 times among his cards and no other value has more occurrences. Then the next player who has no cards yet is chosen and Andrew deals cards to him in the same way. The game continues until all but one friends have their cards. The last player gets all the remaining cards. Andrew’s friends has seen the order in which the cards are arranged in the deck. Now they want to choose such strategy that the sum of their scores was maximal possible. Also they want each player to be dealt at least one card. Help them to develop their strategy: for each player from 1 to k − 1 find the card that he must say “stop” after. The last player would receive the rest of the cards. Solution非常不错的dp题 一个复杂度为$O(n^2k)$的dp是非常好想的：考虑dp[i][j]表示当前看到第i张牌，已经划分出j段的最大权值，转移的时候枚举当前人的左端点k，从dp[k-1][j-1]转移来。 考虑优化这个dp,我们可以发现一个非常好的性质：对于dp[i][j]，假如最后一个元素不是第j个人的众数，我们可以直接从dp[i-1][j]转移来，相当于最后给第j个人加一张无用的牌i;假如最后一个元素是第j个人的众数，设a[i]=x,我们可以发现这个人的左端点处的牌一定也是x,因为如果不是x可以把最前面的一段不是x的牌砍掉，当前段众数个数不会变化且前面的答案可以更优。 所以我们可以直接从所有的a[k]=a[i]的k转移来，这个部分可以做一个前缀max优化，我们令maxn[i]表示从1~i所有和a[i]值相同的位置的dp值加上最后的一些a[i]的牌的数量的最大值。预处理每一个位置i之前的一个与它牌值相同的位置pre[i]，则dp[i][j]=max(maxn[pre[i]]+1,1+dp[i-1][j-1])，此时又可以用maxn[pre[i]]和dp[i][j]来更新maxn[i] 总时间复杂度$O(nk)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int k,n;int a[MAXN+48];struct node&#123; int val,from; inline bool operator &lt; (const node &amp;other) const &#123;return val&lt;other.val;&#125;&#125;b[MAXN+48];int pre[MAXN+48],pos[MAXN+48];int dp[101][MAXN+48],maxn[MAXN+48],maxpos[MAXN+48],from[101][MAXN+48];int List[MAXN+48],tot=0;inline void getans(int r,int i)&#123; if (!i) return; List[++tot]=i;getans(r-1,from[r][i]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif freopen ("funny.in","r",stdin); freopen ("funny.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;k) &amp;&amp; n &amp;&amp; k) &#123; for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),b[i].val=a[i],b[i].from=i; sort(b+1,b+n+1);int itot=0; for (register int i=1;i&lt;=n;i++) &#123; if (i==1 || b[i].val!=b[i-1].val) itot++; a[b[i].from]=itot; &#125; for (register int i=1;i&lt;=itot;i++) pos[i]=0; for (register int i=1;i&lt;=n;i++) pre[i]=pos[a[i]],pos[a[i]]=i; for (register int r=1;r&lt;=k;r++) &#123; for (register int i=0;i&lt;=n;i++) maxn[i]=0,maxpos[i]=0;maxn[0]=-INF; for (register int i=1;i&lt;=r-1;i++) dp[r][i]=-INF; for (register int i=r;i&lt;=n;i++) &#123; dp[r][i]=dp[r][i-1];from[r][i]=from[r][i-1]; maxn[i]=maxn[pre[i]]+1;maxpos[i]=maxpos[pre[i]]; if (dp[r-1][i-1]+1&gt;maxn[i]) &#123; maxn[i]=dp[r-1][i-1]+1; maxpos[i]=i-1; &#125; if (maxn[i]&gt;dp[r][i]) dp[r][i]=maxn[i],from[r][i]=maxpos[i]; &#125; &#125; printf("%d\n",dp[k][n]); tot=0;getans(k,n);reverse(List+1,List+k+1); for (register int i=1;i&lt;=k-1;i++) printf("%d ",List[i]); printf("\n"); &#125;#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #260][六校联合训练 #7]环 题解]]></title>
    <url>%2Fblog%2Fnflsoj260%2F</url>
    <content type="text"><![CDATA[Description对于一张 n 个点的竞赛图 G，其中 e 条边的方向已经确定，剩下的边朝向是两边等概率的。 求 G 中最小环的期望个数对 1e9+7 取模的结果。 特别地，若 G 无环，则我们认为这种情况下最小环个数为 0。 Input第一行两个数 n,e。 接下来 e 行，每行两个数 x,y 表示一条确定的边。 Output输出一行一个数表示答案。 Sample 1 &amp; 2见下发文件。 Constraints对于 30% 的数据，n≤300。 对于另 20% 的数据，e=0。 对于另 20% 的数据，e=n(n−1)/2。 对于 100% 的数据，1≤n≤1e5，1≤e≤1e6。 Solution竞赛图有这样一个性质：整张图要么是一个DAG，要么存在三元环。因为考虑每一个三元组(i,j,k)，根据抽屉原理三条边至少有两条边是同向的，此时第三条边如果和前两条同向就形成了三元环，否则就是一个DAG。(这里同向指顺时针和逆时针) 于是这题变成了竞赛图三元环计数，有一种线性的做法：考虑容斥，所有的无序三元组(i,j,k)的个数是$C_N^3$，考虑减去那些不是三元环的三元组，我们发现对于一个不是三元环的三元组，有且仅有一个点的度数为2，我们考虑在这种点上统计个数。 我们枚举每一个点，将其出边两两搭配就能得到所有的非三元环情况，注意每个点的n-1条边中有些边确定是出边，设数量为$p$，有些边确定不是出边，还有一些边没有定向，有$\frac{1}{2}$的概率是出边，设数量为$q$，于是一个点的答案是$\frac{p(p-1)}{2}+p\cdot \frac{q}{2}+\frac{q(q-1)}{2}\cdot \frac{1}{4}$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,e;int cnt[MAXN+48],deg[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(e); int x,y; for (register int i=1;i&lt;=e;i++) &#123; io.Get(x);io.Get(y); cnt[x]++;cnt[y]++;deg[x]++; &#125; int i2=quick_pow(2,MOD-2),i8=1ll*i2*i2%MOD*i2%MOD,i6=quick_pow(6,MOD-2); int ans=1ll*n*(n-1)%MOD*(n-2)%MOD*i6%MOD; for (register int i=1;i&lt;=n;i++) &#123; Sub(ans,1ll*deg[i]*(deg[i]-1)%MOD*i2%MOD); int doubt=(n-1)-cnt[i]; Sub(ans,1ll*deg[i]*doubt%MOD*i2%MOD); Sub(ans,1ll*doubt*(doubt-1)%MOD*i8%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #233][McfXH AK Contest #2]染色 题解]]></title>
    <url>%2Fblog%2Fnflsoj233%2F</url>
    <content type="text"><![CDATA[Problem StatementWXH是天下第一的。一日，他正向众生播撒福音： WXH说——要有树。于是这世上便有了树：一棵n个节点的冒金光的树。 WXH说——要有颜色。于是这树上便有了颜色：n个节点依次从WXH处得到了WXH无私的馈赠—— m种颜色之一。 WXH说——同样的颜色不能靠的太近，也不能太远。于是，所有同色点对距离的最小值介于[L,R]之间的树被留下，而剩余的都被销毁。 WXH发现了一旁的你。WXH对你的无礼感到愤怒，并打算把你做成树的肥料。 你为了证明自己的价值，决定求出WXH一共能够得到多少棵不同的树。 WXH是慈悲的，因而你只要求出这个值对1,000,000,007取模的结果即可。 两棵树是不同的，当且仅当存在至少一个节点得到的颜色不同。 Input第一行四个空格隔开的整数 n,m,L,R,分别表示树的点数WXH的颜色数，以及 WXH钦定的最小值范围。 接下来 n−1行，每行两个空格隔开的整数 u,v，表示这棵冒金光的树上有一条边连接 u 与 v。 Output一行一个整数，表示不同的树的个数对 1,000,000,007取模的结果。 Sample Input3 3 1 2 1 2 2 3 Sample Output21 Sample Explanation除了三个点颜色互不相同的 3!=6种树之外，剩余的 27−6=21 棵树都是可能出现的。 Constraints对于所有数据，1≤n≤1e5，1≤m≤1e9，1&lt;=l,r&lt;=n-1 Subtask 1（15%）：n,m≤5； Subtask 2（10%）：L=R=n−1； Subtask 3（15%）：L=R=1； Subtask 4（20%）：n≤5000； Subtask 5（25%）：L=R； Subtask 6（15%）：无特殊限制。 by diamond_duke PS：由于某天下第一选手被卡常了，本题时限放宽为 1666 ms（std 在最慢的测试点上的运行时间只要约 300 ms）。 PPS：此题数据可能较弱，因此本题开放 hack，请不要恶意 hack。 Solution此题思路略难（逃 首先可以容斥，我们将问题转化成计算（最近点对距离大于等于L的方案数）减去（最近点对距离大于等于R+1的方案数），这样我们只要解决（最近点对距离大于等于x的方案数）这样一个子问题。 考虑最近点对距离大于等于x的这个约束，相当于对于所有距离小于x的点对，这两个点的颜色要求不同。进一步我们发现，对于每个点对只要用深度小的点去约束深度大的点，每个点最终可选的颜色数就是m-约束个数，因为如果有两个点A,B都能约束C，则A,B距离必然小于x，所以A,B的颜色必定不一样。 于是我们可以按照bfs序对原树进行搜索，每搜索到一个点，就查找一下已经被“激活”的点中有多少个和他距离小于x，乘到ans中，再将当前点“激活”即可。 接下来考虑如何计算与当前点距离小于x的点的个数。考虑点分树，即每个重心向以重心为根的所有孩子的子树的重心连边。这样的树的很好的性质是从任意点出发到根的距离都是log级别的。考虑从当前点的重心点出发顺着点分树向上走，每次计算过该重心的路径。从出发点到当前重心有一个距离dis，所以我们要查找当前重心所在树中深度不超过x-dis的点的个数（这个值根据树的深度标号方法可能有一点小出入），这个我们可以对每个重心建一个BIT来维护，但是要注意我们还要减去当前点所在子树的一些不合法的路径，所以还要记录当前点在重心的哪个儿子下面，在这个儿子的BIT里面再算一波。更新的时候就沿着点分树向各个BIT里面插就行了。 时间总复杂度$O(nlog^2n)$，码量略大。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m,L,R;vector&lt;int&gt; v[MAXN+48];int sgn[MAXN*80+48],toc[MAXN+48],tod[MAXN*80+48];int Head[MAXN*80+48],nxt[MAXN*80+48],to[MAXN*80+48],etot=1;inline void addedge(int s,int t) &#123;to[++etot]=t;nxt[etot]=Head[s];Head[s]=etot;&#125;int anc[MAXN+48][21];int depth[MAXN+48];int seq[MAXN*5+48],pos[MAXN*5],stot;inline void dfs_anc(int cur,int father)&#123; seq[++stot]=cur;pos[cur]=stot; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; anc[y][0]=cur; depth[y]=depth[cur]+1;dfs_anc(y,cur); seq[++stot]=cur; &#125; &#125;&#125;int ST[MAXN*5+48][21],Log[MAXN*5+48];inline void init_dist()&#123; depth[1]=1;dfs_anc(1,-1); assert(stot&lt;=MAXN*5); for (register int i=1;i&lt;=stot;i++) ST[i][0]=depth[seq[i]]; for (register int j=1;j&lt;=20;j++) for (register int i=1;i&lt;=stot;i++) &#123; ST[i][j]=ST[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=stot) ST[i][j]=min(ST[i][j],ST[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (register int i=2;i&lt;=stot;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int getlca(int u,int v)&#123; int l=pos[u],r=pos[v]; if (l&gt;r) swap(l,r); int k=Log[r-l+1]; return min(ST[l][k],ST[r-(1&lt;&lt;k)+1][k]);&#125;inline int getdist(int x,int y) &#123;return depth[x]+depth[y]-2*getlca(x,y);&#125;int id=0;namespace BIT&#123; int c[MAXN*80+48]; int starter[MAXN*3+48],len[MAXN*3+48];int tot; inline void clear() &#123;for (register int i=1;i&lt;=tot;i++) c[i]=0;&#125; inline void Create(int ind,int l) &#123; starter[ind]=tot+1;len[ind]=l; tot+=l; &#125; inline void update(int ind,int x,int delta) &#123; x+=starter[ind]-1; int N=starter[ind]+len[ind]-1; while (x&lt;=N) c[x]+=delta,x+=LOWBIT(x); &#125; inline int query(int ind,int x) &#123; int res=0;x+=starter[ind]-1; x=min(x,starter[ind]+len[ind]-1); while (x&gt;=starter[ind]) res+=c[x],x^=LOWBIT(x); return res; &#125; inline int calc(int ind,int left,int right) &#123;return query(ind,right)-query(ind,left-1);&#125;&#125;int sz[MAXN+48];bool visited[MAXN+48];inline void init(int cur,int father)&#123; sz[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y]) init(y,cur),sz[cur]+=sz[y]; &#125;&#125;inline int getroot(int cur,int father,int Sz)&#123; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y] &amp;&amp; sz[y]&gt;Sz/2) return getroot(y,cur,Sz); &#125; return cur;&#125;int q[MAXN+48];int head,tail;inline void doit(int id,int Sz,int Sgn)&#123; sgn[id]=Sgn; BIT::Create(id,Sz);&#125;inline void dfs(int cur,int father)&#123; init(cur,-1); doit(++id,sz[cur],-1);tod[id]=cur; if (father!=-1) addedge(id,father); int rt=getroot(cur,-1,sz[cur]); doit(++id,sz[cur],1);visited[rt]=true;int cid=id;toc[rt]=cid;tod[id]=rt; if (father!=-1) addedge(id,id-1); for (register int i=0;i&lt;int(v[rt].size());i++) &#123; int y=v[rt][i]; if (!visited[y]) dfs(y,cid); &#125;&#125;inline int querygo(int cur,int Len)&#123; int res=0,ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); if (sgn[i]==1) res+=BIT::calc(i,1,Len-dis); else res-=BIT::calc(i,1,Len-dis-2); &#125; return res;&#125;inline void updatego(int cur)&#123; int ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); BIT::update(i,dis+1,1); &#125;&#125;bool vv[MAXN+48];inline int solve(int Len)&#123; head=tail=1;q[head]=1; memset(vv,false,sizeof(vv)); int res=1;BIT::clear(); while (head&lt;=tail) &#123; int x=q[head++];vv[x]=true; res=1ll*res*(m-querygo(toc[x],Len))%MOD; updatego(toc[x]); for (register int i=0;i&lt;int(v[x].size());i++) &#123; int y=v[x][i]; if (!vv[y]) q[++tail]=y; &#125; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);io.Get(L);io.Get(R); int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; init_dist(); dfs(1,-1); io.Print(sub(solve(L)-solve(R+1)),'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;fixed&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数学</category>
        <category>数据结构</category>
        <category>容斥原理</category>
        <category>BIT</category>
        <category>点分树</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
        <tag>清华集训模拟</tag>
        <tag>点分树</tag>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟赛]number 题解]]></title>
    <url>%2Fblog%2Fnumber%2F</url>
    <content type="text"><![CDATA[Description对于所有长度为$k$的满足$\sum_{i=1}^na_i=n$的不下降数列{$a_k$},其权值为$\sum_{i=1}^na_i^m$，求所有满足条件的数列的权值和。 数据范围: $n,m,k&lt;=4096$ Solution非常好的dp题 这题显然的一个思路是用类似背包的dp,令$dp[i][j][k]$表示当前考虑到第$i$个数，所有数的和是$j$，最大的数是$k$的方案数,转移的时候还要考虑下一个数是多少，所以这个dp是$O(n^4)$的，不能接受。 给出一个比较难想的dp思路:令$dp[i][j]$表示当前数列有$i$个数，和为j的方案数，有两种转移： 所有的数都加1，$dp[i][j]\rightarrow dp[i][j+i]$ 在数列的最前面添加一个1，$dp[i][j]\rightarrow dp[i+1]][j+1]$ 可以发现按照这个dp构造数列的方法，所有的满足条件的数列都能不重不漏的构造出来。 现在我们已经知道了方案数，考虑如何计算最后的权值。我们考虑对于一个数$x$，$dp[k-1][n-x]$对应的是序列中至少有一个$x$的方案数，$dp[k-2][n-2x]$对应的是序列中至少有两个$x$的方案数，以此类推。我们发现一个有$num$个$x$的序列会正好在$num$个“至少”的方案数中出现一次，所以我们只要枚举$x$和$num$，累加$dp[k-num][n-x\cdot num] *x^m$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=4096;int n,k,m;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("number.in","r",stdin); freopen ("number.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);io.Get(m); dp[0][0]=1; for (register int i=0;i&lt;=k-1;i++) for (register int j=0;j&lt;=n;j++) if (dp[i][j]) &#123; Add(dp[i+1][j+1],dp[i][j]); if (j+i&lt;=n) Add(dp[i][j+i],dp[i][j]); &#125; int ans=0; for (register int i=1;i&lt;=n;i++) &#123; int base=quick_pow(i,m); for (register int j=1;j&lt;=k &amp;&amp; i*j&lt;=n;j++) Add(ans,1ll*base*dp[k-j][n-i*j]%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3636]教义问答手册 题解]]></title>
    <url>%2Fblog%2Fbzoj3636%2F</url>
    <content type="text"><![CDATA[Description“汉中沃野如关中，四五百里烟蒙蒙。黄云连天夏麦熟，水稻漠漠吹秋风。”——摘自 黄裳《汉中行》 “泉岭精神不朽，汉中诸球永生。”——摘自《泉岭精神创立者语录》 “把神犇烤一烤，味道会更好。”——摘自《xhr语录》 “秀恩爱有利于身心健康！”——摘自《泉岭精神集大成者语录》 “楼上说的对！”——摘自《泉岭精神信徒语录合集》 “不会做积分，怎么找妹子！”——摘自《xhr语录》 “切实保护耕地以放置更多的哨戒炮。”——摘自《泉岭精神信徒语录合集》 “就算两个包子一起吃掉，也不能阻止我修筑梯田。”——摘自《泉岭精神创立者语录》 “我来自泉岭，他来自汉中，我们半道而逢。”——摘自《泉岭精神集大成者语录》 作为泉岭精神的缔造者、信奉者、捍卫者、传承者，Pear决定印制一些教义问答手册，以满足泉岭精神日益增多的信徒。Pear收集了一些有关的诗选、语录，其中部分内容摘录在了【题目背景】里。这些语录是按出现的时间排好序的——Pear很喜欢这样的作风，于是决定在按时间排好序的基础上，选择部分语录，制作成若干本教义问答手册。 一共有N条语录。Pear决定从中选出某一段时间内的所有语录，在此基础上印制大小为L的若干本教义问答手册。Pear对印制的手册有如下要求： 1.每本手册必须包含这个区间内连续的恰好L条语录。 2.不同手册包含的语录不能相同。 3.每条语录有一个“主题相关程度”，这个数可正可负。Pear希望所有手册的语录的“主题相关程度”之和尽可能大。 例如，对于区间[3,15]和L=3，一种选择方法是：[4,6]+[9,11]+[12,14]。这三个区间长度都恰好为L，且互不重叠。 Pear并没有决定选哪段时间的语录，因此他有Q次询问。每次询问，给出两个数[l,r]表示候选语录的范围是第l条到第r条。你能回答出每个询问的最大“主题相关程度”之和么？ Input第一行两个正整数N，L，含义如上所述。注意对于所有询问，L都是一样的。 第二行N个整数，绝对值&lt;=10000。第i个数表示第i条语录的“主题相关程度”。 接下来Q行，每行两个正整数l和r，表示询问区间。 Output输出Q行，每行表示这组询问的答案。注意，这个答案可以是0，如果区间负数过于多的话。 Sample Input15 3 3 1 5 -2 3 -2 -2 2 2 2 0 3 2 -1 0 9 8 10 10 10 9 11 2 14 5 14 5 13 12 13 7 13 2 10 Sample Output6 0 4 17 11 11 0 11 12 HINT【数据范围】 对于10%的数据，N=1000,Q=1000,L&lt;=50 对于另外20%的数据，N=100000,Q=100000,L&lt;=5 对于另外20%的数据，N=100000,Q=100000,L&lt;=10 对于100%的数据，N=100000,Q=100000,L&lt;=50 Source2014年国家集训队十五人互测 Solution这样的题目还是很有启发性的 刚开始看到这样的区间询问，想到的肯定是线段树，但线段树不能只求当前区间的最值，否则无法支持合并。所以我们对每个区间都要维护$L^2$个状态，令$f[x][y]$表示左边$x$个不选，右边$y$个不选的最大值，然后合并两个区间的时候需要枚举跨两边的一个长度为$L$的区间的位置，这样总复杂度是$O(nlognL^3)$，显然是不能通过的。 如果没有$Q$次询问，只是求整个区间的最大选择方案，那我们有一个显然的dp做法：令$dp[i]$表示当前考虑到第$i$个数的最大方案，显然有两种转移：不选这个数，从$dp[i-1]$转移来，或者选这个数所在的一个长度为$L$的区间，从$dp[i-L]+sum(i-L+1,i)$转移来，于是状态转移方程为$$dp[i]=max(dp[i-1],dp[i-L]+sum(i-L+1,i)$$ 如果有多次询问，考虑离线后分治。在$solve(l,r)$的时候，我们只处理跨过该块中间点$(l+r)/2$的区间，完全在左边和完全在右边的区间递归下去处理。 考虑如何处理跨中间的询问，其实处理方法和线段树的区间合并差不多，我们向左向右分别维护$L$个dp状态，$dp1[i][j]$表示从$mid$开始向前的$i$个点没选，从后向前考虑到$j$时的最大方案，$dp2[i][j]$表示从$mid+1$开始向后的$i$个点没选，从前向后考虑到$j$时的最大方案，这两个dp的转移和之前是一样的。然后要么拿两边的max更新，要么枚举跨中间的一个长度为$L$的区间更新，这样复杂度是一个$L$的，因为相当于你在线段树上只求母区间的$f[0][0]$ 分治的总复杂度$O(nlognL)$，可以通过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,L,Q;int a[MAXN+48],sum[MAXN+48];int ans[MAXN+48];inline int calc(int left,int right) &#123;return sum[right]-sum[left-1];&#125;struct Query&#123; int l,r,ind; inline void input() &#123;io.Get(l);io.Get(r);&#125;&#125;q[MAXN+48],tmp1[MAXN+48],tmp2[MAXN+48],tmp3[MAXN+48];int tot1,tot2,tot3;int dp1[51][MAXN+48],dp2[51][MAXN+48];inline void solve(int l,int r,int ql,int qr)&#123; if (l&gt;r) return; if (l==r) &#123; for (register int i=ql;i&lt;=qr;i++) ans[q[i].ind]=((a[l]&gt;=0 &amp;&amp; L&lt;=1)?a[l]:0); return; &#125; int mid=(l+r)&gt;&gt;1;tot1=tot2=tot3=0; for (register int i=ql;i&lt;=qr;i++) &#123; if (q[i].r&lt;=mid) &#123;tmp1[++tot1]=q[i];continue;&#125; if (q[i].l&gt;=mid+1) &#123;tmp2[++tot2]=q[i];continue;&#125; tmp3[++tot3]=q[i]; &#125; int pt=ql,ll=ql+tot1-1,rr=qr-tot2+1; for (register int i=1;i&lt;=tot1;i++) q[pt++]=tmp1[i]; for (register int i=1;i&lt;=tot3;i++) q[pt++]=tmp3[i]; for (register int i=1;i&lt;=tot2;i++) q[pt++]=tmp2[i]; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp1[gap][mid-gap+1]=0; for (register int i=mid-gap;i&gt;=l;i--) &#123; dp1[gap][i]=dp1[gap][i+1]; if (mid-gap-i+1&gt;=L) check_max(dp1[gap][i],dp1[gap][i+L]+calc(i,i+L-1)); &#125; &#125; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp2[gap][mid+gap]=0; for (register int i=mid+1+gap;i&lt;=r;i++) &#123; dp2[gap][i]=dp2[gap][i-1]; if (i-(mid+1+gap)+1&gt;=L) check_max(dp2[gap][i],dp2[gap][i-L]+calc(i-L+1,i)); &#125; &#125; for (register int i=1;i&lt;=tot3;i++) &#123; ans[tmp3[i].ind]=dp1[0][tmp3[i].l]+dp2[0][tmp3[i].r]; for (register int j=mid;j&gt;=mid-(L-1)+1;j--) if (j&gt;=tmp3[i].l &amp;&amp; j+L-1&lt;=tmp3[i].r) check_max(ans[tmp3[i].ind],calc(j,j+L-1)+dp1[mid-j+1][tmp3[i].l]+dp2[j+L-1-(mid+1)+1][tmp3[i].r]); &#125; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid-gap+1;i&gt;=l;i--) dp1[gap][i]=0; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid+gap;i&lt;=r;i++) dp2[gap][i]=0; solve(l,mid,ql,ll);solve(mid+1,r,rr,qr);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(L); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),sum[i]=sum[i-1]+a[i]; io.Get(Q); for (register int i=1;i&lt;=Q;i++) q[i].input(),q[i].ind=i; solve(1,n,1,Q); for (register int i=1;i&lt;=Q;i++) io.Print(ans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM198DIV1C]Soma 题解]]></title>
    <url>%2Fblog%2Ftcsrm198div1c%2F</url>
    <content type="text"><![CDATA[DescriptionSoma is a three dimensional puzzle invented by Piet Hein. You have seven pieces which are formed by joining cubes at their faces. (They are all of the non-convex shapes that can be so formed with four or fewer cubes). Six of the pieces are formed from four cubes and one is formed by three cubes. There are 27 cubes total. The pieces can be described by the following arrays which show how high cubes are stacked in each grid cell, and are also shown in the picture below. 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 1 1 0 0 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 2 &nbsp;&nbsp;&nbsp;&nbsp; 2 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 2 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 The pieces can be translated and rotated into any orientation, to build larger shapes, but can not be reflected (as in a mirror) or disassembled. Pieces may touch, but not intersect. Each piece is used exactly once in a solution. Given pattern (a shape composed of 27 cubes, not necessarily connected), try to arrange the seven soma pieces into the same shape as pattern. In other words, you are constructing pattern using the seven pieces. Return the number of distinct solutions for pattern. What is meant by “distinct”: In a valid solution each cube in pattern will be occupied by a cube from exactly one of the seven pieces. You could assign a number between 1 and 7 inclusive to each pattern cube to indicate which piece occupies that pattern cube. Two solutions are distinct if this assignment is different at one or more pattern cubes. Thus removing a piece which has rotational symmetry, rotating it, and putting it back “in the same place” does not produce a new distinct solution. But a rearrangement of some or all of the pieces which is equivalent to rotating or reflecting the entire pattern (assuming pattern has such symmetry) is considered distinct by this definition. For example the pattern, “21112”, can be constructed in exactly two distinct ways using the pieces “211” and “12”. The distinct ways are “211”-“12” and “21”-“112”. The pattern will be specified in a String[] similar to the arrays showing the individual pieces above. Each character indicates how many cubes are stacked at that location, starting from a common plane at a height of zero. For example: {“333”, “333”, “333”} specifies a 3x3x3 cube which is possible to construct with the seven soma pieces in 11520 distinct (as defined above) ways, so return 11520. DefinitionClass: Soma Method: letMeCountTheWays Parameters: String[] Returns: int Method signature: int letMeCountTheWays(String[] pattern) (be sure your method is public) Notes If no rotational symmetries are involved, there are 24 possible orthogonal orientations resulting from rotations in three dimensions. Visualize the 3x2 “L” shaped piece (which has no rotational symmetry). The top (long end) of the “L” can point in six directions x,y,z,-x,-y,-z. For each of those, the short leg of the “L” can point in one of four directions. 6 x 4 = 24 Each of the other six pieces does have some rotational symmetry, and thus fewer possible distinct orientations. The rotation of a point about a line passing through the origin can be calculated using a single, vector by matrix, multiplication: [x y z]*M=[rx ry rz] where M is a 3 by 3 matrix, [x y z] is the original point and [rx ry rz] is the rotated point. Vector by matrix multiplication is defined as: for(i) { r[i]=0 ; for(j) { r[i]+=p[j]*M[j][i] } } where p is the original point and r is the rotated point. The matrix for 90 degree rotation about the x axis is: {&nbsp;{1,0,0},{0,0,1},{0,-1,0}&nbsp;} The matrix for 90 degree rotation about the y axis is: {&nbsp;{0,0,-1},{0,1,0},{1,0,0}&nbsp;} The matrix for 90 degree rotation about the z axis is: {&nbsp;{0,1,0},{-1,0,0},{0,0,1}&nbsp;} The easiest way to generate all possible orthogonal orientations is to rotate about the x axis (0,90,180 or 270 degrees), then about the y axis (0,90,180 or 270 degrees) then about the z axis (0,90,180,270 degrees). That is 64 combinations of rotations (4x4x4). Try all 64 and throw away those that produce duplicate results. Sequences of rotations in three dimensions are non-commutative. The order in which you apply the rotations matters. There are 240 fundamental patterns to form the cube, proven by the great mathematician, Prof. John H. Conway. 240 x 24 rotations x 2 (for mirror reflection) = 11520. There are 96 ways to rotate individual pieces in each of the 11520 “distinct” ways. 11520 x 96 = 1105920 which is the “over a million ways to build a cube” number the manufacturer uses. Constraints pattern will contain between 2 and 27 elements, inclusive. Each element of pattern will consist of between 2 and 27 characters, inclusive. Each element of pattern will have the same number of characters. Each character in each element of pattern will be a digit between ‘0’ and ‘9’ inclusive. The sum of all the digits in pattern will be exactly equal to 27. Examples0) {“333”, “333”, “333”} Returns: 11520 The cube. 1) {“345”, “234”, “123”} Returns: 2800 The crystal. 2) {“3330000”, “0033300”, “0000333”} Returns: 28 The wall. 3) {“21111111”, “21111111”, “21111111”} Returns: 0 The chase lounge, impossible. 4) {“67”, “77”} Returns: 1520 The tower. 5) {“010000000000000000000000000”, “110000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000022”, “000000000000000000000000022”, “000000000000000000000002222”, “000000000000000000000002222”} Returns: 76 Replication. 6) {“11100110001”, “01001100111”, “00000000000”, “20002012011”, “11011001001”} Returns: 1 Disjoint. 7) {“121”, “222”, “121”, “121”, “333”} Returns: 78 The monument. 8) {“020”, “010”, “010”, “020”, “343”, “353”} Returns: 42 The gallows. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution超级大模拟，不仅代码难写，而且搜索的时候还可能超时 首先预处理所有的soma的24种翻转并剔除掉重复的，旋转可以用题面中notes里的矩阵来实现，判断重复可以计算一下两个soma对应点的位移向量，如果全部一样就是相同的soma，只是位置不一样 搜索的时候找第一个没有被覆盖的格子，然后选一个soma往里面放就行 为了避免超时和尽量减少代码量，应该注意：STL处理方便 但是速度慢，内置数组处理较复杂 但是速度快，因此在时间不紧的预处理过程中 尽可能的使用STL模板，在搜索中尽可能使用标准的数组和指针 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n,m;struct Matrix&#123; int b[4][4]; Matrix () &#123;memset(b,0,sizeof(b));&#125; inline void clear() &#123;memset(b,0,sizeof(b));&#125; inline Matrix (int x,int y,int z) &#123;memset(b,0,sizeof(b));b[1][1]=x;b[1][2]=y;b[1][3]=z;&#125; inline void init_I() &#123;for (register int i=1;i&lt;=3;i++) b[i][i]=1;&#125; inline bool operator &lt; (const Matrix &amp;other) const &#123; if (b[1][3]!=other.b[1][3]) return b[1][3]&lt;other.b[1][3]; if (b[1][1]!=other.b[1][1]) return b[1][1]&lt;other.b[1][1]; return b[1][2]&lt;other.b[1][2]; &#125; inline bool operator == (const Matrix &amp;other) const &#123; for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) if (b[i][j]!=other.b[i][j]) return false; return true; &#125; inline Matrix operator + (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]+ma.b[i][j]; return res; &#125; inline Matrix operator - (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]-ma.b[i][j]; return res; &#125; inline Matrix operator * (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) for (register int k=1;k&lt;=3;k++) res.b[i][j]+=b[i][k]*ma.b[k][j]; return res; &#125;&#125;rx,ry,rz;inline Matrix quick_pow(Matrix x,int y)&#123; Matrix res;res.clear();res.init_I(); while (y) &#123; if (y&amp;1) res=res*x; x=x*x;y&gt;&gt;=1; &#125; return res;&#125;typedef vector&lt;Matrix&gt; soma;struct somapos&#123; int x,y,z; somapos () &#123;&#125; inline somapos(int xx,int yy,int zz) &#123;x=xx;y=yy;z=zz;&#125; inline bool operator &lt; (const somapos &amp;other) const &#123; if (z!=other.z) return z&lt;other.z; if (x!=other.x) return x&lt;other.x; return y&lt;other.y; &#125;&#125;P[48];int tot=0;soma base[48];vector&lt;soma&gt; candidate[48];int Cx[48][48][5],Cy[48][48][5],Cz[48][48][5];int ctot[48],wtot[48];inline soma Move(soma ori,Matrix pos,somapos topos)&#123; Matrix delta;delta.clear(); for (register int i=1;i&lt;=3;i++) delta.b[1][i]=-pos.b[1][i]; delta.b[1][1]+=topos.x;delta.b[1][2]+=topos.y;delta.b[1][3]+=topos.z; for (register int i=0;i&lt;int(ori.size());i++) ori[i]=ori[i]+delta; return ori;&#125;inline soma getsoma(soma ori,int dx,int dy,int dz)&#123; for (register int k=0;k&lt;int(ori.size());k++) for (register int i=2;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) assert(ori[k].b[i][j]==0); for (register int i=0;i&lt;int(ori.size());i++) &#123; ori[i]=ori[i]*quick_pow(rx,dx); ori[i]=ori[i]*quick_pow(ry,dy); ori[i]=ori[i]*quick_pow(rz,dz); &#125; sort(ori.begin(),ori.end()); return ori;&#125;inline bool issame(soma x,soma y)&#123; Matrix cmp=x[0]-y[0]; for (register int i=1;i&lt;int(x.size());i++) if (!(x[i]-y[i]==cmp)) return false; return true;&#125;inline void init_soma()&#123; for (register int i=1;i&lt;=7;i++) base[i].clear(),candidate[i].clear(); base[1].pb(Matrix(1,1,1));base[1].pb(Matrix(2,1,1));base[1].pb(Matrix(3,1,1));base[1].pb(Matrix(1,2,1)); base[2].pb(Matrix(1,1,1));base[2].pb(Matrix(2,1,1));base[2].pb(Matrix(3,1,1));base[2].pb(Matrix(2,2,1)); base[3].pb(Matrix(2,1,1));base[3].pb(Matrix(3,1,1));base[3].pb(Matrix(1,2,1));base[3].pb(Matrix(2,2,1)); base[4].pb(Matrix(1,1,1));base[4].pb(Matrix(2,1,1));base[4].pb(Matrix(1,2,1)); base[5].pb(Matrix(2,1,1));base[5].pb(Matrix(2,1,2));base[5].pb(Matrix(1,2,1));base[5].pb(Matrix(2,2,1)); base[6].pb(Matrix(1,1,1));base[6].pb(Matrix(1,1,2));base[6].pb(Matrix(1,2,1));base[6].pb(Matrix(2,2,1)); base[7].pb(Matrix(1,1,1));base[7].pb(Matrix(2,1,1));base[7].pb(Matrix(2,1,2));base[7].pb(Matrix(2,2,1)); rx.clear();ry.clear();rz.clear(); rx.b[1][1]=1;rx.b[2][3]=1;rx.b[3][2]=-1; ry.b[1][3]=-1;ry.b[2][2]=1;ry.b[3][1]=1; rz.b[1][2]=1;rz.b[2][1]=-1;rz.b[3][3]=1; for (register int i=1;i&lt;=7;i++) sort(base[i].begin(),base[i].end()); for (register int i=1;i&lt;=7;i++) for (register int dx=0;dx&lt;=3;dx++) for (register int dy=0;dy&lt;=3;dy++) for (register int dz=0;dz&lt;=3;dz++) &#123; soma ns=getsoma(base[i],dx,dy,dz);bool f=true; for (register int j=0;j&lt;int(candidate[i].size());j++) if (issame(candidate[i][j],ns)) &#123;f=false;break;&#125; if (f) candidate[i].pb(ns); &#125;&#125;bool exist[48][48][48];class Soma&#123; int ans; int a[48][48]; inline int dfs(int used) &#123; int res=0; if (used==127) return 1; int tox,toy,toz; for (register int i=1;i&lt;=27;i++) if (exist[P[i].x][P[i].y][P[i].z]) &#123;tox=P[i].x;toy=P[i].y;toz=P[i].z;break;&#125; for (register int i=1;i&lt;=7;i++) if (!(used&amp;(1&lt;&lt;(i-1)))) &#123; for (register int j=1;j&lt;=ctot[i];j++) &#123; int deltax=tox-Cx[i][j][1],deltay=toy-Cy[i][j][1],deltaz=toz-Cz[i][j][1]; bool valid=true; for (register int k=2;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; if (!exist[xx][yy][zz]) &#123;valid=false;break;&#125; &#125; if (valid) &#123; for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=false; &#125; used|=(1&lt;&lt;(i-1)); res+=dfs(used); for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=true; &#125; used^=(1&lt;&lt;(i-1)); &#125; &#125; &#125; return res; &#125; inline void toarray() &#123; for (register int i=1;i&lt;=7;i++) &#123; ctot[i]=int(candidate[i].size()); wtot[i]=((i==4)?3:4); for (register int j=1;j&lt;=ctot[i];j++) for (register int k=1;k&lt;=wtot[i];k++) &#123; Cx[i][j][k]=candidate[i][j-1][k-1].b[1][1]; Cy[i][j][k]=candidate[i][j-1][k-1].b[1][2]; Cz[i][j][k]=candidate[i][j-1][k-1].b[1][3]; &#125; &#125; &#125; public: inline int letMeCountTheWays(vector&lt;string&gt; pattern) &#123; n=int(pattern.size());m=int(pattern[0].size()); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) a[i][j]=pattern[i-1][j-1]-'0'; init_soma();toarray(); tot=0;memset(exist,false,sizeof(exist)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) for (register int k=1;k&lt;=a[i][j];k++) &#123; P[++tot]=somapos(i,j,k); exist[i][j][k]=true; &#125; sort(P+1,P+tot+1); for (register int i=1;i&lt;=27;i++) ind[P[i].x][P[i].y][P[i].z]=i; return dfs(0); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; int nn;vector&lt;string&gt; vv;string ss; Soma A; while (cin&gt;&gt;nn) &#123; vv.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;ss,vv.pb(ss); double t=clock(); cout&lt;&lt;A.letMeCountTheWays(vv)&lt;&lt;endl; cerr&lt;&lt;"Time: "&lt;&lt;(clock()-t)/CLOCKS_PER_SEC&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>大模拟</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #8E]Beads 题解]]></title>
    <url>%2Fblog%2Fcf8e%2F</url>
    <content type="text"><![CDATA[DescriptionOne Martian boy called Zorg wants to present a string of beads to his friend from the Earth — Masha. He knows that Masha likes two colours: blue and red, — and right in the shop where he has come, there is a variety of adornments with beads of these two colours. All the strings of beads have a small fastener, and if one unfastens it, one might notice that all the strings of beads in the shop are of the same length. Because of the peculiarities of the Martian eyesight, if Zorg sees one blue-and-red string of beads first, and then the other with red beads instead of blue ones, and blue — instead of red, he regards these two strings of beads as identical. In other words, Zorg regards as identical not only those strings of beads that can be derived from each other by the string turnover, but as well those that can be derived from each other by a mutual replacement of colours and/or by the string turnover. It is known that all Martians are very orderly, and if a Martian sees some amount of objects, he tries to put them in good order. Zorg thinks that a red bead is smaller than a blue one. Let’s put 0 for a red bead, and 1 — for a blue one. From two strings the Martian puts earlier the string with a red bead in the i-th position, providing that the second string has a blue bead in the i-th position, and the first two beads i - 1 are identical. At first Zorg unfastens all the strings of beads, and puts them into small heaps so, that in each heap strings are identical, in his opinion. Then he sorts out the heaps and chooses the minimum string in each heap, in his opinion. He gives the unnecassary strings back to the shop assistant and says he doesn’t need them any more. Then Zorg sorts out the remaining strings of beads and buys the string with index k. All these manupulations will take Zorg a lot of time, that’s why he asks you to help and find the string of beads for Masha. InputThe input file contains two integers n and k (2 ≤ n ≤ 50;1 ≤ k ≤ 1016) —the length of a string of beads, and the index of the string, chosen by Zorg. OutputOutput the k-th string of beads, putting 0 for a red bead, and 1 — for a blue one. If it s impossible to find the required string, output the only number -1. ExamplesInput 4 4 Output 0101 NoteLet’s consider the example of strings of length 4 — 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110. Zorg will divide them into heaps: {0001, 0111, 1000, 1110}, {0010, 0100, 1011, 1101}, {0011, 1100}, {0101, 1010}, {0110, 1001}. Then he will choose the minimum strings of beads in each heap: 0001, 0010, 0011, 0101, 0110. The forth string — 0101. Solution考虑按位确定答案，于是我们要能算出对于一个确定的前缀，有多少个合法的数是以这个前缀开头的。 首先我们可以观察到一个性质：所有的答案的第一位肯定是0，否则它的取反串肯定比他小。在确定了第一位是0之后，我们之后在计算个数的时候就不用考虑取反串和它本身的大小问题了 第二我们可以发现当前串的最后一位如果是0，那么原串的取反串的倒串就肯定比原串小；最后一位如果是1，那么原串的倒串肯定比原串小，所以一旦确定了最后一位，我们就又可以少考虑一种情况。 所以在计算个数的时候，我们先枚举最后一位是0还是1，这样我们自始至终就只要考虑原串和其倒串的大小关系或者是原串和其取反倒串的关系。 先讨论最后一位是0的情况，我们考虑按位枚举后缀，后缀的每一位和前缀的一位相对应。如果前缀的对应位是0，那么后缀的对应位放1就肯定是合法的了，中间可以2的若干次方直接计算答案，当然也可以放0继续和前缀匹配，如果前缀的对应位是1，就只能放1和其匹配。 设当前前缀长度是$len$,我们匹配的总位数是$Len=min(len,n-len)$,全部匹配完之后，我们又要分两种情况讨论： $len\geq \frac{n}{2}$,此时整个串已经完全确定，我们还需要检验一下中间的这些位是否满足条件，这个部分比较简单。 $len&lt;\frac{n}{2}$，此时我们中间还有一些空位要填，考虑如何快速计算有多少种填法符合条件，我们可以发现，如果中间填一个回文串肯定是符合条件的，回文串的个数很好计算，相当于将对应的位打包，个数是$2^{\left \lceil \frac{n-Len-Len}{2}\right \rceil}$。对于不是回文串的串，我们发现一个合法的填法取反肯定是不合法的，一个不合法的填法取反肯定是合法的，所以合法的和不合法的填法一一对应，我们用总填法数减去回文的填法数除以二即可 再讨论最后一位是1的情况，大部分和前面是一样的。我们可以一样的按位和前缀匹配，匹配完了之后$len\geq \frac{n}{2}$的做法也是一样的，但在$len&lt;\frac{n}{2}$的时候，非回文的填法还是那样算，但我们发现回文的填法并不全是合法的，如果$n-Len-Len$是偶数是没有问题的，如果是奇数，我们会发现，最中间的那个单独的一位只能是0不能是1，所以这是回文的合法个数等于回文的总个数除以二。 写起来不长，但很容易错。时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n;LL k;int a[148];LL pw[148];inline LL Count(int len)&#123; int Len=min(len,n-len);LL res=0; //not reverse for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==1) break; if (a[i]==1 &amp;&amp; a[j]==0) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; bool f=true; for (register int i=1;i&lt;=len;i++) if (a[i]) &#123;f=false;break;&#125; if (f) res--; // 000...0 is not allowed if (len==n) return res; //reverse,a[n]=1; for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; if ((n-Len-Len)%2==0) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; p/=2; res+=p+np/2; &#125; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==0) break; if (a[i]==1 &amp;&amp; a[j]==1) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);a[1]=0; pw[0]=1;for (register int i=1;i&lt;=n;i++) pw[i]=pw[i-1]+pw[i-1]; if (Count(1)&lt;k) &#123;printf("-1\n");return 0;&#125; for (register int i=2;i&lt;=n;i++) &#123; a[i]=0; register LL res=Count(i); if (k&gt;res) k-=res,a[i]=1; &#125; for (register int i=1;i&lt;=n;i++) printf("%d",a[i]); printf("\n");#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2018模拟赛]money 题解]]></title>
    <url>%2Fblog%2Fmoney%2F</url>
    <content type="text"><![CDATA[Description给定$n$个节点，有$q$次操作: $0$ $a$ $b$ $c$，表示$a$向$b$连一条有向边，并给$a$赋值$c$ $1$ $a$ $b$，如果$b$是$a$的祖先，输出$a$到$b$路径上的权值最小值（包括$a$的权值，不包括$b$的权值） 保证整张图在任意时刻都是一个森林 $n\leq 100000$,$q\leq 1000000$ Solution非常好的思维题 如果整棵树是静态的，我们肯定希望维护祖先和最小值的倍增表，从而在$log$的时间查询 现在是动态的，但我们发现每个点的祖先和最小值倍增表的值只会添加不会删除，因为每个点的祖先是越来越多的，所以我们只要不重复的修改所有节点的祖先和最小值倍增表，最后的时间复杂度就会是数组的大小$O(nlogn)$ 考虑如何实现，我们对当前的每一颗树维护一个deque,deque里的每个节点又是一个单向链表，表示这棵树这一层的所有节点。 在更新祖先和最小值倍增表的过程中，考虑启发式合并，如果$a$所在的树的深度小于$b$所在的树的深度，我们抓着$a$里面的每个点去更新表格，随着深度的增加，更新的$2^k$的祖先的那个$k$也会增加，有点像two pointers；如果$a$所在的树的深度大于$b$所在的树的深度，我们抓着$b$里面的每个节点去找可能能更新到的$a$的节点，这个也是一个类似two pointers的东西。 在合并树的过程中，我们会发现相同深度的点是很好合并的，只要把第一个链表的结尾接上第二个链表的头就行了，这就是我们用链表存储信息的原因。合并的时候也要启发式，不然复杂度不对。 总时间复杂度$O(nlogn+mlogn)$，注意启发式合并的$log$和处理倍增表的$log$不是叠加的，所以不是$log^2n$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;struct List&#123; int bg,ed; List () &#123;&#125; inline List(int b,int e) &#123;bg=b;ed=e;&#125;&#125;;struct node&#123; int nxt;&#125;nodes[MAXN+48];inline List join(List x,List y)&#123; nodes[x.ed].nxt=y.bg; return List(x.bg,y.ed);&#125;int root[MAXN+48];struct tree&#123; vector&lt;List&gt; L,R; int sz,szl,szr; inline void clear() &#123;L.clear();R.clear();sz=szl=szr=0;&#125; inline void push_back(List nw) &#123;R.pb(nw);szr++;sz++;&#125; inline void push_front(List nw) &#123;L.pb(nw);szl++;sz++;&#125; inline List getind(int id) &#123;return (id&lt;=szl)?L[szl-id]:R[id-szl-1];&#125; inline void modify(int id,List nw) &#123; if (id&lt;=szl) L[szl-id]=nw; else R[id-szl-1]=nw; &#125;&#125;tree[MAXN+48];inline void init()&#123; for (register int i=1;i&lt;=n;i++) nodes[i].nxt=0,root[i]=i; for (register int i=1;i&lt;=n;i++) tree[i].clear(),tree[i].pb(List(i,i));&#125;int anc[MAXN+48][21],minn[MAXN+48][21];inline int getdepth(int u)&#123; int res=0; for (register int i=20;i&gt;=0;i--) if (anc[u][i]) res+=(1&lt;&lt;i),u=anc[u][i]; return res+1;&#125;inline int jump(int u,int depth)&#123; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),u=anc[u][i]; return u;&#125;inline int getmin(int u,int depth)&#123; int res=INF; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),res=min(res,minn[u][i]),u=anc[u][i]; return res;&#125;inline int query(int a,int b)&#123; int da=getdepth(a),db=getdepth(b); if (da&lt;=db) return 0; if (jump(a,da-db)!=b) return 0; return getmin(a,da-db);&#125;inline void update(int a,int b,int c)&#123; anc[a][0]=b;minn[a][0]=c; int A=root[a]; int da=tree[A].sz,db=getdepth(b); //update info if (da&lt;=db) &#123; int curdepth=0; for (register int i=1;i&lt;=da;i++) &#123; while ((1&lt;&lt;curdepth)&lt;i) curdepth++; List cur=tree[A].getind(i); for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=i-1+db;j++) for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; else &#123; int curdepth=0; for (register int i=db;i&gt;=1;i--) &#123; while ((1&lt;&lt;curdepth)&lt;(db-i+1)) curdepth++; for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=da-1+(db-i+1);j++) &#123; List cur=tree[A].getind((1&lt;&lt;j)-(db-i+1)+1); for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; &#125; //merge int Root=root[jump(b,db-1)],dep=tree[Root].sz; if (da&lt;=db) &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[Root].getind(i); List need=join(tree[A].getind(j),cur); tree[Root].modify(i,need); &#125; for (register int i=dep-db+1;i&lt;=da;i++) tree[Root].pb(tree[A].getind(i)); tree[A].clear(); &#125; else &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[A].getind(j); List need=join(cur,tree[Root].getind(i)); tree[A].modify(j,need); &#125; for (register int i=db+da+1;i&lt;=dep;i++) tree[A].pb(tree[Root].getind(i)); for (register int i=db;i&gt;=1;i--) tree[A].pf(tree[Root].getind(i)); tree[Root].clear();root[jump(b,db-1)]=A; &#125;&#125;int lastans=0;inline int getreal(int x) &#123;return (x+lastans)%n+1;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("money.in","r",stdin); freopen ("money.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m); init();int op,a,b,c; while (m--) &#123; io.Get(op);io.Get(a);io.Get(b); a=getreal(a);b=getreal(b); if (!op) io.Get(c),c=getreal(c); if (!op) update(a,b,c); else &#123; lastans=query(a,b); printf("%d\n",lastans); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>倍增</category>
        <category>启发式合并</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>倍增</tag>
        <tag>启发式合并</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM565DIV1C]UnknownTree 题解]]></title>
    <url>%2Fblog%2Ftcsrm565div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given three int[]s: distancesA, distancesB, and distancesC. Each of these int[]s has exactly N elements. We are interested in trees that satisfy the following conditions: The tree has exactly N + 3 vertices. Each vertex has a different label. The set of all labels is { A, B, C, 0, 1, …, N-1 }. Each edge of the tree has a positive integer length. For each i (0 &lt;= i &lt; N), the distance between the vertex A and the vertex i is distancesA[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex B and the vertex i is distancesB[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex C and the vertex i is distancesC[i]. Find the number of trees that satisfy all of the conditions above, and return the number modulo 1,000,000,009. DefinitionClass: UnknownTree Method: getCount Parameters: int[], int[], int[] Returns: int Method signature: int getCount(int[] distancesA, int[] distancesB, int[] distancesC) (be sure your method is public) Notes The distance between two vertices s and t is defined as the sum of lengths of all edges on the only simple path between s and t. Two trees T1 and T2 are different when T1 has an edge u-v such that in T2 the edge u-v is either not present at all, or it has a different length than the edge u-v in T1. Constraints distancesA, distancesB, and distancesC will contain the same number of elements. distancesA, distancesB, and distancesC will contain between 1 and 50 elements, inclusive. Each element of distancesA, distancesB, and distancesC will be between 1 and 100,000,000, inclusive. Examples0) {1} {2} {3} Returns: 6 1) {1, 2} {1, 2} {1, 2} Returns: 1 2) {5, 4} {3, 2} {2, 1} Returns: 8 3) {2, 4, 2} {1, 3, 3} {4, 6, 4} Returns: 2 4) {4, 6, 1, 5, 3, 2, 5} {4, 2, 3, 1, 3, 2, 1} {5, 7, 2, 6, 4, 3, 6} Returns: 12 5) {6, 4, 5, 6, 8, 1, 5, 6, 4, 2} {4, 2, 3, 4, 6, 1, 3, 4, 2, 2} {6, 4, 5, 6, 8, 3, 5, 6, 4, 4} Returns: 9000 6) {8, 5, 6, 8, 6, 5, 6, 10, 8, 5, 10, 8, 7, 9, 7, 1, 11, 5, 9, 6, 6, 1, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 5, 3, 3, 4, 8, 6, 6, 8, 8, 9, 7, 5} {9, 6, 7, 9, 7, 6, 7, 11, 9, 6, 11, 9, 8, 10, 8, 2, 12, 6, 10, 7, 7, 4, 7, 10, 9, 5, 13, 8, 6, 8, 7, 9, 13, 9, 7, 7, 6, 9, 6, 4, 4, 5, 9, 7, 7, 9, 9, 10, 8, 6} {8, 9, 6, 8, 2, 5, 6, 10, 8, 5, 10, 8, 7, 9, 1, 5, 11, 5, 9, 6, 6, 7, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 1, 7, 3, 4, 8, 6, 6, 8, 8, 3, 7, 5} Returns: 770724166 7) {33030780, 30296205, 16842859, 28857842, 37928939, 27190807, 48689043, 33328845, 24254103, 3962046,31043603, 25699520, 11297547, 27045586, 31603483, 23207518, 44089781, 48470539, 52366295, 39786470,45623279, 21593844, 38639305, 27260993, 43899542, 36162768, 21640232, 43580853, 33826577, 30501815,51470990, 2157904, 27823597, 9550575, 39234641, 24163007, 34155133, 42504989, 35821444, 36054200,29026389, 29716374, 41764139, 19392309, 44258194, 19987908, 56722905, 46771885, 32668277, 40665175} {16191697, 13457122, 3776, 12018759, 21089856, 10351724, 31849960, 16489762, 7415020, 12877037,14204520, 8860437, 9035480, 10206503, 14764400, 6368435, 27250698, 31631456, 35527212, 22947387,28784196, 4754761, 21800222, 10421910, 27060459, 19323685, 4801149, 26741770, 16987494, 13662732,34631907, 18996987, 10984514, 7288508, 22395558, 7323924, 17316050, 25665906, 18982361, 19215117,12187306, 12877291, 24925056, 2553226, 27419111, 3148825, 39883822, 29932802, 15829194, 23826092} {19337227, 16602652, 3149306, 15164289, 24235386, 13497254, 34995490, 19635292, 10560550, 16030119,17350050, 12005967, 12188562, 13352033, 17909930, 3215353, 30396228, 34776986, 38672742, 26092917,31929726, 7907843, 24945752, 13567440, 30205989, 22469215, 7946679, 29887300, 20133024, 16808262,37777437, 22150069, 14130044, 10441590, 25541088, 10469454, 20461580, 28811436, 22127891, 22360647,15332836, 16022821, 28070586, 5706308, 30564641, 6294355, 43029352, 33078332, 18974724, 26971622} Returns: 101733071 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution非常好(fan)的分类讨论题 不妨尝试考虑A,B,C三个点在树中的位置关系，发现无外乎两种：Y字型，即三个点在树上有LCA,和链状。 先考虑Y字型，对于一棵树，它可能是Y字型的条件是树上到A,B,C三个点距离之和最小的点是唯一的，这个点就是A,B,C的LCA，设其为root。确定了这个LCA之后，我们就能确定AB,AC,BC三条链的长度：用root-A,root-B,root-C加一加就有。 接下来我们希望找出root-A,root-B,root-C上的所有点，我们可以发现到A和B距离等于AB且到A和C距离等于AC的点在root-A分支上，同理可以确定出root-B和root-C分支，这里要判掉几个不合法的情况：每个点到A/B/C和root都要有距离且同一个分支上的两个点到root的距离必须不同,每个点最多只能存在于一个分支上。 最后我们要确定这个“电风扇”下面挂的点有多少种方案，我们考虑以A为根把树提起来，尝试为每个不在“电风扇”里的点找父亲，父亲应该满足深度比当前点小且当前点与父亲到A/B/C的距离差相等（这个值实际上是当前点和父亲的边的权值），注意不要漏了A,B,C三个点。 再考虑链状，首先应该枚举中间的关键点是哪一个，这样有三种情况，以A为例，考虑确定AB和AC的长度，以AB为例，如果AB之间有其他点，那么这个点集是到A和到B的距离和最小的点的集合；如果AB之间没有点，那么树上所有的关键点到A和到B的距离差的绝对值应该相等，AC也是同理，这样有12种情况，接下来为每个点确定父亲，过程和上面一样。有些要特判的不合法情况也和上面一样。 在实现上，为了简便，可以把Y型的A,B,C分别与root匹配形成三组两个点的情况解决，链状可以把B和C分别和A匹配形成两组两个点的情况，从而节省代码量。 这题主要难在以下几点： 判断每个分支上有哪些点，要能发现距离和，距离差的性质 对不合法情况的特判比较繁琐 对于每个点找到合法父亲的个数，直接累乘就是方案数，这些方案确实都是合法的，但是一下子就看出来可以直接这样计算并不容易。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+9;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;bool visited[148];int distA[148],distB[148],distC[148],n;inline bool cmpA(int x,int y) &#123;return distA[x]&lt;distA[y];&#125;inline bool cmpB(int x,int y) &#123;return distB[x]&lt;distB[y];&#125;inline bool cmpC(int x,int y) &#123;return distC[x]&lt;distC[y];&#125;class UnknownTree&#123; inline bool equ(int x,int y,int z) &#123;return x==y &amp;&amp; x==z;&#125; inline int Y() &#123; int minn=INF,root=-1; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]&lt;minn) minn=distA[i]+distB[i]+distC[i]; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]==minn) &#123;if (root==-1) root=i; else return 0;&#125; int AB=distA[root]+distB[root],AC=distA[root]+distC[root],BC=distB[root]+distC[root]; memset(visited,false,sizeof(visited));visited[root]=true; vector&lt;int&gt; ptA,ptB,ptC;ptA.clear();ptB.clear();ptC.clear(); for (register int i=1;i&lt;=n;i++) &#123; if (i==root) continue; if (distA[i]+distB[i]==AB &amp;&amp; distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distA[i]&gt;=distA[root]) return 0; ptA.pb(i);visited[i]=true; &#125; if (distA[i]+distB[i]==AB &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distB[i]&gt;=distB[root]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distC[i]&gt;=distC[root]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptA.begin(),ptA.end(),cmpA); sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptA.size())-1;i++) if (distA[ptA[i]]==distA[ptA[i+1]]) return 0; for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-BC)) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-BC)) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int calc(int AB,int AC) &#123; if (!AB || !AC) return 0; vector&lt;int&gt; ptB,ptC;ptB.clear();ptC.clear(); memset(visited,false,sizeof(visited)); for (register int i=1;i&lt;=n;i++) &#123; if (distA[i]+distB[i]==AB) &#123; if (visited[i]) return 0; if (distC[i]!=AC+distA[i]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distB[i]!=AB+distA[i]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-(AB+AC))) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-(AB+AC))) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int Line(vector&lt;int&gt; B,vector&lt;int&gt; A,vector&lt;int&gt; C) &#123; for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; vector&lt;int&gt; AB,AC;AB.clear();AC.clear(); int maxn=-INF,minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distB[i])),minn=min(minn,myabs(distA[i]-distB[i])); if (maxn==minn) AB.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distB[i]); AB.pb(minn); maxn=-INF;minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distC[i])),minn=min(minn,myabs(distA[i]-distC[i])); if (maxn==minn) AC.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distC[i]); AC.pb(minn); int res=0; for (auto d1 : AB) for (auto d2 : AC) Add(res,calc(d1,d2)); return res; &#125; public: inline int getCount(vector&lt;int&gt; A,vector&lt;int&gt; B,vector&lt;int&gt; C) &#123; n=int(A.size()); for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; return add(add(add(Y()+Line(B,A,C))+Line(A,B,C))+Line(A,C,B)); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;int&gt; aa,bb,cc;int nn; UnknownTree A; while (cin&gt;&gt;nn) &#123; aa.clear();bb.clear();cc.clear();int x; for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,aa.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,bb.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,cc.pb(x); cout&lt;&lt;A.getcount(aa,bb,cc)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>思维</category>
        <category>分类讨论题</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>TopCoder</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #228][六校联合训练 #8]地理课 题解]]></title>
    <url>%2Fblog%2Fnflsoj228%2F</url>
    <content type="text"><![CDATA[Description地理课上，老师给出了一个巨大的地图，由于世界日新月异，会有一些道路在某一时刻被删除，也会有一些道路在某一时刻被修建。这里的道路均为双向的。 老师认为，有一些城市被分在了一个连通块中可以相互到达，而有一些城市不能够相互到达。而他想知道，每个时刻所有连通块大小的乘积是多少？ wzy看到这个地图的时候就蒙了，还好那只上天的喵及时帮助了他。现在他把这个毒瘤的地图拿过来给你，想试试看你能不能求出来。由于答案可能很大，输出乘积mod 1e9+7即可。 Input Format第一行两个数n,m，表示有n个点，m个时刻。接下来mm行每行三个数，要么是1 u v，要么是2 u v，分别表示添加一条无向边和删除一条无向边。 Output Format共m行，每行一个数表示连通块大小乘积mod 1,000,000,007。 Sample Input5 6 1 1 3 1 2 3 1 1 2 1 4 5 1 3 4 2 3 4 Sample Output2 3 3 6 5 6 上面是每个时刻操作后的图。乘积分别为：2×1×1×1=2，3×1×1=3，3×1×1=3，3×2=6，5，3×2=6. Constraints subtask1: 30pts，n≤1,000, m≤2,000n≤1,000, m≤2,000. subtask2: 20pts，满足没有删除操作。 subtask3: 50pts，n,m≤100,000,n,m≤100,000. 保证没有重边自环，不会删除不存在的边。 时间限制2s，空间限制512MB Solution考虑离线做法，对于每条边我们都能确定它存在的时间区间，然后我们在线段树的对应区间上加上这条边 加完之后我们对线段树做dfs,每遍历一个节点，就将这个点上的所有边连到DSU里面，然后向左右继续搜索，这样我们可以确定当我们搜索到叶子时，所有覆盖了这个时刻的边都被加入了DSU，于是可以快速算出答案；在离开一个节点的时候，我们要把这个节点加入的边删掉，于是我们要写一个可撤销的DSU 线段树上所有节点的边数之和是$nlogn$级别，因为要支持撤销，所以DSU中没有路径压缩，只有启发式合并，find_anc也要一个$log$，所以时间复杂度为$O(nlog^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;int fans[MAXN+48];int ans=1;int inv[MAXN+48];inline void init_inv()&#123; inv[0]=inv[1]=1; for (register int i=2;i&lt;=n;i++) inv[i]=MOD-1ll*(MOD/i)*inv[MOD%i]%MOD;&#125;namespace DSU&#123; int pre[MAXN+48],sz[MAXN+48]; int ptx[MAXN*20+48],pty[MAXN*20+48],szx[MAXN*20+48],szy[MAXN*20+48],tot; inline void init() &#123;tot=0;for (register int i=1;i&lt;=n;i++) pre[i]=i,sz[i]=1;&#125; inline int find_anc(int x) &#123;if (pre[x]==x) return x; return find_anc(pre[x]);&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123; x=find_anc(x);y=find_anc(y); if (sz[x]&gt;sz[y]) swap(x,y); ++tot;ptx[tot]=x;pty[tot]=y;szx[tot]=sz[x];szy[tot]=sz[y]; ans=1ll*ans*inv[sz[x]]%MOD;ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=y;sz[y]+=sz[x]; ans=1ll*ans*sz[y]%MOD; &#125; inline void undo() &#123; int x=ptx[tot],y=pty[tot]; ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=x;sz[x]=szx[tot];sz[y]=szy[tot];tot--; ans=1ll*ans*sz[x]%MOD;ans=1ll*ans*sz[y]%MOD; &#125;&#125;namespace SegmentTree&#123; vector&lt;Pair&gt; edge[MAXN*4+48]; inline void init() &#123;for (register int i=1;i&lt;=MAXN*4;i++) edge[i].clear();&#125; inline void update(int cur,int left,int right,Pair curedge,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;edge[cur].pb(curedge);return;&#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,curedge,l,mid); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,curedge,mid+1,r); &#125; inline void dfs(int cur,int l,int r) &#123; int cnt=0; for (register int i=0;i&lt;int(edge[cur].size());i++) if (!DSU::issame(edge[cur][i].x,edge[cur][i].y)) &#123; cnt++; DSU::update(edge[cur][i].x,edge[cur][i].y); &#125; if (l==r) fans[l]=ans; else &#123; int mid=(l+r)&gt;&gt;1; dfs(cur&lt;&lt;1,l,mid);dfs(cur&lt;&lt;1|1,mid+1,r); &#125; while (cnt--) DSU::undo(); &#125;&#125;map&lt;Pair,int&gt; Mp;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int op,x,y; SegmentTree::init();DSU::init();Mp.clear();init_inv(); for (register int i=1;i&lt;=m;i++) &#123; io.Get(op);io.Get(x);io.Get(y); assert(x!=y); if (x&gt;y) swap(x,y); if (op==1) Mp[mp(x,y)]=i; else SegmentTree::update(1,Mp[mp(x,y)],i-1,mp(x,y),1,m),Mp[mp(x,y)]=0; &#125; for (map&lt;Pair,int&gt;::iterator iter=Mp.begin();iter!=Mp.end();iter++) if (iter-&gt;y) SegmentTree::update(1,iter-&gt;y,m,iter-&gt;x,1,m); SegmentTree::dfs(1,1,m); for (register int i=1;i&lt;=m;i++) io.Print(fans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>并查集</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Regular Contest 092F]Two Faced Edges 题解]]></title>
    <url>%2Fblog%2Farc092f%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given a directed graph with N vertices and M edges. The vertices are numbered 1,2,…,N, and the edges are numbered 1,2,…,M. Edge i points from Vertex ai to Vertex bi. For each edge, determine whether the reversion of that edge would change the number of the strongly connected components in the graph. Here, the reversion of Edge i means deleting Edge i and then adding a new edge that points from Vertex bi to Vertex ai. Constraints 2≤N≤1000 1≤M≤200,000 1≤ai,bi≤N ai≠bi If i≠j, then ai≠aj or bi≠bj. InputInput is given from Standard Input in the following format: N M a1 b1 a2 b2 : aM bM OutputPrint M lines. In the i-th line, if the reversion of Edge i would change the number of the strongly connected components in the graph, print diff; if it would not, print same. Sample Input 13 3 1 2 1 3 2 3 Sample Output 1same diff same The number of the strongly connected components is 3 without reversion of edges, but it will become 1 if Edge 2 is reversed. Sample Input 22 2 1 2 2 1 Sample Output 2diff diff Reversion of an edge may result in multiple edges in the graph. Sample Input 35 9 3 2 3 1 4 1 4 2 3 5 5 3 3 4 1 2 2 5 Sample Output 3same same same same same diff diff diff diff Solution朴素的做法是$O(m^2)$的，考虑优化到$O(nm)$ 我们发现翻转一条边$u\rightarrow v$后连通块个数是否改变主要取决于两点： $v$能否到$u$ $u$能否不经过$u\rightarrow v$这条边到达$v$ 稍微计算一下可以发现，如果上面两条都不满足，连通块个数减一，满足其一连通块个数不变，都满足连通块个数加一 我们枚举每个端点$u$，考虑$u$的所有出边，$v$能否到$u$这件事情是比较容易判断的，我们只要将所有边反向，从$u$做一遍dfs,能到的所有的点就是原图中能到$u$的点，这个部分是$O(m)$的 $u$能否不经过$u\rightarrow v$到$v$比较麻烦，考虑如下做法： 我们将$u$所有指向的点$v_1,v_2…v_k$找出来，然后从$v_1$出发做dfs,要求不经过$u$，找出所有能到的点，然后依次考察$v_2,v_3…v_k$，如果能从$v_1$到的话说明要求的路径存在 再从$v_2$出发做相同的事情，对$v_3,v_4…v_k$做考察，以此类推。这样做看似是$O(m^2)$的，但是注意到如果我们搜到一个已经搜过的点，是不用向下继续搜的，因为“前人”一定已经继续向下搜过了，所以只要每次的visited数组不清空，所有点的搜索复杂度总和就是$O(m)$的 以上我们只考虑了从编号小的点出发走到编号大的点的情况，所以还要再反过来做一次，考虑从编号大的点走到编号小的点的情况 这样，每个点的一轮的总复杂度是$O(m)$，一共$n$个点，总时间复杂度$O(nm)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1000;const int MAXM=2e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];vector&lt;int&gt; vv[MAXN+48];bool visited1[MAXN+48],visited2[MAXN+48],ok[MAXN+48];int ans[MAXM+48];inline void dfs1(int cur)&#123; visited1[cur]=true; for (register int i=0;i&lt;int(vv[cur].size());i++) &#123; register int y=vv[cur][i]; if (!visited1[y]) dfs1(y); &#125;&#125;inline void dfs2(int cur)&#123; visited2[cur]=true; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; register int y=v[cur][i].x; if (!visited2[y]) dfs2(y); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int x,y; for (register int i=1;i&lt;=m;i++) &#123; io.Get(x);io.Get(y); v[x].pb(mp(y,i));vv[y].pb(x); &#125; for (register int i=1;i&lt;=n;i++) &#123; memset(visited1,false,sizeof(visited1)); memset(visited2,false,sizeof(visited2)); memset(ok,false,sizeof(ok)); dfs1(i);visited2[i]=true; for (register int j=0;j&lt;int(v[i].size())-1;j++) &#123; dfs2(v[i][j].x); for (register int k=j+1;k&lt;int(v[i].size());k++) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; memset(visited2,false,sizeof(visited2)); visited2[i]=true; for (register int j=int(v[i].size())-1;j&gt;=1;j--) &#123; dfs2(v[i][j].x); for (register int k=j-1;k&gt;=0;k--) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; for (register int j=0;j&lt;int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]); &#125; for (register int i=1;i&lt;=m;i++) printf(ans[i]?"diff\n":"same\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM337DIV1C]CountPalindromes 题解]]></title>
    <url>%2Fblog%2Ftcsrm337div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementA palindrome is a string that reads the same from left to right as it does from right to left, ignoring spaces. We are building a machine that makes the best palindromes in the world and we need you to make a function that calculates the number of possible results before trying it for the first time. You will be given a String[] words and an int k. Each palindrome generated by the machine will be a single space separated list of words, without leading or trailing spaces, that contains at most k characters (including spaces). Each word is an element of words, and each word can be used zero or more times in each palindrome. Return the number of different palindromes that can be generated by the machine modulo 835454957. DefinitionClass: CountPalindromes Method: count Parameters: String[], int Returns: int Method signature: int count(String[] words, int k) (be sure your method is public) Notes Returning the answer modulo 835454957 means that you have to return the remainder of dividing the answer by 835454957. The empty string does not count as a palindrome. Constraints words will contain between 1 and 50 elements, inclusive. Each element of words will contain between 1 and 15 characters, inclusive. Each character of each element of words will be a lowercase letter (‘a’-‘z’). No two elements of words will be equal. k will be between 1 and 100, inclusive. Examples0) {“tragic”,”cigar”} 24 Returns: 1 The only palindrome with no more than 24 characters is “cigar tragic” with 12 characters. “cigar tragic cigar tragic” is also a valid palindrome, but has 25 characters. 1) {“z”,”zz”} 4 Returns: 5 The 5 different palindromes are (quotes for clarity): “z”,”zz”,”z z”,”z zz”,”zz z”. 2) {“aba”,”acaba”,”baca”,”cac”,”b”,”c”,”a”} 70 Returns: 370786966 Remember to return the answer modulo 835454957. 3) {“hello”} 100 Returns: 0 There is no way to make a palindrome. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution考虑dp 从中间向两边dp:设状态$dp[L][i][j][0/1]$，$L$表示当前构造的字符串长度,$0/1$表示当前是左边多出来一截还是右边多出来一截,$i$表示左/右边的最后一个字符串，$j$表示$i$字符串还剩的前缀最后位置/后缀起始位置，$dp[L][i][j][0/1]$里面存个数 转移的时候，我们只要枚举下一个接什么字符串，如果当前是左边多出来就向右边接，如果当前是右边多出来就向左边接，能否拼接可以预处理一下。 要注意的是为了避免算重，当恰好回文的时候，我们应该把状态固定在左边(或右边)，且应该固定向左边(或右边)加串，例如”zz zz”这个串先加左边再加右边和先加右边再加左边是一样的，不能算作两种 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=835454957;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;class CountPalindromes&#123; int n; char s[148][48];int len[148]; bool table_suf[148][48][148],table_pref[148][48][148]; int dp[148][58][21][2]; inline bool judge_evenpalindrome(int id,int pos) &#123; if (pos&lt;=len[id]-pos) &#123; for (register int i=pos;i&gt;=1;i--) if (s[id][i]!=s[id][pos+pos-i+1]) return false; return true; &#125; else &#123; for (register int i=pos+1;i&lt;=len[id];i++) if (s[id][i]!=s[id][pos-(i-(pos+1))]) return false; return true; &#125; &#125; inline bool judge_oddpalindrome(int id,int pos) &#123; if (pos-1&lt;=len[id]-pos) &#123; for (register int l=1,r=pos+pos-1;l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; else &#123; for (register int l=pos-(len[id]-pos),r=len[id];l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; &#125; public: inline int count(vector&lt;string&gt; words,int lim) &#123; n=int(words.size()); for (register int i=1;i&lt;=n;i++) &#123; for (register int j=0;j&lt;int(words[i-1].size());j++) s[i][j+1]=words[i-1][j]; len[i]=int(words[i-1].size());s[i][len[i]+1]='\0'; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i]+1;j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&lt;=min(len[i],j+len[k]-1);p++) if (s[i][p]!=s[k][len[k]-(p-j)]) &#123;f=false;break;&#125; table_suf[i][j][k]=f; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&gt;=max(1,j-len[k]+1);p--) if (s[i][p]!=s[k][j-p+1]) &#123;f=false;break;&#125; table_pref[i][j][k]=f; &#125; // cerr&lt;&lt;table_pref[1][3][1]&lt;&lt;"@"&lt;&lt;endl; memset(dp,0,sizeof(dp)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_evenpalindrome(i,j)) &#123; if (j&lt;len[i]-j) Add(dp[len[i]][i][j*2+1][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2][0],1); &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_oddpalindrome(i,j)) &#123; if (j-1&lt;len[i]-j) Add(dp[len[i]][i][j*2][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2-1][0],1); &#125; for (register int L=1;L&lt;=lim-1;L++) for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) &#123; if (dp[L][i][j][0]) &#123; if (j==0) &#123; for (register int k=1;k&lt;=n;k++) if (L+len[k]+1&lt;=lim) Add(dp[L+len[k]+1][k][len[k]][0],dp[L][i][j][0]); continue; &#125; for (register int k=1;k&lt;=n;k++) if (table_pref[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (j&gt;=len[k]) Add(dp[L+len[k]+1][i][j-len[k]][0],dp[L][i][j][0]); else Add(dp[L+len[k]+1][k][j+1][1],dp[L][i][j][0]); &#125; &#125; if (dp[L][i][j][1]) for (register int k=1;k&lt;=n;k++) if (table_suf[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (len[i]-j+1&gt;len[k]) Add(dp[L+len[k]+1][i][j+len[k]][1],dp[L][i][j][1]); else Add(dp[L+len[k]+1][k][len[k]-(len[i]-j+1)][0],dp[L][i][j][1]); &#125; &#125; int ans=0; for (register int L=1;L&lt;=lim;L++) for (register int i=1;i&lt;=n;i++) Add(ans,dp[L][i][0][0]); return ans; &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;string&gt; ss;string s;CountPalindrome A;int nn,kk; while (cin&gt;&gt;nn&gt;&gt;kk) &#123; ss.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,ss.pb(s); cout&lt;&lt;A.count(ss,kk)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #228][McfXH AK Contest]比赛 题解]]></title>
    <url>%2Fblog%2Fnflsoj218%2F</url>
    <content type="text"><![CDATA[Problem statement陈太阳非常喜欢打比赛。 最近有 n 个比赛，陈太阳参加第 i 个比赛能获得的快乐值是 ai，他准备选择某些比赛去虐场。 他选择的比赛的快乐值必须满足快乐值不下降，即如果陈太阳参加了第 $i$,$j$ 个比赛，且 $i&lt;j$，则必须有 $a_i\leq a_j$。 陈太阳如果不去打某个比赛他的心里就会难受，并且不打的时间越长他越难受。如果陈太阳选择不打某个比赛，并且他已经在这之前连续选择不打 x 个比赛了，那他就会损失 x+1 的快乐值。 请你计算陈太阳能获得的快乐值的最大值。注意他可以选择不参加所有比赛。 Input第一行一个整数 n。 接下来一行 n 个整数，表示 ai。 Output输出一个整数，表示答案。 Sample Input 17 1 3 2 7 3 2 4 Sample Output 17 Sample Input 27 -3 -4 -2 -2 -6 -8 -1 Sample Output 2-11 Constraints Subtask 11（30 pts）: 1≤n≤5000,1≤n≤5000； Subtask 22（70 pts）: 1≤n≤100000,1≤n≤100000。 Solution如果我们先不考虑不下降子序列的要求，那么这是一个比较显然的dp+斜率优化，推一波式子： $dp[i]$表示以i结尾的最大收益,有状态转移方程:$$dp[i]=a[i]+\max_{j=1}^{i-1}(dp[j]+\frac{(i-j)(i-j-1)}{2})$$ 考虑决策$j$比决策$k$优的条件：$$dp[j]+\frac{(i-j)(i-j-1)}{2}&lt;dp[k]+\frac{(i-k)(i-k-1)}{2}$$ 化简，按照斜率优化的套路移项，我们有$$i&lt;-\frac{(dp[j]-\frac{j(j+1)}{2})-(dp[k]-\frac{k(k+1)}{2})}{j-k}$$ 考虑到$i$是递增的，我们应该把$(j,dp[j]-\frac{j(j+1)}{2})$看做点，用单调队列维护斜率的相反数的一个下凸壳 然而现在还有一个不下降子序列的要求，相当于转移要在一个二维偏序上进行 考虑cdq分治，定义函数$solve(l,r)$表示我们当前正在计算$l$到$r$的dp状态，刚开始我们将数组按照$a[i]$排序，然后我们预处理每个区间的点按照$id$排序的结果$pos$数组，然后先$solve(l,mid)$(注意这里的区间是按照$a[i]$排序的),接着考虑$l$到$mid$对$mid+1$到$r$的贡献,我们按照$pos$数组从$l$到$r$扫描，如果这个点来自$l$就把它加到下凸壳里面，如果这个点来自$r$就在单调队列里面找一个最优决策点，想想可以发现的确是按照二维偏序进行的更新。 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e5;int n;int a[MAXN+48],id[MAXN+48];int pos[21][MAXN+48];bool isleft[MAXN+48];LL dp[MAXN+48];int q[MAXN+48];inline void mergesort(int l,int r,int d)&#123; if (l==r) &#123;pos[d][l]=id[l];return;&#125; int mid=(l+r)&gt;&gt;1; mergesort(l,mid,d+1);mergesort(mid+1,r,d+1); for (register int k1=l,k2=mid+1,pt=l;k1&lt;=mid || k2&lt;=r;pt++) &#123; if (k1&gt;mid) &#123;pos[d][pt]=pos[d+1][k2++];continue;&#125; if (k2&gt;r) &#123;pos[d][pt]=pos[d+1][k1++];continue;&#125; if (pos[d+1][k1]&lt;pos[d+1][k2]) pos[d][pt]=pos[d+1][k1++]; else pos[d][pt]=pos[d+1][k2++]; &#125;&#125;inline double calc(int id1,int id2)&#123; LL x1=id1,x2=id2,y1=-dp[id1]+1ll*id1*(id1+1)/2,y2=-dp[id2]+1ll*id2*(id2+1)/2; return double(y2-y1)/double(x2-x1);&#125;inline void solve(int l,int r,int d)&#123; if (l==r) &#123;dp[pos[d][l]]+=a[pos[d][l]];return;&#125; int mid=(l+r)&gt;&gt;1,head=1,tail=0; solve(l,mid,d+1); for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=true; for (register int i=l;i&lt;=r;i++) &#123; int cur=pos[d][i]; if (isleft[cur]) &#123; while (head&lt;tail &amp;&amp; calc(q[tail-1],q[tail])&gt;=calc(q[tail],cur)) tail--; q[++tail]=cur; &#125; else &#123; while (head&lt;tail &amp;&amp; calc(q[head],q[head+1])&lt;cur) head++; if (head&lt;=tail) check_max(dp[cur],dp[q[head]]-1ll*(cur-q[head]-1)*(cur-q[head])/2); &#125; &#125; for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=false; solve(mid+1,r,d+1);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),id[i]=i; sort(id+1,id+n+1,[&amp;](const int &amp;x,const int &amp;y) &#123;if (a[x]!=a[y]) return a[x]&lt;a[y];return x&lt;y;&#125;); for (register int i=1;i&lt;=n;i++) dp[i]=-1ll*i*(i-1)/2; mergesort(1,n,1);solve(1,n,1); LL ans=-1ll*n*(n+1)/2; for (register int i=1;i&lt;=n;i++) check_max(ans,dp[i]-1ll*(n-i+1)*(n-i)/2); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>斜率优化</category>
        <category>cdq分治</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NFLSoj</tag>
        <tag>斜率优化</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #908G]New Year and Original Order 题解]]></title>
    <url>%2Fblog%2Fcf908g%2F</url>
    <content type="text"><![CDATA[DescriptionLet S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555. Given a number X, compute modulo $10^9 + 7$. InputThe first line of input will contain the integer X ($1$ ≤ $X$ ≤ $10^{700}$). OutputPrint a single integer, the answer to the question. ExamplesInput 21 Output 195 Input 345342 Output 390548434 NoteThe first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. Solution很神的dp题 我们尝试考虑每一位的贡献，也就是要算第i位是j的数有多少个 容易想到一个$O(n^3)$的dp:令$dp[i][j][k][l][cmp]$表示当前考虑到第$i$位，大于等于j的数位有k个，j这个数位有l个，当前数与$n$的大小关系是cmp的情况下有多少种情况，转移只要枚举下一个数是多少即可 这样最后在算答案的时候，把这连续的$l$个$j$统计一下贡献即可 然而这题需要$O(n^2)$的复杂度，考虑优化：我们把上面的dp中$l$的那一维去掉，这样算dp的复杂度是$O(n^2)$的，但你会发现答案不好统计了，因为比如如果你有一串3，中间的那些3无法通过差分得到 于是有这样一个神结论：对于每个$sum=dp[n][j][k][0]+dp[n][j][k][1]$，对答案的贡献是$sum*\underbrace{11…111}_{j个1}$ 下面证这个结论的正确性：我们尝试考虑每个数按数位排好序的那个序列是怎样被计算到的 首先对于最左边的数码$x_1$，显然会有$x_1$个长度为n的dp中会算到这个排列，所以会加$x_1$个$\underbrace{11…111}_{n个1}$，一个很好的性质是，如果有若干个连续的相同数码，在上面的dp中非开头位不会体现在某个状态之中，一起跟着开头的那个数位算掉了 然后我们考虑第二小的数码$x_2$，乍一看感觉它会被算$x_2$次，加上前面的$x_1$次就不对了，但我们注意到$x_2$是比$x_1$大的，所以从不大于$x_1$的数码中对$x_2$这位加的贡献其实都不归当前的这个状态，所以实际上这时$x_2$只被计算了$x_2-x_1$次，加上前面的$x_1$次正好是正确的，以此类推，后面的都是正确的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=700;char s[MAXN+48];int n;int dp[MAXN+48][MAXN+48][10][2],ans[MAXN+48][10];int pw[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); memset(dp,0,sizeof(dp)); for (register int i=0;i&lt;=9;i++) dp[0][0][i][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) for (register int k=0;k&lt;=9;k++) &#123; if (dp[i][j][k][0]) &#123; //to 0 add(dp[i+1][j+(s[i+1]-'0'&gt;=k)][k][0],dp[i][j][k][0]); //to 1 for (register int nxt=0;nxt&lt;=s[i+1]-'0'-1;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][0]); &#125; if (dp[i][j][k][1]) &#123; for (register int nxt=0;nxt&lt;=9;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][1]); &#125; &#125; pw[1]=1; for (register int i=2;i&lt;=n;i++) pw[i]=(1ll*pw[i-1]*10+1)%MOD; int ans=0; for (register int j=0;j&lt;=n;j++) for (register int k=1;k&lt;=9;k++) add(ans,1ll*add(dp[n][j][k][0]+dp[n][j][k][1])*pw[j]%MOD); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1045A]Last Chance 题解]]></title>
    <url>%2Fblog%2Fcf1045a%2F</url>
    <content type="text"><![CDATA[DescriptionIt is the year 2969. 1000 years have passed from the moon landing. Meanwhile, the humanity colonized the Hyperspace™ and lived in harmony. Until we realized that we were not alone. Not too far away from the Earth, the massive fleet of aliens’ spaceships is preparing to attack the Earth. For the first time in a while, the humanity is in real danger. Crisis and panic are everywhere. The scientists from all around the solar system have met and discussed the possible solutions. However, no progress has been made. The Earth’s last hope is YOU! Fortunately, the Earth is equipped with very powerful defense systems made by MDCS. There are N aliens’ spaceships which form the line. The defense system consists of three types of weapons: SQL rockets – every SQL rocket can destroy at most one spaceship in the given set. Cognition beams – every Cognition beam has an interval [l,r]and can destroy at most one spaceship in that interval. OMG bazooka – every OMG bazooka has three possible targets, however, each bazooka can destroy either zero or exactly two spaceships. In addition, due to the smart targeting system, the sets of the three possible targets of any two different OMG bazookas are disjoint (that means that every ship is targeted with at most one OMG bazooka). Your task is to make a plan of the attack which will destroy the largest possible number of spaceships. Every destroyed spaceship should be destroyed with exactly one weapon. InputThe first line contains two integers: the number of your weapons N(1≤N≤5000)and the number of spaceships M(1≤M≤5000). In the next N lines, each line starts with one integer that represents type (either 0, 1 or 2). If the type is 0, then the weapon is SQL rocket, the rest of the line contains strictly positive number K(∑K≤100000) and array ki (1≤ki≤M) of K integers. If the type is 1, then the weapon is Cognition beam, the rest of the line contains integers l and r(1≤l≤r≤M). If the type is 2 then the weapon is OMG bazooka, the rest of the line contains distinct numbers a, b and c (1≤a,b,c≤M). OutputThe first line should contain the maximum number of destroyed spaceships —X. In the next X lines, every line should contain two numbers A and B, where A is an index of the weapon and B is an index of the spaceship which was destroyed by the weapon A. Exampleinput3 50 1 42 5 4 11 1 4 output42 13 21 42 5 NoteSQL rocket can destroy only 4th spaceship. OMG Bazooka can destroy two of 1st, 4th or 5th spaceship, and Cognition beam can destroy any spaceship from the interval [1,4]. The maximum number of destroyed spaceship is 4, and one possible plan is that SQL rocket should destroy 4th spaceship, OMG bazooka should destroy 1st and 5th spaceship and Cognition beam should destroy 2nd spaceship. Solution这题的宗旨是你要相信$1e5$的网络流是能跑的，然后你就真的过了（大雾 网络流的模型还是很显然的，考虑对每种武器建一个点，超级源点向这些点连流量为$1$的边（对于第三种武器，连流量为2的边），每个目标建一个点，这些点向超级汇点连流量为$1$的边 考虑三种武器怎么建： 第一种武器比较简单，从武器点向覆盖的集合连流量为1的边即可 第二种武器是区间，一条一条暴力连肯定会爆炸，考虑用线段树优化建边，我们可以把目标想象成线段树的叶子，然后向上垒出一棵线段树，线段树上的每个点向左右孩子连流量为$INF$的边，然后武器点只要像正常线段树一样查询一波，向所有查询到的区间$(left&lt;=l 且 r&lt;=right)$连边即可，这样点数仍然是$O(m)$的，边数是$O(nlogm)的$ 第三种武器，我们发现很难控制一选就要选两个这个条件，但是我们可以好好利用题目中的性质：任意两个第三种武器的集合是不交的。我们可以发现，只要向武器点连流量为2的边，武器点向对应目标连流量为1的边，不加控制答案就是对的，理由如下： 首先如果这条流量为2的边被流满了，那么它肯定选了两个 如果这条流量为2的边没流，那么它肯定不用选 如果这条流量为2的边流了1，首先可以确定的是，它指向的三个点不可能只有一个被选了，否则因为这个点还能流，所以当前的这个流肯定不是最大流。继而我们发现，我们可以直接把它对应的三个点中，任意一个被其他武器“占领”的点强行占为己有，这样带来的影响是，其他某个武器可能会因此变得无用，但最大流跑出的答案肯定是对的 接下来考虑如何构造答案。根据上面所述，第三种武器是要“抢占”别人的目标的，所以先处理掉。然后我们处理第一种武器，注意如果目标已经被第三种占领了就把这个武器直接扔掉。 第二种武器比较烦，因为比较难从残量网络中直接看出每个武器占用了哪个点，我们只能看出这些武器占领的点的总集合，所以我们换用一个贪心的手法来为每个区间分配一个点：考虑将所有的区间按照左端点从小到大排序，然后我们从左到右枚举每一个目标，这时我们要找出那些区间左端点在这个点左边的可能可行的区间，显然这个集合是单调增的，对于这些区间我们把它扔到按右端点从小到大排序的堆里，每次我们找区间右端点在这个点之右且最靠左的区间来覆盖这个点，这样的贪心策略显然是对的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=5e4;const int MAXM=1e6;int n,m,t,ind;int toid[MAXN+48],tonode[MAXN+48];int L[MAXN+48],R[MAXN+48],type[MAXN+48];bool visited[MAXN+48],chosen[MAXN+48];int head[MAXM+48],cur[MAXM+48],to[MAXM+48],nxt[MAXM+48],f[MAXM+48],tot=1;vector&lt;Pair&gt; ans;int seq[MAXN+48],stot;priority_queue&lt;Pair&gt; q;inline bool cmp_l(int x,int y) &#123;return L[x]&lt;L[y];&#125;inline bool cmp_x(Pair x,Pair y) &#123;return x.y&lt;y.y;&#125;namespace flow&#123; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[MAXM+48],Head,Tail,depth[MAXM+48]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; register int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; return depth[t]!=-1; &#125; inline int dfs(int x,int maxf) &#123; if (!maxf || x==t) return maxf; int minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; if (ans&gt;=maxf) break; &#125; &#125; if (!ans) depth[x]=-1; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;namespace SegmentTree&#123; inline void build(int cur,int left,int right) &#123; if (left==right) &#123; ++ind; toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,n+left,INF); return; &#125; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid);build(cur&lt;&lt;1|1,mid+1,right); ++ind;toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,toid[cur&lt;&lt;1],INF); flow::addedge(ind,toid[cur&lt;&lt;1|1],INF); &#125; inline void update(int cur,int left,int right,int l,int r,int id) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; flow::addedge(id,toid[cur],1); return; &#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,l,mid,id); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,mid+1,r,id); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);ind=n+m; SegmentTree::build(1,1,m);int num,x; for (register int i=1;i&lt;=n;i++) &#123; io.Get(type[i]); switch(type[i]) &#123; case 0: &#123; io.Get(num); for (register int j=1;j&lt;=num;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; case 1: &#123; io.Get(L[i]);io.Get(R[i]); SegmentTree::update(1,L[i],R[i],1,m,i); break; &#125; case 2: &#123; for (register int j=1;j&lt;=3;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; &#125; &#125; t=ind+1; for (register int i=1;i&lt;=n;i++) if (type[i]!=2) flow::addedge(0,i,1); else flow::addedge(0,i,2); for (register int i=1;i&lt;=m;i++) flow::addedge(n+i,t,1); io.Print(flow::dinic(),'\n'); for (register int i=1;i&lt;=m;i++) for (register int j=head[n+i];j;j=nxt[j]) if (to[j]==t) &#123; if (!f[j]) chosen[i]=true; break; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i],cnt=0; if (type[y]==2 &amp;&amp; f[i]&lt;2) &#123; for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; if (cnt&lt;2) for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !visited[to[j]-n] &amp;&amp; chosen[to[j]-n]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==0 &amp;&amp; !f[i]) for (register int j=head[y];j;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; if (!visited[to[j]-n]) visited[to[j]-n]=true,ans.pb(mp(y,to[j]-n)); break; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==1 &amp;&amp; !f[i]) seq[++stot]=y; &#125; sort(seq+1,seq+stot+1,cmp_l);int pt=1; for (register int i=1;i&lt;=m;i++) if (chosen[i] &amp;&amp; !visited[i]) &#123; while (pt&lt;=stot &amp;&amp; L[seq[pt]]&lt;=i) q.push(mp(-R[seq[pt]],seq[pt])),pt++; while (!q.empty() &amp;&amp; -q.top().x&lt;i) q.pop(); assert(!q.empty()); ans.pb(mp(q.top().y,i));q.pop(); &#125; sort(ans.begin(),ans.end(),cmp_x); for (auto y : ans) io.Print(y.x,' '),io.Print(y.y,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>线段树</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2134][Code Festival 2016 Final]Zigzag MST 题解]]></title>
    <url>%2Fblog%2Fatcoder2134%2F</url>
    <content type="text"><![CDATA[Problem StatementWe have a graph with N vertices, numbered 0 through N−1. Edges are yet to be added. We will process Q queries to add edges. In the i-th (1≦i≦Q) query, three integers Ai,Bi and Ci will be given, and we will add infinitely many edges to the graph as follows: The two vertices numbered Ai and Bi will be connected by an edge with a weight of Ci. The two vertices numbered Bi and Ai+1 will be connected by an edge with a weight of Ci+1. The two vertices numbered Ai+1 and Bi+1 will be connected by an edge with a weight of Ci+2. The two vertices numbered Bi+1 and Ai+2 will be connected by an edge with a weight of Ci+3. The two vertices numbered Ai+2 and Bi+2 will be connected by an edge with a weight of Ci+4. The two vertices numbered Bi+2 and Ai+3 will be connected by an edge with a weight of Ci+5. The two vertices numbered Ai+3 and Bi+3 will be connected by an edge with a weight of Ci+6. … Here, consider the indices of the vertices modulo N. For example, the vertice numbered N is the one numbered 0, and the vertice numbered 2N−1 is the one numbered N−1. The figure below shows the first seven edges added when N=16,Ai=7,Bi=14,Ci=1: After processing all the queries, find the total weight of the edges contained in a minimum spanning tree of the graph. Constraints2 ≦ N ≦ 200,000 1 ≦ Q ≦ 200,000 0 ≦ Ai,Bi ≦ N−1 1 ≦ Ci ≦ 1e9 InputThe input is given from Standard Input in the following format: N Q A1 B1 C1 A2 B2 C2 : AQ BQ CQ OutputPrint the total weight of the edges contained in a minimum spanning tree of the graph. Sample Input 17 1 5 2 1 Sample Output 121 The figure below shows the minimum spanning tree of the graph: Note that there can be multiple edges connecting the same pair of vertices. Sample Input 22 1 0 0 1000000000 Sample Output 21000000001 Also note that there can be self-loops. Sample Input 35 3 0 1 10 0 2 10 0 4 10 Sample Output 342 Solution对kruskal算法的灵活运用 我们考虑kruskal算法的精髓，不在于每条边连接的是哪两个点，而在于任意两点之间是否连通 对于每组边，首先我们考虑(Bi,Ai+1),因为(Ai,Bi)的边权比(Bi,Ai+1)小，所以我们一定会先处理(Ai,Bi),如果这条边没加进去，说明Ai和Bi已经连通了，如果这条边加进去了，那么此时Ai和Bi变得连通了，于是我们会发现处理(Bi,Ai+1)时Ai和Bi一定是连通的，所以这是Ai+1这个点我们可以改连到Ai上，把这条边换成(Ai,Ai+1) 依次类推，第二条边(Ai+1,Bi+1),Ai+1,Ai,Bi都是连通的，所以我们可以把Bi+1连到Bi上 最终我们会发现，对于每一组边，我们都是先在Ai和Bi之间连边，然后从Ai和Bi出发顺时针连边，所以我们可以把它拆成三部分：Ai和Bi的横跨边，从Ai出发的链和Bi出发的链 Ai和Bi的横跨边一共只有1e5条，可以不管。对于剩下的链,我们会发现一些很好的性质:如果某一条链当前在连的过程中，发现要连的两个点已经连通了，那么可以立刻停止这条链的连接过程，因为注意到每条链的边权都是公差为2的等差数列，所以已经连起来的那条边属于的链后面的边都会比当前链后面的边的边权小，当前链直接被废掉 因为一共只会向图中连n-1条边，所以直接用堆维护这个过程，复杂度正确 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;int n,m;struct node&#123; int A,B,C; inline void input() &#123;io.Get(A);io.Get(B);io.Get(C);&#125;&#125;a[MAXN+48];inline Pair query(int id,int ti)&#123; if (ti==1) return mp(a[id].A,a[id].B); if ((a[id].A+1)%n==a[id].B &amp;&amp; !(ti&amp;1)) return mp(0,0); if (ti&amp;1) &#123; Pair res=mp(a[id].B+ti/2-1,a[id].B+ti/2); res.x%=n;res.y%=n; return res; &#125; else &#123; Pair res=mp(a[id].A+ti/2-1,a[id].A+ti/2); res.x%=n;res.y%=n; return res; &#125;&#125;namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=0;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;priority_queue&lt;pair&lt;int,pair&lt;Pair,bool&gt; &gt; &gt; q;int main ()&#123; io.Get(n);io.Get(m); for (register int i=1;i&lt;=m;i++) &#123; a[i].input(); q.push(mp(-a[i].C,mp(mp(a[i].A,a[i].B),false))); if (a[i].A+1!=a[i].B) q.push(mp(-a[i].C-1,mp(mp(a[i].A,(a[i].A+1)%n),true))); q.push(mp(-a[i].C-2,mp(mp(a[i].B,(a[i].B+1)%n),true))); &#125; LL ans=0;DSU::init(); for (register int cnt=0;cnt&lt;n-1;) &#123; int len=q.top().x;Pair res=q.top().y.x;bool type=q.top().y.y;q.pop(); if (DSU::issame(res.x,res.y)) continue; cnt++;ans-=len; DSU::update(res.x,res.y); if (type) &#123; res.x=(res.x+1)%n;res.y=(res.y+1)%n; len-=2; q.push(mp(len,mp(res,type))); &#125; &#125; io.Print(ans,'\n'); io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4934][Ceoi2016]kangaroo 题解]]></title>
    <url>%2Fblog%2Fbzoj4934%2F</url>
    <content type="text"><![CDATA[Description有一个园子，里面有n个草丛排成一排，标号1~n，有一个袋鼠，从s出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达t。显然他会跳跃n-1次为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同，具体地，如果他现在在now,他是从prev跳跃一次到达now的，然后他跳跃一次到达next，那么如果prev &lt; now，就必须有now &lt; next，如果now &lt; prev，就必须有next &lt; now。问从s到t的方案数，模1e9+7两个路线不同，当且仅当草丛被访问的顺序不同保证至少有一种方案初始时可以往任意方向跳。 修正下：那么如果prev &lt; now，就必须有next &lt; now,如果now &lt; prev,就必须有now &lt; next Input 一行三个整数，n，s，t 2&lt;=n&lt;=2000 1&lt;=s&lt;=n 1&lt;=t&lt;=n Output一行一个整数，代表答案 Sample Input4 2 3 Sample Output2 Solution最后的序列肯定长成一个不断上下的折线 如果考虑从左到右确定折线，就不免要维护每个数是否已经被选过，无法逃离指数级的算法 考虑把所有的数从小到大往里面放，我们会发现，如果有一个“上扬“的结构，那它的后面肯定不能再接东西了，否则就会形成一个连续三个的”上扬”,从而不符合题意，也就是一个数只能单独成一块，或者连接两个端点“下垂”的块，除非是$S$或$T$才能去形成“上扬”结构 于是dp的思路就很明显了，考虑$dp[i][j]$表示已经将$1～i$扔进了排列，当前形成了$j$个连通块的方案数 考虑$i+1$的方法 单独建一个新连通块,$dp[i][j]\rightarrow dp[i+1][j+1]$ 如果是$S$或$T$，可以选择一个连通块接在它的前面或后面，但要注意除非$S$和$T$等于$n$，$S$不能和$T$在一个联通块中，否则这个图就连不起来了 连接两个连通块，当前有$j$个连通块，所以显然有$j(j-1)$种连法，但要注意$S$所在的连通块前面不能有连通块，所以如果$i+1&gt;=S$要$-=j$，$T$所在的连通块后面不能有连通块，所以如果$i+1&gt;=T$要$-=j$，这样$TS$型连通块会被减两次，所以如果$i+1&gt;=S$且$i+j&gt;=T$要$+1$，还要注意如果$i+1&lt;n$的话$S$不能和$T$连起来，所以还要减一 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=2000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,S,T;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif // io.Get(n);io.Get(S);io.Get(T); scanf("%d%d%d",&amp;n,&amp;S,&amp;T); dp[0][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) if (dp[i][j]) &#123; // cerr&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;dp[i][j]&lt;&lt;endl; //create a new node dp[i+1][j+1]=add(dp[i+1][j+1]+dp[i][j]); //add before a node if (i+1==S) &#123; register int valid=j; if (i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //add after a node if (i+1==T) &#123; register int valid=j; if (i+1&gt;=S &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //connect two nodes if (i+1!=S &amp;&amp; i+1!=T &amp;&amp; j&gt;=2) &#123; register int valid=1ll*j*(j-1)%MOD; if (i+1&gt;=S) valid=sub(valid-(j-1)); //can't connect a node before S if (i+1&gt;=T) valid=sub(valid-(j-1)); //can't connect a node after T if (i+1&gt;=S &amp;&amp; i+1&gt;=T) valid=add(valid+1); //T-S is deleted twice if (i+1&gt;=S &amp;&amp; i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); //S-T is not allowed dp[i+1][j-1]=add(dp[i+1][j-1]+1ll*dp[i][j]*valid%MOD); &#125; &#125; // io.Print(dp[n][1],'\n'); printf("%d\n",dp[n][1]); // io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #992E]Nastya and King-Shamans 题解]]></title>
    <url>%2Fblog%2Fcf992e%2F</url>
    <content type="text"><![CDATA[DescriptionNastya likes reading and even spends whole days in a library sometimes. Today she found a chronicle of Byteland in the library, and it stated that there lived shamans long time ago. It is known that at every moment there was exactly one shaman in Byteland, and there were n shamans in total enumerated with integers from 1 to n in the order they lived. Also, each shaman had a magic power which can now be expressed as an integer. The chronicle includes a list of powers of the n shamans. Also, some shamans can be king-shamans, if they gathered all the power of their predecessors, i.e. their power is exactly the sum of powers of all previous shamans. Nastya is interested in whether there was at least one king-shaman in Byteland. Unfortunately many of the powers are unreadable in the list, so Nastya is doing the following: Initially she supposes some power for each shaman.After that she changes the power of some shaman q times (the shamans can differ) and after that wants to check if there is at least one king-shaman in the list. If yes, she wants to know the index of any king-shaman.Unfortunately the list is too large and Nastya wants you to help her. InputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105). The second line contains n integers a1, …, an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman. After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi. OutputPrint q lines, the i-th of them should contain - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change. If there are multiple king-shamans after each change, print the index of any of them. Examplesinput 2 11 31 2 output -1 input 3 42 2 31 11 22 43 6 output 32-13 input 10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0 output 1-19-14-11 NoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2. In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3. Solution注意到$a[i]=sum[i-1]$的话，那么$sum[i]=2*sum[i-1]$，似乎存在倍增的关系，尝试从这个角度入手 我们对原序列维护线段树，线段树记录区间和&amp;区间最大值,每次单点修改后，我们记录一个初始前缀和cursum，然后在序列中找第一个比cursum大的数a[i]，这个根据我们维护的区间最大值可以线段树二分在log的时间内求出，然后我们验证a[i]是否是king，如果是则结束，否则把cursum更新成sum[i]，从头来过。可以看出因为cursum每次至少乘2，所以最多只会做log(1e9)次，加上每次线段树二分的log，我们可以在$O(nlognlog(1e9))$的时间复杂度解决这个问题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int #define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rlen,wlen; fastio () &#123;rlen=wlen=0;&#125; inline char Getchar() &#123; if (rlen==S) rlen=0,fread(rbuf,1,S,stdin); return rbuf[rlen++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; T res=0;char ch;bool f; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=res; &#125; inline void flush() &#123;fwrite(wbuf,1,wlen,stdout);rlen=0;&#125; inline void Writechar(char ch) &#123; wbuf[wlen++]=ch; if (wlen==S) flush(); &#125; template &lt;class T&gt; inline void Print(T res,char ch) &#123; char s[48];int pt; if (res==0) &#123; pt=1; s[1]='0'; &#125; else &#123; bool f=true;if (res&lt;0) f=false,res=-res; pt=0;while (res) s[++pt]=res%10+'0',res/=10; if (!f) s[++pt]='-'; &#125; while (pt&gt;=1) Writechar(s[pt--]); Writechar(ch); &#125;&#125;io;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct node &#123; int left,right; int maxn;LL sum; &#125;tree[MAXN*4]; inline void pushup(int cur) &#123; tree[cur].maxn=max(tree[cur&lt;&lt;1].maxn,tree[cur&lt;&lt;1|1].maxn); tree[cur].sum=tree[cur&lt;&lt;1].sum+tree[cur&lt;&lt;1|1].sum; &#125; inline void build(int cur,int left,int right) &#123; tree[cur].left=left;tree[cur].right=right; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid); build(cur&lt;&lt;1|1,mid+1,right); pushup(cur); &#125; else &#123; tree[cur].maxn=tree[cur].sum=a[left]; &#125; &#125; inline void update(int cur,int pos,int newval) &#123; if (tree[cur].left==tree[cur].right) &#123; tree[cur].maxn=tree[cur].sum=newval; return; &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (pos&lt;=mid) update(cur&lt;&lt;1,pos,newval); else update(cur&lt;&lt;1|1,pos,newval); pushup(cur); &#125; inline LL querysum(int cur,int left,int right) &#123; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) return tree[cur].sum; LL res=0; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (left&lt;=mid) res+=querysum(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) res+=querysum(cur&lt;&lt;1|1,left,right); return res; &#125; inline int findpos(int cur,int left,int right,LL need) &#123; if (left&gt;right) return -1; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) &#123; if (tree[cur].maxn&lt;need) return -1; if (tree[cur].left==tree[cur].right) return tree[cur].left; if (tree[cur&lt;&lt;1].maxn&gt;=need) return findpos(cur&lt;&lt;1,left,right,need); else return findpos(cur&lt;&lt;1|1,left,right,need); &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; int res=-1; if (left&lt;=mid) res=findpos(cur&lt;&lt;1,left,right,need); if (res!=-1) return res; if (mid+1&lt;=right) res=findpos(cur&lt;&lt;1|1,left,right,need); return res; &#125;&#125;inline int solve()&#123; LL cursum=SegmentTree::querysum(1,1,1);int lastpos=1; if (!cursum) return 1; for (;;) &#123; int pos=SegmentTree::findpos(1,lastpos+1,n,cursum); if (pos==-1) return -1; if (SegmentTree::querysum(1,pos,pos)==SegmentTree::querysum(1,1,pos-1)) return pos; cursum=SegmentTree::querysum(1,1,pos); lastpos=pos; &#125;&#125;int main ()&#123; io.Get(n);io.Get(q); for (register int i=1;i&lt;=n;i++) io.Get(a[i]); SegmentTree::build(1,1,n); while (q--) &#123; register int pos,x; io.Get(pos);io.Get(x); SegmentTree::update(1,pos,x); io.Print(solve(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>倍增</category>
        <category>线段树二分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6405][2018ACM多校]Make ZYB Happy 题解]]></title>
    <url>%2Fblog%2Fhdu6405%2F</url>
    <content type="text"><![CDATA[DescriptionIt’s known to all that ZYB is godlike, so obviously he has a large number of titles, such as jsking, bijingzyb and nbazyb. ZYB likes his titles very much. Each of ZYB’s titles is a string consisting of lower case letters ‘a’-‘z’ associated with a happiness value hi, which shows how much ZYB likes this title. If you say any substring of some title with happiness value x, he will get x happiness points. Moreover, a string may appear in more than one title. In this case, the happiness points ZYB gets are multiplied. If the string you say is not the substring of any of his titles, he gets no happiness point. For example, let’s say ZYB has two titles: zybnb (with happiness value 3) and ybyb (with happiness value 5). If you say y, b or yb, ZYB will get 15 happiness points; if you say z, zy or zyb, ZYB will only get 3 happiness points; if you say ybz or ybac he will get 0 happiness points. One day, you find ZYB pretty sad. As a big fan of ZYB, you want to say a word to ZYB to cheer him up. However, ZYB is really busy, so you can only say no more than m letters. As you haven’t seen ZYB for a long time, you are so excited that you forget what you want to say, so you decide to choose to say a nonempty string no longer than m and only containing ‘a’-‘z’ with equal probability. You want to know the expectations of happiness points you will bring to ZYB for different m. InputThe first line contains an integer n (1≤n≤104), the number of titles ZYB has. The i-th of the next n lines contains a nonempty string ti, which only contains lower case letters ‘a’-‘z’, representing the i-th title. The sum of lengths of all titles does not exceed 3×105. Then follows a line with n integers hi (1≤hi≤106), the happiness value of i-th title. The next line is a single integer Q (1≤Q≤3×105), the number of queries. For the next Q lines, each contains a single integer m (1≤m≤106), meaning that you can say no more than m letters to ZYB. The input data contains only one test case. OutputFor each query, display a single line of integer, representing the answer. It can be proved that the answer can be uniquely written as p/q where p and q are non-negative integers with gcd(p,q)=gcd(q,109+7)=1, and you should display p*q−1mod(109+7), where q−1 means the multiplicative inverse of q modulo 109+7. Sample Input2zybnbybyb3 541234 Sample Output769230776425925929891125950633120399 HintFor the first query, you can bring him 3 happiness points if you say “z” or “n”, and 15 happiness points if you say “y” or “b”; all other strings of length 1 bring no happiness point to ZYB. Therefore, the expectation is (2×3+2×15)/26 = 18/13, and the answer is 18×13^(-1) mod (10^9+7) = 769230776. Source2018 Multi-University Training Contest 8 Solution学习了一下广义后缀自动机 广义后缀自动机其实和普通后缀自动机一模一样，可以把它看做在trie上建立的SAM,实现上只要先建好一个串的SAM,然后后面的串把last置成root再来就可以了，中间不需要任何改动 首先对所有的串建立广义SAM,然后考虑题目的需求，对于广义SAM的每个节点，我们需要计算有多少个串包含它，然后把它们的happy值做累乘，这个的话，只要抓着每个串到SAM里面跑一遍，每跑到一个状态就同时顺着parent树更新所有的祖先，为了保证复杂度，每个节点记一个visited，如果已经被访问过了，那么它的祖先们肯定也都被访问过了，所以可以终止向上，这样保证每个点最多被访问一次，使得复杂度是$O(\sum len)$的 求出每个节点的累乘值后，考虑到每个节点所代表的子串长度都是在$min[i]$到$max[i]$范围内的，所以可以用一个差分数组来维护权值，具体来说，$sum[min[i]]+=\Pi_{happy},sum[max[i]+1]-=\Pi_{happy}$即可，这个数组做一遍前缀和就可以得到对于每种长度，所有可能子串的权值和 最后还要除以每种长度的子串个数，注意到子串是完全随机的，所以总个数显然是$26^{len}$,于是这题就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void getstring(string &amp;s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) s+=string(1,ch); &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=4e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int n,q;string s[MAXN+48];int h[MAXN+48];int sum[MAXN+48],ans[MAXN+48],maxlen;namespace SAM&#123; const int MAXN=1e6; int maxn[MAXN+48],nxt[MAXN+48][27],par[MAXN+48],h[MAXN+48],visited[MAXN+48],root,last,tot; inline void init() &#123;root=last=tot=1;&#125; inline void extend(char ch) &#123; int w=ch-'a'+1,p=last,np=++tot;maxn[np]=maxn[p]+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=++tot;maxn[nq]=maxn[p]+1; memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[q]=par[np]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline void insert(string s) &#123; last=root;int len=int(s.size()); for (register int i=0;i&lt;=len-1;i++) extend(s[i]); &#125; inline void go(string s,int ind,int val) &#123; int pos=root,len=int(s.size()); for (register int i=0;i&lt;len;i++) &#123; pos=nxt[pos][s[i]-'a'+1];int tmp=pos; while (tmp &amp;&amp; visited[tmp]!=ind) &#123; visited[tmp]=ind; //带着编号进去就不用清空visited if (!h[tmp]) h[tmp]=val; else h[tmp]=(1ll*h[tmp]*val)%MOD; tmp=par[tmp]; &#125; &#125; &#125;&#125;int main ()&#123; int i,qlen;io.Get(n);SAM::init(); for (i=1;i&lt;=n;i++) &#123; io.getstring(s[i]); SAM::insert(s[i]); maxlen=max(maxlen,int(s[i].size())); &#125; for (i=1;i&lt;=n;i++) io.Get(h[i]); for (i=1;i&lt;=n;i++) SAM::go(s[i],i,h[i]); for (i=2;i&lt;=SAM::tot;i++) &#123; int L=SAM::maxn[SAM::par[i]]+1,R=SAM::maxn[i]; sum[L]=add(sum[L]+SAM::h[i]);sum[R+1]=sub(sum[R+1]-SAM::h[i]); &#125; int ss=0,cur=1,vv=0; for (i=1;i&lt;=maxlen;i++) &#123; cur=(1ll*cur*26)%MOD; ss=add(ss+cur); sum[i]=add(sum[i]+sum[i-1]); vv=add(vv+sum[i]); ans[i]=1ll*vv*quick_pow(ss,MOD-2)%MOD; &#125; io.Get(q); while (q--) &#123; io.Get(qlen); qlen=min(qlen,maxlen); //注意一下这个细节 io.Print(ans[qlen],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>字符串</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6428][2018ACM多校]Calculate 题解]]></title>
    <url>%2Fblog%2Fhdu6428%2F</url>
    <content type="text"><![CDATA[DescriptionGiven A, B, C, Calculate $$ \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3)) (mod 2^{30}) $$ Where $\phi (n)$ denotes the number of positive integers ≤ n that are relatively prime to n. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there are three integers A, B, C in one line, as described above. 1 ≤ T ≤ 10, 0 &lt; A, B, C ≤ 10^7 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 2^30. Sample Input496 93 95970 906 89392460 95043 542459760979 8053227 7156842 Sample Output111453628070648388873924623507672 Source2018 Multi-University Training Contest 10 Solution考虑莫比乌斯反演 \begin{split}ans &amp;= \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3))\ &amp;= \sum_{d=1}^A\phi (d)\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=d]\end{split} 令$f(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=n]$ 令$F(n)=\sum_{n\mid d}f(d)$ $gcd(i,j^2,k^3)$是$n$的倍数等价于$i$,$j^2$,$k^3$都是$n$的倍数，所以 $$F(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{d\mid i,d\mid j^2,d\mid k^3} 1$$ 考虑$x\mid y^k$的充要条件，设$x=\Pi_ip_i^{a_i}$,则应满足$\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil} \mid y$ 令$f_k(x)=\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil}$,则 $$F(n)=\left \lfloor \frac{A}{f_1(n)}\right \rfloor \left\lfloor \frac{B}{f_2(n)}\right\rfloor \left\lfloor \frac{C}{f_3(n)} \right\rfloor $$ 根据莫比乌斯反演 $$f(n)=\sum_{n\mid d}F(d)\mu (\frac{d}{n})=\sum_{n\mid d}\left \lfloor \frac{A}{f_1(d)}\right \rfloor \left\lfloor \frac{B}{f_2(d)}\right\rfloor \left\lfloor \frac{C}{f_3(d)} \right\rfloor \mu (\frac{d}{n})$$ 将此式带回$ans$式,有 $$ans=\sum_{d=1}^A\phi (d)f(d)=\sum_{d=1}^A\phi (d)\sum_{d\mid t}\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \mu (\frac{t}{d})$$ 发现$\mu$和$\phi$很像卷积的关系，所以转而枚举$t$,我们有 \begin{split}ans &amp;=\sum_{t=1}^A\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \sum_{d\mid t}\phi (d)\mu (\frac{t}{d})&amp;=\sum_{t=1}^A(\phi \ast \mu)(t)\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor\end{split} 现在只要线性筛出$f_k(n)$和$(\phi \ast \mu)(n)$,$f_k(n)$是积性函数比较显然,对于$(\phi \ast \mu)(n)$是积性函数，下面给出一个简短的证明:证明：考虑$(\phi \ast \mu)(a)和(\phi \ast \mu)(b)$,其中$a$,$b$互质&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(\phi \ast \mu)(a)$可以写成$\sum \phi(x)\mu(y)[xy=a]$的形式，同理$(\phi \ast \mu)(b)$可以写成$\sum \phi(X)\mu(Y)[XY=b]$的形式&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 考虑$(\phi \ast \mu)(a)$和$(\phi \ast \mu)(b)$相乘，拆开括号后，每一项应该都是$\phi(x)\mu(y)\phi(X)\mu(Y)的形式$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为$(a,b)=1$,所以$(x,X)=1,(y,Y)=1$,因为$\phi$和$\mu$都是积性函数，所以上式可以写成$\phi(xX)\mu(yY)$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 注意到$xXyY=ab$,因为$xy$遍历了$a$的所有拆分,$XY$遍历了$b$的所有拆分，所以$xX$和$yY$必然也遍历了$ab$的所有拆分，又因为$(a,b)=1$,所以所有的$xX$必然互不相同,同时所有的$yY$也互不相同&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 所以，当$(a,b)=1$时,$(\phi \ast \mu)(ab)=(\phi \ast \mu)(a)(\phi \ast \mu)(b)$,$(\phi \ast \mu)(n)$是积性函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Q.E.D.$ $f_1(n)$不用筛，我们注意到线性筛有一个非常好的性质，每个数都是被它最小的质因数筛去的，举一个例子，如果有一个数是$2^2\cdot 3^2\cdot 5$,那筛掉它的一定是$2$,剩下的是$2\cdot 3^2\cdot 5$,而$2\cdot 3^2\cdot 5$又是被$2$筛掉的,剩下的是$3^2\cdot 5$…依次类推，我们会发现一个数的相同质因数总是会在一起，所以如果我们对每一个数记录一个$cnt$表示筛掉它的质数现在有几个，在$i%prime[j]==0$的环节$cnt$累加,否则$cnt$置为$1$,然后判断一下$cnt%k$是否为1就能维护$f_k(n)$,具体细节可以看看代码 对于$(\phi \ast \mu)(n)$,首先当n是质数的时候,$(\phi \ast \mu)(n)=\phi (n)\mu (1)+\phi(1) \mu(n)=n-2$,进而当$n=p^k$,其中$p$是质数时,$(\phi \ast \mu)(n)=(\phi \ast \mu)(p^k)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)+\phi(p^{k-2})\mu(p^2)+…+\phi(p)\mu(p^{k-1})+\phi(1)\mu(p^k)$, 根据莫比乌斯函数的定义,后面的$p$的次数大于等于二的项都是0,所以$(\phi \ast \mu)(n)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)=(p^k-p^{k-1})\cdot 1+(p^{k-1}-p^{k-2})\cdot (-1)=p^k-2\cdot p^{k-1}+p^{k-2}$根据这个就足够进行线性筛了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e7;bool isprime[MAXN+48];int prime[MAXN+48],tot;int phi[MAXN+48],mu[MAXN+48],mup[MAXN+48],f2[MAXN+48],f3[MAXN+48];int cnt[MAXN+48],pw[MAXN+48];inline void init()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=mu[1]=mup[1]=f2[1]=f3[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) &#123; prime[++tot]=i; phi[i]=i-1;mu[i]=-1;mup[i]=i-2; f2[i]=f3[i]=i;cnt[i]=1;pw[i]=i; &#125; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]!=0) &#123; phi[i*prime[j]]=phi[i]*(prime[j]-1); mu[i*prime[j]]=-mu[i]; mup[i*prime[j]]=mup[i]*mup[prime[j]]; f2[i*prime[j]]=f2[i]*prime[j]; f3[i*prime[j]]=f3[i]*prime[j]; cnt[i*prime[j]]=1;pw[i*prime[j]]=prime[j]; &#125; else &#123; phi[i*prime[j]]=phi[i]*prime[j]; mu[i*prime[j]]=0;cnt[i*prime[j]]=cnt[i]+1;pw[i*prime[j]]=pw[i]*prime[j]; mup[i*prime[j]]=mup[i/pw[i]]*(pw[i*prime[j]]-2*pw[i*prime[j]]/prime[j]+pw[i*prime[j]]/prime[j]/prime[j]); f2[i*prime[j]]=f2[i]*((cnt[i*prime[j]]%2==1)?prime[j]:1); f3[i*prime[j]]=f3[i]*((cnt[i*prime[j]]%3==1)?prime[j]:1); break; &#125; &#125; &#125;&#125;uint A,B,C;int main ()&#123; int ca;io.Get(ca);init(); while (ca--) &#123; io.Get(A);io.Get(B);io.Get(C); uint ans=0; for (register int i=1;i&lt;=A;i++) ans+=(A/i)*(B/f2[i])*(C/f3[i])*mup[i]; io.Print(ans&amp;((1&lt;&lt;30)-1),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6437][2018ACM多校]Videos 题解]]></title>
    <url>%2Fblog%2Fhdu6437%2F</url>
    <content type="text"><![CDATA[DescriptionC-bacteria takes charge of two kinds of videos: ’The Collection of Silly Games’ and ’The Collection of Horrible Games’. For simplicity’s sake, they will be called as videoA and videoB. There are some people who want to watch videos during today, and they will be happy after watching videos of C-bacteria. There are n hours a day, m videos are going to be show, and the number of people is K. Every video has a type(videoA or videoB), a running time, and the degree of happi- ness after someone watching whole of it. People can watch videos continuous(If one video is running on 2pm to 3pm and another is 3pm to 5pm, people can watch both of them). But each video only allows one person for watching. For a single person, it’s better to watch two kinds to videos alternately, or he will lose W happiness. For example, if the order of video is ’videoA, videoB, videoA, videoB, …’ or ’B, A, B, A, B, …’, he won’t lose happiness; But if the order of video is ’A, B, B, B, A, B, A, A’, he will lose 3W happiness. Now you have to help people to maximization the sum of the degree of happiness. InputMultiple query. On the first line, there is a positive integer T, which describe the number of data. Next there are T groups of data. for each group, the first line have four positive integers n, m, K, W : n hours a day, m videos, K people, lose W happiness when watching same videos).and then, the next m line will describe m videos, four positive integers each line S, T, w, op : video is the begin at S and end at T, the happiness that people can get is w, and op describe it’s tpye(op=0 for videoA and op=1 for videoB). There is a blank line before each groups of data. T&lt;=20, n&lt;=200, m&lt;=200, K&lt;=200, W&lt;=20, 1&lt;=S&lt;T&lt;=n, W&lt;=w&lt;=1000,op=0 or op=1 OutputYour output should include T lines, for each line, output the maximum happiness for the corresponding datum. Sample Input210 3 1 101 5 1000 05 10 1000 13 9 10 010 3 1 101 5 1000 05 10 1000 03 9 10 0 Sample Output20001990 Source2018 Multi-University Training Contest 10 Solution这题一眼网络流 我们可以对每个时刻建点，给每个点一个编号(A/B,1~n)表示上一个看的电影是A/B,当前是第i个小时，把人想象成流量 首先，一个人可以在某一个时刻什么也不干，所以(A,i)应该向(A,i+1)连一条流量为INF,费用为0的边，(B,i)应该向(B,i+1)连一条流量为INF，费用为0的边 每一步电影可以看做一条边，如果是A类型的电影，时刻从a到b,那么(A,a)应该向(B,b)连一条流量为1，费用为val的边，如果是B类型的电影，时刻从a到b,那么(B,a)应该向(A,b)连一条流量为1，费用为val的边，可以看出，这样连边如果看的电影类型交替是没有额外花费的 如果连续看同样的电影会有w的代价，所以(A,i)应该向(B,i)连一条流量为INF,费用为-w的边，同时(B,i)应该向(A,i)连一条流量为INF,费用为-w的边 最后设置源点和汇点，s向(A,1)和(B,1)连流量为INF,费用为0的边，(A,n)和(B,n)向t连流量为INF，费用为0的边 最后只要跑流量为k的最小费用流即可，最后要把答案取反 因为一开始就有负权边，所以有两种解决方案： 先跑一遍spfa，再跑带势的dijkstra 先把负权边流满，重新构图再跑费用流 考场上懒直接按1做了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=1e8;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=10000;int n,m,k,w;namespace flow&#123; int head[200048],nxt[200048],to[200048],f[200048],w[200048],tot=1,t; inline void addedge(int s,int t,int l,int cost) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=l;w[tot]=cost; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;w[tot]=-cost; &#125; int prevv[200048],preve[200048]; int h[200048]; priority_queue&lt;Pair&gt; q;int dist[200048]; inline void init() &#123; t=n*2+2; for (register int i=0;i&lt;=t;i++) head[i]=0; for (register int i=0;i&lt;=t;i++) h[i]=0; tot=1; &#125; bool dijkstra() &#123; int i,x,y,dd; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;q.push(mp(0,t)); while (!q.empty()) &#123; x=q.top().y;dd=-q.top().x;q.pop(); if (dd&gt;dist[x]) continue; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]+h[x]-h[y]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]+h[x]-h[y]; prevv[y]=x;preve[y]=i; q.push(mp(-dist[y],y)); &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; int qq[MAXN+48],Head,Tail;bool inq[MAXN+48]; bool spfa() &#123; int i,x,y; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;qq[Head=Tail=1]=t;inq[t]=true; while (Head&lt;=Tail) &#123; x=qq[Head++];inq[x]=false; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]; prevv[y]=x;preve[y]=i; if (!inq[y]) inq[y]=true,qq[++Tail]=y; &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; inline int min_cost_flow() &#123; int i,u,res,minf; for (i=0;i&lt;=t;i++) h[i]+=dist[i]; minf=INF; for (u=n*2+1;u!=t;u=prevv[u]) minf=min(minf,f[preve[u]]); res=minf*h[n*2+1]; for (u=n*2+1;u!=t;u=prevv[u]) &#123; f[preve[u]]-=minf; f[preve[u]^1]+=minf; &#125; return res; &#125; inline int ek() &#123; int ans=0; if (spfa()) &#123; do &#123; ans+=min_cost_flow(); &#125; while (dijkstra()); &#125; return -ans; &#125;&#125;int main ()&#123; int i,ca,s,t,v,op;io.Get(ca); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k);io.Get(w); flow::init(); for (i=1;i&lt;=n*2;i++) flow::addedge(0,i,INF,0),flow::addedge(i,n*2+1,INF,0); flow::addedge(n*2+2,0,k,0); for (i=1;i&lt;=n;i++) flow::addedge(i,n+i,INF,w),flow::addedge(n+i,i,INF,w); for (i=1;i&lt;=n-1;i++) flow::addedge(i,i+1,INF,0),flow::addedge(n+i,n+i+1,INF,0); for (i=1;i&lt;=m;i++) &#123; io.Get(s);io.Get(t);io.Get(v);io.Get(op); flow::addedge(op*n+s,(op^1)*n+t,1,-v); &#125; io.Print(flow::ek(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard_Rho分解质因数]]></title>
    <url>%2Fblog%2Fpollard_rho%2F</url>
    <content type="text"><![CDATA[Pollard_Rho的核心思想大概是两个: 生日攻击理论 假设当前要分解的数$p=a*b$，$a$和$b$很稀有，但是$a$和$b$的倍数却有很多，所以只要找到一个数$c$，使得$gcd(c,p)&gt;1$即可 所以算法大概是这样： 在[2,n-1]之间随机一些数$x_1,x_2…x_k$,$k$大概是$n^{\frac{1}{4}}$级别 判断是否存在$gcd(\mid x_i-x_j\mid ,p)&gt;1$ 但把这些x全部预处理出来的方法太傻了，事实上我们可以先造两个数出来，然后不断地生成伪随机数，pollard告诉我们,$x_{i+1}=(x_i^2+a)%N$是一个非常好的随机函数，这里的$a$是随机的，通常随机一个不会出锅如果真的出锅了就再随机一个 不过这个随机算法有一点问题：这样随机下去之后，$x_i$会重复。如果把所有的$x_i$都存下来然后哈希显然又显得烦了一些，有两种判圈算法可以帮我们在发现入圈之后跳出去 Floyd判圈法：它的核心思想是这样的：假设乌龟和兔子在某种形状的跑道上跑，兔子的速度比乌龟快，那么除了在起点的时刻，如果兔子遇到了乌龟，说明跑道上存在环，套用在pollard_rho上，就是$x_{i+1}=(x_i^2+a)%N$这个函数，准备$x$和$y$两个变量，一个每次做一下，一个每次做两下，模拟乌龟和兔子 Brent判圈法：还是用乌龟和兔子举例子，乌龟不动，兔子每跑一步，就判断一下是否和兔子相遇，一旦兔子跑的步数是2的次幂，就把乌龟移到兔子的位置。这个算法比Floyd要好一些]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Pollard_Rho分解质因数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Pollard_Rho分解质因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller_Rabin强伪素性测试]]></title>
    <url>%2Fblog%2Fmiller_rabin%2F</url>
    <content type="text"><![CDATA[Miller_Rabin强伪素性测试主要基于下面两个定理 费尔马小定理：若$gcd(a,p)=1$,则$a^{p-1}\equiv 1(mod$ &nbsp; $p)$ 二次探测定理：若p是质数且$a^2\equiv 1(mod$ &nbsp; $p)$,则$a\equiv \pm 1(mod$ &nbsp; $p)$ (对于2给出一个简单的证明: 若$a^2\equiv 1(mod$ &nbsp; $p)$,那么$p\mid a^2-1$,即$p\mid (a+1)(a-1)$,这里我们不讨论$p=2$的情况，因为p是质数，所以p不可能同时整除$a-1$和$a+1$,所以要么$p\mid a-1$,要么$p\mid a+1$,即$a\equiv \pm 1(mod$ &nbsp; $p)$) 也就是说，一旦找到任何一个$a$不满足上述条件，那么$p$一定不是质数 为什么定理1不够用还要定理2呢，因为有一种数叫Carmichael数，它们都是合数，且均满足对于$\forall a$,有$a^{p-1}\equiv 1(mod$ &nbsp; $p)$,这种数在1e8范围内只有255个，但是也足够多了 所以我们考虑下面的方法： 对于$p-1$,把它写成$p-1=2^kt$的形式,其中$p\equiv 1(mod$ &nbsp; $2)$ 随机一个小于p的数a, 快速幂算出$a^t$ 当前数是$a^t$,自乘的结果是$a^{2t}$,再自乘的结果是$a^{2^2t}$,依次类推，自乘k次后这个数就会变成$a^{2^kt}$,即$a^{p-1}$ 在3的过程中，参考上面的两条定理，我们可以得到： 如果最后这个数不等于1，那么p不是质数 如果在某一个时刻，这个数在模$p$意义下等于1,而上一时刻不等于$\pm 1$，那么$p$不是质数 我们称2和3为一次测试，一个数$p$,不是质数且通过一次测试的概率约为25%,所以多随机几次失败的概率就微乎其微]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Miller_Rabin强伪素性测试</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Miller_Rabin强伪素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6432][2018ACM多校]Cyclic 题解]]></title>
    <url>%2Fblog%2Fhdu6432%2F</url>
    <content type="text"><![CDATA[DescriptionCount the number of cyclic permutations of length n with no continuous subsequence [i, i + 1 mod n]. Output the answer modulo 998244353. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there is a single integer n in one line, denoting the length of cyclic permutations. 1 ≤ T ≤ 20, 1 ≤ n ≤ 100000 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 998244353. Sample Input3456 Sample Output1836 Source2018 Multi-University Training Contest 10 Solution考场上我已经想到了容斥竟然还没推出式子，卑劣地使用了OEIS，太惭愧了 容斥的思路是显然的，每次要算至少包含i个[i,i+1]片段的序列有多少种(这个“至少”指的是对于任意i个片段，这个序列都被算了一次)，这个怎么算呢？ 我们考虑所有的[i,i+1]片段，一共有[1,2],[2,3]…[n-1,n],[n,1]n种 我们考虑选出其中的i种，这i种将会在序列中出现，这个是$C_n^i$，然后我们将这些片段中的数捆在一起，比如如果选中了[1,2],[3,4]就把1和2捆在一起,3和4捆在一起; 如果选中了[1,2],[2,3]就把1,2,3三个数捆在一起。显然不论怎么选，最后一定会有n-i捆数，这些捆有$(n-i)!$种排列方法，考虑到这是一个置换群，所以1必须放在第一个，所以实际上是$(n-i-1)!$排列方法 这样我们得到了至少有i个片段的序列个数是$C_n^i(n-i-1)!$，注意到这个式子只在i=0~n-1的时候适用，当i=n时，显然有n个片段的排列只有一个，即1,2,3…n 所以最后的答案是 $$ans=(-1)^n+\sum_{i=0}^{n-1}(-1)^iC_n^i(n-i-1)!$$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int inv[MAXN+48],finv[MAXN+48],fac[MAXN+48];inline void init_inv()&#123; fac[0]=fac[1]=1; for (register int i=2;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y) &#123;return 1ll*fac[x]*finv[y]%MOD*finv[x-y]%MOD;&#125;int main ()&#123; int i,n,ans,ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);ans=0; for (i=0;i&lt;=n-1;i++) &#123; int delta=1ll*C(n,i)*fac[n-i-1]%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; if (n&amp;1) ans=sub(ans-1); else ans=add(ans+1); io.Print(ans,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6434][2018ACM多校]Count 题解]]></title>
    <url>%2Fblog%2Fhdu6434%2F</url>
    <content type="text"><![CDATA[DescriptionMultiple query, for each n, you need to get $$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)=1]$$ InputOn the first line, there is a positive integer T, which describe the number of queries. Next there are T lines, each line give a positive integer n, as mentioned above. T&lt;=1e5, n&lt;=2e7 OutputYour output should include T lines, for each line, output the answer for the corresponding n. Sample Input4978438233666 Sample Output194041389511106589963 Source2018 Multi-University Training Contest 10 Solution我刚开始的思路是：转而考虑枚举i+j和j，但发现j的范围与i+j有关，最后不好算 我们考虑枚举一个a,i+j=2i-a,i-j=a,可以看出这样的a和j是一一对应的，且a+j=n 所以我们转而求 $$\sum_{i=1}^n\sum_{a=1}^{n-1}[gcd(2i-a,a)=1]$$ 根据辗转相减求gcd的原理，我们有$gcd(a+b,b)=gcd(a,b)$，所以$gcd(2i-a,a)=gcd(2i,a)$ 于是我们转而求 $$\sum_{i=1}^n\sum_{j=1}^{n-1}[gcd(2i,a)=1]$$ 首先a肯定是奇数，然后这时可以把2扔掉，只判断i和a是否互质 如果i是偶数，那么小于i的与i互质的数必然全都是奇数，都可以作为a，所以这时答案是$phi(i)$ 如果i是奇数，考虑任意一个小于i且与i互质的数p，则i-p也和i互质，而且p和i-p必然一奇一偶，所以所有小于i且与i互质的数中，奇数偶数各占一半，所以这时答案是$\frac{phi(i)}{2}$ 所以只要线性筛一波欧拉函数，然后前缀和一下就好了，时间复杂度O(n+T) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e7;int phi[MAXN+48],prime[MAXN+48],tot;bool isprime[MAXN+48];inline void init_phi()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i,phi[i]=i-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]) phi[i*prime[j]]=phi[i]*(prime[j]-1); else phi[i*prime[j]]=phi[i]*prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;LL ans[MAXN+48];inline void init_ans()&#123; ans[1]=0; for (register int i=2;i&lt;=MAXN;i++) if (i&amp;1) ans[i]=ans[i-1]+phi[i]/2; else ans[i]=ans[i-1]+phi[i];&#125;int main ()&#123; int ca,i,n;io.Get(ca); init_phi();init_ans(); while (ca--) &#123; io.Get(n); io.Print(ans[n],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6412][百度之星2018]公共子序列 题解]]></title>
    <url>%2Fblog%2Fhdu6412%2F</url>
    <content type="text"><![CDATA[Description光羽一点都不喜欢高代，某一次高代课上，光羽特意挑了最后一排的位置，睡着睡着，他忽然想到了这道字符串水题！ 度度熊有k(k≥2)个序列s1,s2,..,sk，每个序列的长度均为n，且序列中每个数均是1到n之间某个整数，请问这k个串有多少个长度大于0的公共子序列？ 解释：在每个序列中都选出一些位置，并将这些位置对应的字符顺次拼接起来，当它们都相等时，称其为公共子序列。 答案可能很大，请对$10^9+7$取模。 Input第一行一个数，表示数据组数T。 每组数据第一行两个数k,n；接下来k行，每行一个长度为n的序列si。 数据组数T=80，分别有20组数据满足k=2,3,4,5。 每组数据均满足1≤n≤1000，且s1,s2,…,sk中每一个数在1到n之间等概率随机生成！！ 随机生成！！ 随机生成！！ 随机生成！！ Output每组数据输出一行，每行仅包含一个数，表示公共子序列个数。 Sample Input42 31 2 12 3 13 31 2 32 3 11 2 34 33 2 23 1 32 3 13 2 15 33 1 33 1 11 2 32 3 31 3 3 Sample Output4428 Source2018“百度之星”程序设计大赛 - 复赛 Solution这么naive的题我赛场没有做出来，这种随机相关的题见的太少了…… 两个串的公共子串个数有非常简单的$O(n^2)$的dp可以解决，如果没有特殊性质，那么$k=5$时的复杂度应该是$O(n^5)$的，所以必须利用好随机这个性质 我刚开始一直在往最长公共子串很短这方面想，但这并没有什么用。我们可以考虑常规dp里的每个状态，记录的第一，二，三…个串的公共子串的最后位置p1,p2,p3…pn，要满足$s1[p1]=s2[p2]=s3[p3]=…=sn[pn]$,在随机的情况下，每个数列都接近一个排列，所以这样的状态数不会很多，期望是$O(n)$的，所以只要先搜索出所有合法的状态，再做一个$O(n^2)$的dp就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,k;int a[6][MAXN+48];vector&lt;int&gt; v[6][MAXN+48];struct node&#123; int pos[6]; inline bool operator &lt; (const node &amp;other) const &#123; for (register int i=1;i&lt;=k;i++) if (pos[i]&gt;=other.pos[i]) return false; return true; &#125;&#125;sta[MAXN*10+48],ins;int tot;int dp[MAXN*10+48];inline void dfs(int step,int type)&#123; if (step==k+1) &#123; sta[++tot]=ins; return; &#125; for (register int i=0;i&lt;int(v[step][type].size());i++) ins.pos[step]=v[step][type][i],dfs(step+1,type);&#125;inline int solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=1; for (register int i=1;i&lt;=tot;i++) if (sta[i]&lt;sta[cur]) dp[cur]=add(dp[cur]+solve(i)); return dp[cur];&#125;inline void Clear()&#123; for (register int i=1;i&lt;=k;i++) for (register int j=1;j&lt;=n;j++) v[i][j].clear();&#125;int main ()&#123; int i,j,ca;io.Get(ca); while (ca--) &#123; io.Get(k);io.Get(n);Clear(); for (i=1;i&lt;=k;i++) for (j=1;j&lt;=n;j++) io.Get(a[i][j]),v[i][a[i][j]].pb(j); tot=0; for (i=1;i&lt;=n;i++) dfs(1,i); memset(dp,-1,sizeof(dp));int ans=0; for (i=1;i&lt;=tot;i++) ans=add(ans+solve(i)); io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>HDU</tag>
        <tag>随机</tag>
        <tag>百度之星</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6403][2018ACM多校]Card Game 题解]]></title>
    <url>%2Fblog%2Fhdu6403%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob are playing a card game. In this card game, a number is written on each face of the playing card. The rule of the game is described as follows: Alice arranges the cards in a row, and for each of the cards, she chooses one of its faces to place it up; Bob turns over minimum number of cards to make all numbers on the front faces unique. They play the game some times, and Bob always succeeds making the numbers unique. However, both of them are not sure whether the number of cards flipped is minimum. Moreover, they want to figure out the number of different ways of turning over minimum number of cards to make the numbers unique. Two ways are considered equal if and only if the sets of flipped cards are equal. Please write a program to help them! InputThe first line of the input is a single integer T (1≤T≤50), the number of test cases. Each test case begins with a single line of integer n (1≤n≤105), the number of cards on the table. Then follow n lines, specifying the cards that Alice arranges. Each of these n lines contains two integers x,y (1≤x,y≤2n), meaning that Alice places a card with number x on the front face and number y on the back face. It is guaranteed that the sum of n over all test cases does not exceed 106. OutputFor each test case, display two integers in a line, the minimum number of cards to turn over, and the number of different ways of flipping modulo 998244353, respectively. If it is impossible to turn over cards to make all numbers unique, display -1 -1 instead. Sample Input341 21 34 54 621 11 131 23 45 6 Sample Output2 4-1 -10 1 HintIn the first sample test case, Bob may turn over one of the first two cards and one of the last two cards, so there are four different ways of turning over two cards tomake all numbers on the front faces unique. Obviously, this can’t be done with less than two cards flipped. In the second sample test case, it is impossible to make all numbers on the front faces unique. In the third sample test case, all numbers on the front faces are already distinct. Source2018 Multi-University Training Contest 8 Solution非常赞的图论建模题 我们可以考虑把每场卡片看成一条无向边，把数字看成点，比如卡片上的数字是u和v，就在u和v之间连一条边，这样我们的任务就是给每条边定向（显然有一种方向权值是0，另外一种方向权值是1），使得每个点被不多于一条边指向（即每条边指向的点是这张卡片最后的数字），且权值和最小 我们可以发现两个重要的性质 如果出现了一个环，那么这个环只有两种定向方式：逆时针和顺时针，即环上的每个点都会被指到 如果某个联通块中有两个环，那么必然无解。因为考虑连接两个环的路径，因为路径的两头的点都属于环中，根据性质1，这两个点都在环上被指到了，那么这条路径中的边数会比点数多1，无论如何也不可能合法定向 所以每个联通块要么是基环外向树，要么是树，分情况讨论： 基环外向树：考虑环上挂的若干棵树，因为根节点在环上已经被指到了，所以树中所有连接到根节点的边必须向下定向，同理根节点的孩子们都被指到了，所以根节点的孩子们的边也要向下定向……所以说，基环树上的每棵树的定向方式都是唯一的，即所有边都向下，然后环有两种情况，分别判一下就好。尤其要注意自环的情况，自环无论如何只可能有一种情况 树：树中有n-1条边和n个点，所以必然有且仅有一个点没有被指到，考虑一旦确定了这个没有被指到的点，以它为根，那么整棵树的定向就确定了。我们可以先考虑随便抓一个点i作为根算一遍，得到一个初始答案ans,然后再做一遍深搜枚举根，设当前根为j,我们会发现这时i到j的路径上的边会反向，其他边不变，这个可以边搜边记录，可以比较轻松的解决 至此所有情况讨论完毕，时间复杂度$O(n)$，对代码能力要求稍高 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n;vector&lt;int&gt; v[MAXN+48];bool incir[MAXN+48];struct Edge&#123; int u,v; inline void input() &#123;io.Get(u);io.Get(v);&#125;&#125;edge[MAXN+48];inline int getanother(int id,int u)&#123; return edge[id].u==u?edge[id].v:edge[id].u;&#125;int cid,cnt;int depth[MAXN+48],fa[MAXN+48],vis[MAXN+48],exist[MAXN+48];//fa didn't store his father but the id of the edge to his fatherinline void dfs(int cur,int father)&#123; fa[cur]=father;int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (!depth[y]) &#123; depth[y]=depth[cur]+1; dfs(y,id); &#125; else if (id!=father &amp;&amp; depth[y]&lt;=depth[cur]) &#123; cnt++; cid=id; &#125; &#125;&#125;int minn,minmethod;namespace cycle&#123; int cirlist[MAXN+48],ctot; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father &amp;&amp; !incir[y]) &#123; if (cur==edge[id].u) minn++; dfs(y,id); &#125; &#125; &#125; inline void solve() &#123; ctot=0;int u=edge[cid].u,v=edge[cid].v; if (depth[u]&lt;depth[v]) swap(u,v); for (register int cur=u;cur!=v;cur=getanother(fa[cur],cur)) cirlist[++ctot]=cur,incir[cur]=true; cirlist[++ctot]=v;incir[v]=true; for (register int i=1;i&lt;=ctot;i++) dfs(cirlist[i],-1); if (ctot==1) return; int cnt1=0,cnt2=0; //from down to up for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].u==cirlist[i]) cnt1++; if (edge[cid].u==cirlist[ctot]) cnt1++; //from up to down for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].v==cirlist[i]) cnt2++; if (edge[cid].u==cirlist[1]) cnt2++; minn+=min(cnt1,cnt2); if (cnt1==cnt2) minmethod=add(minmethod+minmethod); &#125;&#125;namespace tree&#123; int Minn,Cnt,ans; inline void update(int curans) &#123; if (curans&lt;Minn) Minn=curans,Cnt=1; else if (curans==Minn) Cnt++; &#125; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father) &#123; if (edge[id].u==cur) ans++; dfs(y,id); &#125; &#125; &#125; inline void Dfs(int cur,int father) &#123; update(ans);int i,id,y,delta; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id==father) continue; if (edge[id].u==cur) delta=1; else delta=-1; ans-=delta;Dfs(y,id); ans+=delta; &#125; &#125; inline void solve(int root) &#123; Minn=INF;Cnt=0; ans=0;dfs(root,-1); Dfs(root,-1); minn+=Minn;minmethod=(1ll*minmethod*Cnt)%MOD; &#125;&#125;inline void Clear()&#123; for (register int i=1;i&lt;=n*2;i++) depth[i]=0,v[i].clear(),incir[i]=false,vis[i]=false; minn=0;minmethod=1;&#125;int main ()&#123; int ca;io.Get(ca);int i; while (ca--) &#123; io.Get(n);Clear(); bool f=true; for (i=1;i&lt;=n;i++) &#123; edge[i].input(); if (edge[i].u!=edge[i].v) v[edge[i].u].pb(i),v[edge[i].v].pb(i); else v[edge[i].u].pb(i); exist[edge[i].u]=true;exist[edge[i].v]=true; if (edge[i].u==edge[i].v) &#123; if (vis[edge[i].u]) f=false; vis[edge[i].u]=true; &#125; &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; for (i=1;i&lt;=n*2;i++) if (!depth[i] &amp;&amp; exist[i]) &#123; cnt=0;cid=0; depth[i]=1;dfs(i,-1); if (cnt&gt;1) &#123;f=false;break;&#125; if (cnt==1) cycle::solve(); else tree::solve(i); &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; io.Print(minn,' ');io.Print(minmethod,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>图论</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6406][2018ACM多校]Taotao Picks Apples 题解]]></title>
    <url>%2Fblog%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1,h2,⋯,hn, you are required to answer some independent queries. Each query is two integers p,q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1≤T≤10), the number of test cases. Each test case begins with a line of two integers n,m (1≤n,m≤105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1,h2,⋯,hn (1≤hi≤109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1≤p≤n) and q (1≤q≤109), as described in the problem statement. OutputFor each query, display the answer in a single line. Sample Input15 31 2 3 4 41 55 52 3 Sample Output153 HintFor the first query, the heights of the apples were 5, 2, 3, 4, 4, so Taotao would only pick the first apple. For the second query, the heights of the apples were 1, 2, 3, 4, 5, so Taotao would pick all these five apples. For the third query, the heights of the apples were 1, 3, 3, 4, 4, so Taotao would pick the first, the second and the fourth apples. Source2018 Multi-University Training Contest 8 Solution我们可以先预处理原数列中会摘哪些苹果，这样对于每次询问，如果这次修改的苹果是pos，那么原数列中位置在pos前的那些苹果还是会被摘，这个可以二分一下找出在它之前的苹果个数 设之前的最后一个苹果的高度是h, 位置pos的新苹果高度为nv，分两种情况讨论： h&lt;nv 则下一个苹果是nv，在往下一个苹果是pos之后的第一个比nv大的苹果 h&gt;=nv 则下一个苹果是pos之后的第一个比h大的苹果 我们可以看出两种情况都需要支持查找在某个位置p之后，第一个比某个值val大的值在什么位置，显然我们可以二分这个位置，然后查找这个区间的max，如果max&gt;val则在位置以左，否则在位置以右，静态的查询max可以用ST表，这样复杂度可以控制在一个log 找到这关键的pos以右的第一个苹果之后，我们可以发现这之后的苹果都是原始数列的苹果，所以我们可以刚开始从后往前预处理一下从某个苹果开始向后能摘多少个苹果，加一下就好了 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;int n,m;int a[MAXN+48];int maxn[MAXN+48][21],Log[MAXN+48];inline void construct_ST()&#123; int i,j; for (i=1;i&lt;=n;i++) maxn[i][0]=a[i]; for (j=1;j&lt;=20;j++) for (i=1;i&lt;=n;i++) &#123; maxn[i][j]=maxn[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=n) maxn[i][j]=max(maxn[i][j],maxn[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (i=2;i&lt;=MAXN;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return max(maxn[l][Log[k]],maxn[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int find(int pos,int cmp)&#123; int l=pos,r=n,mid,res=-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_ST(pos,mid)&gt;cmp) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int dp[MAXN+48];inline void init_dp()&#123; for (register int i=n;i&gt;=1;i--) &#123; dp[i]=1; int res=find(i+1,a[i]); if (res!=-1) dp[i]+=dp[res]; &#125;&#125;int seq[MAXN+48],tot;inline int bsearch(int cmp)&#123; int l=1,r=tot,res=0,mid; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (seq[mid]&gt;=cmp) r=mid-1; else res=mid,l=mid+1; &#125; return res;&#125;int main ()&#123; int ca;io.Get(ca);int i,pos,nv; while (ca--) &#123; io.Get(n);io.Get(m); for (i=1;i&lt;=n;i++) io.Get(a[i]); construct_ST();init_dp();tot=0; seq[++tot]=1; for (i=2;i&lt;=n;i++) if (a[i]&gt;a[seq[tot]]) seq[++tot]=i; while (m--) &#123; io.Get(pos);io.Get(nv); int pp=bsearch(pos),ans=pp; if (!pp || a[seq[pp]]&lt;nv) &#123; ans++; int res=find(pos+1,nv); if (res!=-1) ans+=dp[res]; &#125; else &#123; int res=find(pos+1,a[seq[pp]]); if (res!=-1) ans+=dp[res]; &#125; io.Print(ans); &#125; &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6397][2018ACM多校]Character Encoding 题解]]></title>
    <url>%2Fblog%2Fhdu6397%2F</url>
    <content type="text"><![CDATA[DescriptionIn computer science, a character is a letter, a digit, a punctuation mark or some other similar symbol. Since computers can only process numbers, number codes are used to represent characters, which is known as character encoding. A character encoding system establishes a bijection between the elements of an alphabet of a certain size n and integers from 0 to n−1. Some well known character encoding systems include American Standard Code for Information Interchange (ASCII), which has an alphabet size 128, and the extended ASCII, which has an alphabet size 256. For example, in ASCII encoding system, the word wdy is encoded as [119, 100, 121], while jsw is encoded as [106, 115, 119]. It can be noticed that both 119+100+121=340 and 106+115+119=340, thus the sum of the encoded numbers of the two words are equal. In fact, there are in all 903 such words of length 3 in an encoding system of alphabet size 128 (in this example, ASCII). The problem is as follows: given an encoding system of alphabet size n where each character is encoded as a number between 0 and n−1 inclusive, how many different words of length m are there, such that the sum of the encoded numbers of all characters is equal to k? Since the answer may be large, you only need to output it modulo 998244353. InputThe first line of input is a single integer T (1≤T≤400), the number of test cases. Each test case includes a line of three integers n,m,k (1≤n,m≤$10^5$,0≤k≤$10^5$), denoting the size of the alphabet of the encoding system, the length of the word, and the required sum of the encoded numbers of all characters, respectively. It is guaranteed that the sum of n, the sum of m and the sum of k don’t exceed $5×10^6$, respectively. OutputFor each test case, display the answer modulo 998244353 in a single line. Sample Input42 3 32 3 43 3 3128 3 340 Sample Output107903 Source2018 Multi-University Training Contest 8 Solution这题我刚开始直接无脑上了多项式快速幂，然后就T飞了，于是被戴大爷教做人……真的是知识越多越反动 我们考虑如果没有每个数在0~n-1这个条件的话，那就是一个简单的盒子可空的隔板法问题，现在加上这个限制，我们考虑容斥，那么最后的方案可以写成这样 $$ans=\sum_{i=0}^{lim}(-1)^i*f(至少有i个数大于n-1)$$ 现在考虑$f(至少有i个数大于n-1)$怎么算，我们可以先钦定哪i个位置比n-1大，这个是$C_m^i$，然后剩下的依旧是一个简单的隔板法，于是就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=3e5;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD,y&gt;&gt;=1; &#125; return res;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int fac[MAXN+48],finv[MAXN+48];inline void init_inv()&#123; fac[0]=1; for (register int i=1;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || y&lt;0 || x&lt;y) return 0; return ((1ll*fac[x]*finv[y])%MOD*finv[x-y])%MOD;&#125;int n,m,k;int main ()&#123; int ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k); int ans=0; for (register int i=0;i&lt;=m &amp;&amp; n*i&lt;=k;i++) &#123; int delta=(1ll*C(m,i)*C(k-n*i+m-1,m-1))%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1019B]The hat 题解]]></title>
    <url>%2Fblog%2Fcf1019b%2F</url>
    <content type="text"><![CDATA[DescriptionThis is an interactive problem. Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice. As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists. You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. InputAt the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students. You are allowed to ask no more than 60 questions. OutputTo ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109). When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn’t exist, you should output «! -1». In both cases you should immediately terminate the program. The query that contains your answer is not counted towards the limit of 60 queries. Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language. HackingUse the following format for hacking: In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students. In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or - 1. The hacked solution will not have direct access to the sequence ai. Examplesinput 822 output ? 4? 8! 4 input 6123210 output ? 1? 2? 3? 4? 5? 6! -1 NoteInput-output in statements illustrates example interaction. In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2 In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. Solution交互题毁我青春……本人不擅长做动脑子的题，这个花了整场比赛才做出来，于是rnk在2题里面垫底。。。 既然次数只有60次，感觉每次肯定要查询相对的两个人，相当于查询30组，估计是二分相关 我们永远考虑位置相对的两个扇形，设上面的扇形上的数字从a到A,下面的扇形上的数字从b到B 通过仔细的观察，我们能发现一些结论： 如果$abs(a-b)\equiv 1(mod 2)$，那么这两个扇形区域内必然没有任何一组数相等 如果$a&gt;b$且$A&lt;B$，那这两个扇形区域内必然有一组数相等 如果(a,A),(b,B)两个区间不相交，那么这两个扇形区域内必然没有任何一组数相等 进而我们可以发现，对于相对的两个扇形，我们二分出中间的一条线，把他们切成两组扇形，这两组扇形要么有一组铁定无解，要么至少有一组铁定有解，无论是哪一种情况，我们都可以把另一半扔掉，在必定有解的那一半里继续二分 这就是大概的思路了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);inline int getint()&#123; bool f;char ch;int res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n;int a,A,b,B,m,M;inline int myabs(int x) &#123;return x&gt;=0?x:-x;&#125;inline bool check_invalid()&#123; if (myabs(a-b)%2==0) return false; if (myabs(A-B)%2==0) return false; return true;&#125;inline bool Contain(int l1,int r1,int l2,int r2)&#123; if (l1&gt;l2 &amp;&amp; r1&lt;r2) return true; if (l1&lt;l2 &amp;&amp; r1&gt;r2) return true; return false;&#125;inline bool Away(int l1,int r1,int l2,int r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return r1&lt;l2 || r2&lt;l1;&#125;int main ()&#123; n=getint(); if (n==2) &#123; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? 2\n");fflush(stdout);scanf("%d",&amp;A); if (a==A) printf("! 1\n"); else printf("! -1\n"); return 0; &#125; int la=1,lA=n/2; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? %d\n",lA);fflush(stdout);scanf("%d",&amp;A); printf("? %d\n",la+n/2);fflush(stdout);scanf("%d",&amp;b); printf("? %d\n",lA+n/2);fflush(stdout);scanf("%d",&amp;B); if (a==b) &#123; printf("! 1\n"); return 0; &#125; if (A==B) &#123; printf("! %d\n",lA); return 0; &#125; if (check_invalid()) &#123;printf("! -1\n");return 0;&#125; while (lA-la&gt;1) &#123; int mid=(la+lA)&gt;&gt;1,to=mid+n/2; printf("? %d\n",mid);fflush(stdout);scanf("%d",&amp;m); printf("? %d\n",to);fflush(stdout);scanf("%d",&amp;M); if (m==M) &#123; printf("! %d\n",mid); return 0; &#125; if (Contain(a,m,b,M)) &#123;lA=mid;A=m;B=M;continue;&#125; if (Contain(m,A,M,B)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(a,m,b,M)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(m,A,M,B)) &#123;lA=mid;A=m;B=M;continue;&#125; &#125; if (a==b) &#123;printf("! %d\n",la);return 0;&#125; if (A==B) &#123;printf("! %d\n",lA);return 0;&#125; printf("! -1\n");return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
</search>
