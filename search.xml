<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces #115D: Unambiguous Arithmetic Expression 题解]]></title>
    <url>%2Fblog%2Fcf115d%2F</url>
    <content type="text"><![CDATA[DescriptionLet’s define an unambiguous arithmetic expression (UAE) as follows. All non-negative integers are UAE’s. Integers may have leading zeroes (for example, 0000 and 0010 are considered valid integers). If X and Y are two UAE’s, then “(X) + (Y)”, “(X) - (Y)”, “(X) * (Y)”, and “(X) / (Y)” (all without the double quotes) are UAE’s. If X is an UAE, then “ - (X)” and “ + (X)” (both without the double quotes) are UAE’s. You are given a string consisting only of digits (“0” - “9”) and characters “-“, “+”, “*”, and “/“. Your task is to compute the number of different possible unambiguous arithmetic expressions such that if all brackets (characters “(“ and “)”) of that unambiguous arithmetic expression are removed, it becomes the input string. Since the answer may be very large, print it modulo 1000003 (1e6 + 3). InputThe first line is a non-empty string consisting of digits (‘0’-‘9’) and characters ‘-‘, ‘+’, ‘*’, and/or ‘/‘. Its length will not exceed 2000. The line doesn’t contain any spaces. OutputPrint a single integer representing the number of different unambiguous arithmetic expressions modulo 1000003 (106 + 3) such that if all its brackets are removed, it becomes equal to the input string (character-by-character). ExamplesInput 1+2*3 Output 2 Input 03+-30+40 Output 3 Input 5//4 Output 0 Input 5/0 Output 1 Input 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 Output 100728 NoteFor the first example, the two possible unambiguous arithmetic expressions are: ((1) + (2)) * (3) (1) + ((2) * (3)) For the second example, the three possible unambiguous arithmetic expressions are: (03) + (( - (30)) + (40)) (03) + ( - ((30) + (40))) ((03) + ( - (30))) + (40) Solution一道神dp题。 首先一个$O(n^3)$的dp是非常好想的，直接考虑区间dp，然后枚举中间断点转移即可。 然后就不会了 我们先把一些必定无解的情况判掉，有两种： 乘号和除号必须作为连接运算符而不能作为符号位，所以如果乘号和除号的前面不是数字必然无解 如果最后一个字符不是数字必然无解 其他的情况都有解。与此同时，我们还能判断出每个加号和减号是什么类型的：对于一串连续的符号，只有第一个符号是连接运算符，其他的都是符号位。 我们考虑这样的一个例子： (+(233))−(8) 这其中的加减运算符有的是连接运算符，有的是符号位，我们考虑统一一下，对于所有的符号位，我们看做是一个空括号和后面的东西相加，这样所有的符号就都是连接运算符了，上述的例子变成了这样 (()+(233))-(8) 这时每个符号作为连接运算符，都对应着左边的一对括号和右边的一对括号，我们把每个运算符右边对应的括号去掉，上述例子变成这样 (()+233)-8 再把所有的数字去掉，得到 (()) 以此为例，我们发现一个UAE可以对应到一个括号序列上，而且所有括号对的右括号按照运算符的出现顺序出现。这里的括号之间的嵌套和并列关系本质上刻画了UAE运算过程中左边和右边谁包含谁的关系，比如上面的例子中是一对嵌套的括号，就意味着加号所连接的东西以一个整体作为减号的左边部分，即右边包含了左边。 我们再看一个例子，还是上面的数字和符号，另一个UAE +((233)-(8)) 按照规则对应的括号序列是 ()() 这样并列的括号刻画的是右边的减号所连接的东西以一个整体作为加号的右边部分，即左边包含了右边。 因此一个括号序列可以非常严密的刻画UAE所有运算的顺序，从而与UAE中符号个数相等的括号形成的括号序列和UAE成一一对应关系。另外要注意的是，所有在先前作为符号位出现的运算符，因为我们是给它人为地加了一对括号，所以它对应的括号不能包含任何其他的括号。 现在我们只要计算符合上述条件的括号序列个数即可，到了这一步就很容易了。令$dp[i][j]$表示当前考虑到第$i$个运算符，当前序列由$j$个并列的括号构成的方案数。转移考虑最后一对括号的左括号放在哪里。如果第$i$个运算符是一个符号位，那么它只能是在原序列的基础上在结尾加一对空括号形成，$dp[i][j]$从$dp[i-1][j-1]$转移而来，否则当前的这对括号可以包住之前的0对，1对，2对…括号，那些被包在里面的括号将不能继续用于转移。$dp[i][j]$从$dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]…$转移而来，这个可以在dp的过程中维护一个后缀和。 总时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e6+3;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2000;char s[MAXN+48];int len;int n,type[MAXN+48];int dp[MAXN+48][MAXN+48],sum[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);len=strlen(s+1); for (register int i=1;i&lt;=len;i++) &#123; if (isdigit(s[i])) continue; if (s[i]=='*' || s[i]=='/') &#123; type[++n]=0; if (i==1 || !isdigit(s[i-1])) &#123;printf("0\n");return 0;&#125; &#125; if (s[i]=='+' || s[i]=='-') &#123; ++n; if (i&gt;1 &amp;&amp; !isdigit(s[i-1])) type[n]=1; &#125; &#125; if (!isdigit(s[len])) &#123;printf("0\n");return 0;&#125; dp[0][0]=1;sum[0][0]=1; for (register int i=1;i&lt;=n;i++) for (register int j=i;j&gt;=1;j--) &#123; Add(dp[i][j],dp[i-1][j-1]); if (!type[i]) Add(dp[i][j],sum[i-1][j]); sum[i][j]=add(sum[i][j+1]+dp[i][j]); &#125; int ans=0; for (register int i=0;i&lt;=n;i++) Add(ans,dp[n][i]); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #490F: Treeland Tour 题解]]></title>
    <url>%2Fblog%2Fcf490f%2F</url>
    <content type="text"><![CDATA[DescriptionThe “Road Accident” band is planning an unprecedented tour around Treeland. The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have. Treeland consists of n cities, some pairs of cities are connected by bidirectional roads. Overall the country has n - 1 roads. We know that it is possible to get to any city from any other one. The cities are numbered by integers from 1 to n. For every city we know its value ri — the number of people in it. We know that the band will travel along some path, having concerts in some cities along the path. The band’s path will not pass one city twice, each time they move to the city that hasn’t been previously visited. Thus, the musicians will travel along some path (without visiting any city twice) and in some (not necessarily all) cities along the way they will have concerts. The band plans to gather all the big stadiums and concert halls during the tour, so every time they will perform in a city which population is larger than the population of the previously visited with concert city. In other words, the sequence of population in the cities where the concerts will be held is strictly increasing. In a recent interview with the leader of the “road accident” band promised to the fans that the band will give concert in the largest possible number of cities! Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities, so that the population number will increase, and the number of concerts will be the largest possible. The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland. Looks like they can’t manage without some help from a real programmer! Help the fans find the sought number of concerts. InputThe first line of the input contains integer n (2 ≤ n ≤ 6000) — the number of cities in Treeland. The next line contains n integers r1, r2, …, rn (1 ≤ ri ≤ 106), where ri is the population of the i-th city. The next n - 1 lines contain the descriptions of the roads, one road per line. Each road is defined by a pair of integers aj, bj (1 ≤ aj, bj ≤ n) — the pair of the numbers of the cities that are connected by the j-th road. All numbers in the lines are separated by spaces. OutputPrint the number of cities where the “Road Accident” band will have concerts. Examplesinput 6 1 2 3 4 5 1 1 2 2 3 3 4 3 5 3 6 output 4 input 5 1 2 3 4 5 1 2 1 3 2 4 3 5 output 3 Solution 1这题一眼看上去感觉数据范围出小了，但是还是先想一个$O(n^2)$的算法比较好。 考虑$dp1[i]$表示以$i$为根的子树，且选择了$i$的最长上升序列长度(从下往上看)，$dp2[i]$表示以$i$为根的子树，且选择了$i$的最长下降序列长度(从下往上看)，这两个dp非常好转移，只要枚举子树内的下一个状态就可以了，这个部分显然是$O(n^2)$的。 接下来考虑如何计算答案。一方面，如果这条链在树上没有“拐弯”，那么一定被$dp1[i]$和$dp2[i]$统计到了，将这些dp值取一个max;另一方面，如果拐弯了，考虑枚举转折点$i$，再枚举一对$lca$为$i$的点$(u,v)$作为接下去的状态，那么在$u$和$v$的$r$值符合条件的情况下，用$dp1[u]+dp2[v]$和$dp1[v]+dp2[u]$更新答案，如果转折点$i$的$r$值介于$u$和$v$之间，用上述两个值+1去更新答案。 因为每个点对只会在它们的$lca$处被枚举，所以总时间复杂度$O(n^2)$，枚举$lca$为某个点的点对可以用dfs序作为小技巧。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=6000;int n;int dp1[MAXN+48],dp2[MAXN+48],r[MAXN+48];vector&lt;int&gt; v[MAXN+48];int ans=0;int L[MAXN+48],R[MAXN+48],seq[MAXN+48],link[MAXN+48],ind;inline void dfs(int cur,int father)&#123; seq[++ind]=cur;L[cur]=ind;dp1[cur]=dp2[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) dfs(y,cur); &#125; R[cur]=ind;int maxn1=0,maxn2=0; for (register int i=L[cur]+1;i&lt;=R[cur];i++) &#123; if (r[seq[i]]&lt;r[cur]) check_max(maxn1,dp1[seq[i]]); if (r[seq[i]]&gt;r[cur]) check_max(maxn2,dp2[seq[i]]); &#125; dp1[cur]+=maxn1;dp2[cur]+=maxn2; check_max(ans,dp1[cur]);check_max(ans,dp2[cur]); for (register int i=L[cur]+1;i&lt;=R[cur];i=R[seq[i]]+1) for (register int j=i;j&lt;=R[seq[i]];j++) link[j]=R[seq[i]]+1; for (register int i=L[cur]+1;i&lt;=R[cur];i++) for (register int j=link[i];j&lt;=R[cur];j++) &#123; if (r[seq[i]]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]); if (r[seq[i]]&gt;r[seq[j]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]); if (r[seq[i]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]+1); if (r[seq[j]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[i]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]+1); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]); int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); dfs(1,-1); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125; Solution 2这个过程显然是可以优化的，首先考虑该dp的第一部分，在子树内找$r$值比根节点$r$值大的点中的$lid$和$lds$的长度，显然可以用一个BIT或者权值线段树来解决，这样这个部分可以做到$O(nlogn)$ 第二个部分涉及两个子树之间的合并，考虑线段树合并，在合并两个子树的权值线段树的过程中，我们可以借助线段树本身的分治性来帮我们统计答案，对于线段树合并的每一层，我们只要拿着第一棵树的左孩子的$lis$加上第二棵树的右孩子的$lds$,以及第二棵树的左孩子的$lis$和第一棵树的右孩子的$lds$来更新答案，这样相当于将小于$mid$和大于$mid$的部分进行了合并，再左右分治下去就完成了所有的子树信息的合并。 Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n;vector&lt;int&gt; v[MAXN+48];int r[MAXN+48],val[MAXN+48],cnt;int ans=0;int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*4],rson[MAXN*4],lis[MAXN*4],lds[MAXN*4],tot; inline void init() &#123; memset(root,0,sizeof(root)); memset(lson,0,sizeof(lson)); memset(rson,0,sizeof(rson)); memset(lis,0,sizeof(lis)); memset(lds,0,sizeof(lds)); tot=0; &#125; inline void pushup(int cur) &#123; lis[cur]=lds[cur]=0; if (lson[cur]) check_max(lis[cur],lis[lson[cur]]),check_max(lds[cur],lds[lson[cur]]); if (rson[cur]) check_max(lis[cur],lis[rson[cur]]),check_max(lds[cur],lds[rson[cur]]); &#125; inline int merge(int root1,int root2) &#123; if (!root1 || !root2) return root1^root2; check_max(ans,lis[lson[root1]]+lds[rson[root2]]); check_max(ans,lis[lson[root2]]+lds[rson[root1]]); lson[root1]=merge(lson[root1],lson[root2]);rson[root1]=merge(rson[root1],rson[root2]); pushup(root1);return root1; &#125; inline void modify(int &amp;cur,int pos,int nv,int l,int r,int type) &#123; if (!cur) cur=++tot; if (l==r) &#123; if (type==1) check_max(lis[cur],nv); else check_max(lds[cur],nv); return; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) modify(lson[cur],pos,nv,l,mid,type); else modify(rson[cur],pos,nv,mid+1,r,type); pushup(cur); &#125; inline int query(int &amp;cur,int left,int right,int l,int r,int type) &#123; if (!cur) return 0; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;if (type==1) return lis[cur]; else return lds[cur];&#125; int mid=(l+r)&gt;&gt;1,res=0; if (left&lt;=mid) check_max(res,query(lson[cur],left,right,l,mid,type)); if (mid+1&lt;=right) check_max(res,query(rson[cur],left,right,mid+1,r,type)); return res; &#125;&#125;inline void dfs(int cur,int father)&#123; int maxn1=0,maxn2=0,cmaxn1,cmaxn2; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); cmaxn1=SegmentTree::query(root[y],1,r[cur]-1,1,cnt,1); cmaxn2=SegmentTree::query(root[y],r[cur]+1,cnt,1,cnt,2); check_max(ans,maxn1+cmaxn2+1);check_max(ans,cmaxn1+maxn2+1); check_max(maxn1,cmaxn1);check_max(maxn2,cmaxn2); root[cur]=SegmentTree::merge(root[cur],root[y]); &#125; &#125; SegmentTree::modify(root[cur],r[cur],maxn1+1,1,cnt,1); SegmentTree::modify(root[cur],r[cur],maxn2+1,1,cnt,2);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]),val[i]=r[i]; int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); sort(val+1,val+n+1);cnt=unique(val+1,val+n+1)-(val+1); for (register int i=1;i&lt;=n;i++) r[i]=lower_bound(val+1,val+cnt+1,r[i])-val; SegmentTree::init(); dfs(1,-1);printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>Dynamic Programming</category>
        <category>常用技术</category>
        <category>线段树</category>
        <category>树型dp</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #19E: Fairy 题解]]></title>
    <url>%2Fblog%2Fcf19e%2F</url>
    <content type="text"><![CDATA[DescriptionOnce upon a time there lived a good fairy A. One day a fine young man B came to her and asked to predict his future. The fairy looked into her magic ball and said that soon the fine young man will meet the most beautiful princess ever and will marry her. Then she drew on a sheet of paper n points and joined some of them with segments, each of the segments starts in some point and ends in some other point. Having drawn that picture, she asked the young man to erase one of the segments from the sheet. Then she tries to colour each point red or blue so, that there is no segment having points of the same colour as its ends. If she manages to do so, the prediction will come true. B wants to meet the most beautiful princess, that’s why he asks you to help him. Find all the segments that will help him to meet the princess. InputThe first input line contains two integer numbers: n — amount of the drawn points and m — amount of the drawn segments (1 ≤ n ≤ 1e4, 0 ≤ m ≤ 1e4). The following m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v, u (1 ≤ v ≤ n, 1 ≤ u ≤ n) — indexes of the points, joined by this segment. No segment is met in the description twice. OutputIn the first line output number k — amount of the segments in the answer. In the second line output k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order. ExamplesInput 4 4 1 2 1 3 2 4 3 4 Output 4 1 2 3 4 Input 4 5 1 2 2 3 3 4 4 1 1 3 Output 1 5 Solution 1简单来说就是从图中删掉一条边，使得图中没有奇环。 考虑对原图求出dfs树，则此时我们的边只有树边和返祖边两种（因为这是一个无向图）。根据返祖边连接的两个点的深度差的奇偶性可以判断所有返祖边所在的环长的奇偶性。 如果原图中没有奇环，那么任意删去一条边以后肯定也没有奇环，这种平凡的情况以下不讨论。 否则分两种情况讨论： 删去一条非树边：则原图中必须只有一个奇环，这显然是必要的。 删去一条树边，则该树边必须为所有奇环的公共边，这也是必要的。 接下来考虑要使得条件充分还需要什么。我们考虑到如果一个奇环和一个偶环相交的话，那么这两个环的复合环肯定是一个奇环，如果删除的是奇环和偶环的公共部分的话仍然会有奇环。 那么删除不在任意一个偶环中且在所有奇环中的一条边是否是该问题的充要条件呢？答案是肯定的。轻微玄学，仔细yy若干情况感觉很对 考虑到这里这个问题就有很多做法了，比如比较暴力的做法可以直接树链剖分，对奇环所在的树链和偶环所在的树链打标记。 但这样就完全没有利用无向图的dfs树只有返祖边的这个优良性质，考虑一个简单的差分打标记做法，对于奇环,在y+1,x-1，这样从上到下做一个前缀和就能得到每条边被多少个奇环覆盖，再判断一下有没有被偶环覆盖，做法是相当的 还有一个比较神奇的做法，我们令奇环对应的非树边是坏边，偶环对应的非树边是好边，那么要判断一条边是否被偶环覆盖，我们可以考虑扔掉坏边对剩下的图求一个边双联通分量，如果某一条边是桥的话那么它没有被偶环覆盖，否则被偶环覆盖。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327// 树链剖分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];int ansnum;vector&lt;int&gt; ans;struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntgedge,ntbedge;int fa[10048],fa_ind[10048];bool visited[10048];int num[10048];vector&lt;int&gt; vv[10048];int tot;int dep[10048],depth[10048],sz[10048],son[10048],ffa[10048];int tpos[10048],ind=0,top[10048];int anc[10048][21];void dfs(int cur)&#123; visited[cur]=true; if (!fa[cur]) num[fa_ind[cur]]=++tot; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); num[v[cur][i].y]=++tot; anc[to][0]=cur;dep[to]=dep[cur]+1; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; dfs(to); vv[num[fa_ind[cur]]].pb(num[v[cur][i].y]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; dep[cur]&gt;dep[to]) &#123; if (!((dep[cur]-dep[to])&amp;1)) ntbedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); else ntgedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125; &#125;&#125;void dfs1(int cur,int father)&#123; ffa[cur]=father;sz[cur]=1;son[cur]=0; int i,to,max_size=-1; for (i=0;i&lt;int(vv[cur].size());i++) &#123; to=vv[cur][i];depth[to]=depth[cur]+1; dfs1(to,cur); sz[cur]+=sz[to]; if (sz[to]&gt;max_size) &#123; max_size=sz[to]; son[cur]=to; &#125; &#125;&#125;void dfs2(int cur,int tp)&#123; top[cur]=tp;tpos[cur]=++ind; if (son[cur]) dfs2(son[cur],tp); int i; for (i=0;i&lt;int(vv[cur].size());i++) if (vv[cur][i]!=son[cur]) dfs2(vv[cur][i],vv[cur][i]);&#125;struct node&#123; int left,right; int cnt;&#125;tree_good[40048],tree_bad[40048];void build_good(int cur,int left,int right)&#123; tree_good[cur].left=left;tree_good[cur].right=right;tree_good[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_good(cur&lt;&lt;1,left,mid); build_good(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void build_bad(int cur,int left,int right)&#123; tree_bad[cur].left=left;tree_bad[cur].right=right;tree_bad[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_bad(cur&lt;&lt;1,left,mid); build_bad(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void update_good(int cur,int left,int right)&#123; if (left&lt;=tree_good[cur].left &amp;&amp; tree_good[cur].right&lt;=right) &#123; tree_good[cur].cnt++; return; &#125; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (left&lt;=mid) update_good(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_good(cur&lt;&lt;1|1,left,right);&#125;void update_bad(int cur,int left,int right)&#123; if (left&lt;=tree_bad[cur].left &amp;&amp; tree_bad[cur].right&lt;=right) &#123; tree_bad[cur].cnt++; return; &#125; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (left&lt;=mid) update_bad(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_bad(cur&lt;&lt;1|1,left,right);&#125;int query_good(int cur,int pos)&#123; if (tree_good[cur].left==tree_good[cur].right) return tree_good[cur].cnt; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_good(cur&lt;&lt;1,pos)+tree_good[cur].cnt; else return query_good(cur&lt;&lt;1|1,pos)+tree_good[cur].cnt;&#125;int query_bad(int cur,int pos)&#123; if (tree_bad[cur].left==tree_bad[cur].right) return tree_bad[cur].cnt; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_bad(cur&lt;&lt;1,pos)+tree_bad[cur].cnt; else return query_bad(cur&lt;&lt;1|1,pos)+tree_bad[cur].cnt;&#125;void doit_good(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_good(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_good(1,tpos[v],tpos[u]);&#125;void doit_bad(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_bad(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_bad(1,tpos[v],tpos[u]);&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int getbelow(int u,int v)&#123; int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;dep[v]) u=anc[u][i]; return u;&#125;Pair query_node(int u,int v)&#123; int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return mp(num[fa_ind[u]],num[fa_ind[v]]); if (dep[u]&lt;dep[v]) swap(u,v); int tmp=getbelow(u,v); return mp(num[fa_ind[u]],num[fa_ind[tmp]]);&#125;int main ()&#123; int i,j,cur,x,y;int wei; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); if (i==1) wei=x; edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0;ansnum=0; for (cur=1;cur&lt;=n;cur++) if (!visited[cur]) &#123; for (j=1;j&lt;=tot;j++) vv[j].clear(); tot=0;fa[cur]=fa_ind[cur]=0;dep[cur]=1; tedge.clear();ntgedge.clear();ntbedge.clear(); dfs(cur); depth[cur]=1;dfs1(1,0); ind=0;dfs2(1,1); if (!int(ntbedge.size())) continue; all_cnt++; if (int(ntbedge.size())==1) &#123; ansnum++; ans.pb(ntbedge[0].ind); &#125; build_good(1,1,ind);build_bad(1,1,ind); for (i=0;i&lt;int(ntgedge.size());i++) &#123; Pair res=query_node(ntgedge[i].x,ntgedge[i].y); doit_good(res.x,res.y); &#125; for (i=0;i&lt;int(ntbedge.size());i++) &#123; Pair res=query_node(ntbedge[i].x,ntbedge[i].y); doit_bad(res.x,res.y); &#125; for (i=0;i&lt;int(tedge.size());i++) &#123; if (dep[tedge[i].x]&gt;dep[tedge[i].y]) swap(tedge[i].x,tedge[i].y); if (query_good(1,tpos[num[fa_ind[tedge[i].y]]])==0 &amp;&amp; query_bad(1,tpos[num[fa_ind[tedge[i].y]]])==int(ntbedge.size())) &#123; ansnum++; ans.pb(tedge[i].ind); &#125; &#125; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// 差分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+9;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;bool istree[10048];int L[10048],R[10048];int a[10048],pos[10048],ind;bool visited[10048];int depth[10048];int sum1[10048],sum2[10048];bool col[10048];int node[10048],tot=0;vector&lt;int&gt; ans;int ansnum;bool ins[10048];void dfs(int cur)&#123; node[++tot]=cur; visited[cur]=true; a[++ind]=cur;pos[cur]=ind; L[cur]=ind; int i,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; istree[v[cur][i].y]=true; depth[to]=depth[cur]+1; col[to]=col[cur]^1; dfs(to); &#125; &#125; R[cur]=ind;&#125;int main ()&#123; int i,j,k,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0,cnt; bool hasbaned=false; ansnum=0; for (i=1;i&lt;=n;i++) if (!visited[i]) &#123; cnt=0; depth[i]=1;col[i]=false; ind=0;tot=0; dfs(i); //for (i=1;i&lt;=n;i++) cout&lt;&lt;visited[i]&lt;&lt;' '; //cout&lt;&lt;endl; bool f=false; for (j=1;j&lt;=tot;j++) for (k=0;k&lt;int(v[node[j]].size());k++) &#123; int eind=v[node[j]][k].y; if (depth[edge[eind].x]&gt;depth[edge[eind].y]) swap(edge[eind].x,edge[eind].y); if (!ins[eind]) &#123; ins[eind]=true; if (!istree[eind]) &#123; ntedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); if (col[edge[eind].x]^col[edge[eind].y]) &#123; sum1[pos[edge[eind].x]]--; sum1[pos[edge[eind].y]]++; &#125; else &#123; hasbaned=true;f=true;cnt++; sum2[pos[edge[eind].x]]--; sum2[pos[edge[eind].y]]++; &#125; &#125; else tedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); &#125; &#125; if (f) all_cnt++; if (!cnt) continue; if (cnt==1) &#123; ansnum=1; for (j=0;j&lt;int(ntedge.size());j++) if (!(col[ntedge[j].x]^col[ntedge[j].y])) &#123; ans.pb(ntedge[j].ind); break; &#125; &#125; for (j=1;j&lt;=tot;j++) sum1[j]+=sum1[j-1],sum2[j]+=sum2[j-1]; for (j=0;j&lt;int(tedge.size());j++) if (sum2[R[tedge[j].y]]-sum2[L[tedge[j].y]-1]==cnt &amp;&amp; sum1[R[tedge[j].y]]-sum1[L[tedge[j].y]-1]==0) &#123; ansnum++; ans.pb(tedge[j].ind); &#125; for (i=1;i&lt;=tot;i++) sum1[i]=sum2[i]=0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; if (!hasbaned) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (j=0;j&lt;int(ans.size());j++) printf("%d ",ans[j]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// 边双联通分量#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;int ansnum;vector&lt;int&gt; ans;vector&lt;Pair&gt; v[10048];int dfn[10048],low[10048],ind;int depth[10048],fa[10048],fa_ind[10048];bool iseven[10048];int anc[10048][21];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;Pair edge[10048];void Tarjan(int cur)&#123; dfn[cur]=low[cur]=++ind; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!dfn[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; depth[to]=depth[cur]+1; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); anc[to][0]=cur; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; Tarjan(to); low[cur]=min(low[cur],low[to]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; (depth[cur]-depth[to])&amp;1) low[cur]=min(low[cur],dfn[to]); if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; !((depth[cur]-depth[to])&amp;1)) ntedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125;&#125;int lca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (depth[anc[u][i]]&gt;=depth[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int Low(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return -1; return u;&#125;bool isanc(int u,int v)&#123; if (u==v) return false; return lca(u,v)==u;&#125;int main ()&#123; int i,cur,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; int all_cnt=0,superf=true; for (cur=1;cur&lt;=n;cur++) if (!dfn[cur]) &#123; tedge.clear();ntedge.clear(); fa[cur]=0;ind=0;depth[cur]=1; Tarjan(cur); for (i=0;i&lt;int(tedge.size());i++) &#123; if (depth[tedge[i].x]&gt;depth[tedge[i].y]) swap(edge[i].x,edge[i].y); if (low[tedge[i].y]!=dfn[tedge[i].y]) iseven[tedge[i].ind]=true; &#125; if (int(ntedge.size())) all_cnt++; if (int(ntedge.size())==1) &#123; ansnum++; ans.pb(ntedge[0].ind); &#125; int curu=-2,curv=-2; for (i=0;i&lt;int(ntedge.size());i++) &#123; if (depth[ntedge[i].x]&gt;depth[ntedge[i].y]) swap(ntedge[i].x,ntedge[i].y); if (curu==-2) &#123; curu=ntedge[i].x; curv=ntedge[i].y; continue; &#125; curu=Low(ntedge[i].x,curu); if (curu==-1) &#123; superf=false; break; &#125; curv=lca(ntedge[i].y,curv); if (!isanc(curu,curv)) &#123; superf=false; break; &#125; &#125; if (!superf) break; for (;curv!=curu;curv=fa[curv]) if (!iseven[fa_ind[curv]]) &#123; ansnum++; ans.pb(fa_ind[curv]); &#125; &#125; if (!superf) &#123; printf("0\n"); return 0; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); &#125; return 0;&#125; Solution 2如果你没有yy出那个非常好用的充要条件，我们仍然有一个非常好的基于分治和可撤销并查集的做法。 首先判断一个图是否存在奇环等价于判断一个图是否是二分图，这个有一个喜闻乐见的并查集做法： 对于一个点$i$，令编号为$i$的点表示它是白色，令编号是$n+i$的点表示它是黑色。如果图中有一条边$(u,v)$，那么$u$和$n+v$连边，$n+u$和$v$连边，表示如果一个是黑的另一个一定是白的。最后对于每一个$i$判断$i$和$n+i$是否连通，如果连通说明导出了矛盾，从而原图不是二分图。 现在对于每一条边，我们希望得到删除它之后的并查集，如果暴力的把其他剩余的边加入并查集就是$O(m^2)$的。考虑分治,$solve(l,r)$表示当前我要解决最后删除的边编号在$l$到$r$之间的情况。如果那么流程如下: 如果$l==r$，说明这条边可以删除，返回 令$mid=(l+r)/2$ 将$[mid+1,r]$之间的边加入并查集，如果仍然合法，递归$solve(l,mid)$ 将$[mid+1,r]$之间的边从并查集中撤销 将$[l,mid]$之间的边加入并查集，如果仍然合法，递归$solve(mid+1,r)$ 将$[l,mid]$之间的边从并查集中撤销，返回 注意判断是否合法的时候不需要check所有的点，只需要check当前加入的这些边所相连的点就可以了。 因为这里的并查集要支持撤销，所以只按秩合并不路径压缩，从而总时间复杂度$O(nlog^2n)$ Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;struct Ope&#123; int x,y; bool type;&#125;ope[100048];int tot=0;int pre[20048],rnk[20048];int find_anc(int x)&#123; while (pre[x]!=x) x=pre[x]; return x;&#125;void update(int x,int y)&#123; x=find_anc(x);y=find_anc(y); if (x==y) &#123; ope[++tot]=Ope&#123;x,y,false&#125;; return; &#125; if (rnk[x]&gt;=rnk[y]) &#123; pre[y]=x; ope[++tot]=Ope&#123;x,y,false&#125;; if (rnk[x]==rnk[y]) rnk[x]++,ope[tot].type=true; &#125; else &#123; ope[++tot]=Ope&#123;y,x,false&#125;; pre[x]=y; &#125;&#125;void undo()&#123; int x=ope[tot].x,y=ope[tot].y; pre[y]=y; if (ope[tot].type) rnk[x]--; tot--;&#125;int n,e;Pair edge[10048];int ansnum;vector&lt;int&gt; ans;bool Conflict=false;void Add(int x,int y)&#123; //if (find_anc(x)==find_anc(y+n)) Conflict=true; update(x,y+n); //if (find_anc(x+n)==find_anc(y)) Conflict=true; update(x+n,y); if (find_anc(x)==find_anc(x+n) || find_anc(y)==find_anc(y+n)) Conflict=true;&#125;void solve(int left,int right)&#123; if (left==right) &#123; ansnum++; ans.pb(left); return; &#125; int i,mid=(left+right)&gt;&gt;1; Conflict=false; for (i=left;i&lt;=mid;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(mid+1,right); for (i=left;i&lt;=mid;i++) undo(),undo(); Conflict=false; for (i=mid+1;i&lt;=right;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(left,mid); for (i=mid+1;i&lt;=right;i++) undo(),undo(); Conflict=false;&#125;int main ()&#123; int i; n=getint();e=getint(); if (e==0) &#123; printf("0\n"); return 0; &#125; for (i=1;i&lt;=e;i++) edge[i].x=getint(),edge[i].y=getint(); for (i=1;i&lt;=n*2;i++) pre[i]=i,rnk[i]=1; solve(1,e); printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>并查集</category>
        <category>分治</category>
        <category>可撤销并查集</category>
        <category>dfs树</category>
        <category>Tarjan求边双联通分量</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>分治</tag>
        <tag>可撤销并查集</tag>
        <tag>dfs树</tag>
        <tag>Tarjan求边双联通分量</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #70E: Information Reform 题解]]></title>
    <url>%2Fblog%2Fcf70e%2F</url>
    <content type="text"><![CDATA[DescriptionThought it is already the XXI century, the Mass Media isn’t very popular in Walrusland. The cities get news from messengers who can only travel along roads. The network of roads in Walrusland is built so that it is possible to get to any city from any other one in exactly one way, and the roads’ lengths are equal. The North Pole governor decided to carry out an information reform. Several cities were decided to be chosen and made regional centers. Maintaining a region center takes k fishlars (which is a local currency) per year. It is assumed that a regional center always has information on the latest news. For every city which is not a regional center, it was decided to appoint a regional center which will be responsible for keeping this city informed. In that case the maintenance costs will be equal to dlen fishlars per year, where len is the distance from a city to the corresponding regional center, measured in the number of roads along which one needs to go. Your task is to minimize the costs to carry out the reform. InputThe first line contains two given numbers n and k (1 ≤ n ≤ 180, 1 ≤ k ≤ 105). The second line contains n - 1 integers di, numbered starting with 1 (di ≤ di + 1, 0 ≤ di ≤ 105). Next n - 1 lines contain the pairs of cities connected by a road. OutputOn the first line print the minimum number of fishlars needed for a year’s maintenance. On the second line print n numbers, where the i-th number will represent the number of the regional center, appointed to the i-th city. If the i-th city is a regional center itself, then you should print number i. If there are several solutions to that problem, print any of them. Examplesinput 8 10 2 5 9 11 15 19 20 1 4 1 3 1 7 4 6 2 8 2 3 3 5 output 38 3 3 3 4 3 4 3 3 Solution一道非常神的dp题。 我们可以考虑如下性质：对于任意一棵子树，其中所有被子树外的regional center控制的点，一定都是被同一个regional center控制的，否则如果被多个regional center控制，到子树的根节点最近的regional center一定比其他的优。 考虑如下dp状态：$dp[i][j]$表示考虑以$i$为根的子树，在$j$一定是regional center且$i$被$j$控制的情况下，所有点都被控制的最小花费，其中建立$j$的费用$k$也被计算在内。另外记录$best[i]$表示令$dp[i][j]$取得最小值的$j$。 转移不是非常复杂，考虑$i$的每一个孩子$v$，如果$v$选择和$i$共用一个regional center,则$v$子树的贡献是$dp[v][j]-k$，注意建立$j$的费用在$i$处已经算过了所以要扣除。另外一种情况是$v$没有选择和$i$共用一个regional center，这时$v$子树的贡献是$dp[v][best[v]]$，注意根据上面考虑的性质，$v$选择的regional center必定在$v$子树内才是最优的，所以不用考虑子树$i$向外勾连两个regional center从而导致建立费用算重的情况。更深入的来说,这个dp的转移中有一部分可能是错误的，但只有正确的部分可能是正确答案。 综上，状态转移方程为$dp[i][j]=\sum_{v\in son_i}min(dp[v][best[v]],dp[v][j]-k)$,最终$dp[1][best[1]]$的值就是第一问的答案。 考虑第二问。我们可以倒着考虑$dp[1][best[1]]$的组成，顺着树dfs一遍，每个孩子的$dp[v][j]-k$和$dp[v][best[v]]$比较一下大小就可以得出它是被哪个节点控制的了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=200;int n,k;int dp[MAXN+48][MAXN+48],best[MAXN+48];int d[MAXN+48],dist[MAXN+48][MAXN+48];vector&lt;int&gt; v[MAXN+48];inline void floyd()&#123; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) dist[i][j]=(i==j?0:INF); for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;int(v[i].size());j++) dist[i][v[i][j]]=1; for (register int k=1;k&lt;=n;k++) for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) if (k!=i &amp;&amp; k!=j &amp;&amp; i!=j) check_min(dist[i][j],dist[i][k]+dist[k][j]);&#125;inline void dfs(int cur,int father)&#123; for (register int i=1;i&lt;=n;i++) dp[cur][i]=k+d[dist[cur][i]]; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); for (register int j=1;j&lt;=n;j++) dp[cur][j]+=min(dp[y][j]-k,dp[y][best[y]]); &#125; &#125; best[cur]=1;for (register int i=2;i&lt;=n;i++) if (dp[cur][i]&lt;dp[cur][best[cur]]) best[cur]=i;&#125;int ans[MAXN+48];inline void getans(int cur,int father,int tar)&#123; ans[cur]=tar; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) getans(y,cur,dp[y][tar]-k&lt;=dp[y][best[y]]?tar:best[y]); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);int x,y; for (register int i=1;i&lt;=n-1;i++) io.Get(d[i]); for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; floyd();dfs(1,-1); printf("%d\n",dp[1][best[1]]); getans(1,-1,best[1]); for (register int i=1;i&lt;=n;i++) printf("%d ",ans[i]);printf("\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #275]b 题解]]></title>
    <url>%2Fblog%2Fnflsoj275%2F</url>
    <content type="text"><![CDATA[Description给定一个二分图，统计满足$1\leq x&lt;y\leq n,1\leq a&lt;b\leq m$且$(x,a),(x,b),(y,a),(y,b)$之间均有边的四元组(x,y,a,b)的个数 Constraint $1\leq n,m \leq 200,000,1\leq k \leq min(n*m,300,000)$ Solution考虑根号暴力，对于二分图左边的点，如果出边大于$\sqrt{m}$称之为大点，否则称之为小点。 考虑左边两个小点，两个大点和一小一大两个点三种匹配情况。 对于小点和小点的情况，我们考虑对于每个小点$x$向右边的出边集合，枚举所有可能的$(a,b)$，其中$a&lt;b$,这样我们只要统计右边的每一个点对$(a,b)$被覆盖了多少次即可计算。 这个部分可以无脑的用map做，但会多一个log,考虑一种比较精巧的做法，对于每个点对$(a,b)$,我们在下标为a的vector里面添加b,之后我们统计每个vector内每种相同的数有多少个，再$C_x^2$一下就好了。 接下来考虑左边的两个点中有一个是大点的情况，我们枚举每个大点，将它的出边所到达的右边的点标记为１，然后枚举左边的每一个点，看看当前点的出边所到达的右边的点有多少个被标记了，假设第$i$个点有$x_i$个，那么当前大点的贡献就是$\sum_{i=1}^nC_{x_i}^2$，注意扣除一下重复计算的情况。 计算一下时间复杂度。第二部分的时间复杂度比较容易证明，考虑到大点的个数不会超过$\sqrt m$个，所有大点的出边条数的和是$O(m)$的，所以第二部分的时间复杂度是$O(m\sqrt m)$ 第一部分的时间复杂度比较难算，我们尝试抽象这个问题：有一个整数集合${a_n}$，要求$\sum a_i\leq m$且$\forall a_i\leq \sqrt m$，我们要证明$\sum {a_i}^2$的最大值是$O(m\sqrt m)$级别的。 我们发现如下性质：如果集合${a_i}$中存在两个元素$a_1$,$a_2$满足$a_1,a_2\leq \frac{\sqrt m}{2}$，则删除这两个元素将这两个元素的和放入，目标函数的值一定更大，因为$a^2+b^2&lt;{(a+b)}^2$。所以满足目标函数最大的集合，一定对于$\forall i$有$\frac{\sqrt m}{2}\leq a_i\leq \sqrt m$，所以集合的大小$n\leq 2\sqrt m$，从而$\sum {a_i}^2$是$O(m\sqrt m)$级别的。 综上总时间复杂度$O(m\sqrt m)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=448;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,m,k;bool type[MAXN+48];vector&lt;int&gt; v[MAXN+48];vector&lt;int&gt; ed[MAXN+48];int cnt[MAXN+48];inline LL doit_small()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (!type[i]) &#123; for (register int p1=0;p1&lt;int(v[i].size())-1;p1++) for (register int p2=p1+1;p2&lt;int(v[i].size());p2++) &#123; int v1=v[i][p1],v2=v[i][p2]; if (v1&gt;v2) swap(v1,v2); ed[v1].pb(v2); &#125; &#125; for (register int i=1;i&lt;=m;i++) &#123; for (register int j=0;j&lt;int(ed[i].size());j++) res+=cnt[ed[i][j]],cnt[ed[i][j]]++; for (register int j=0;j&lt;int(ed[i].size());j++) cnt[ed[i][j]]--; &#125; return res;&#125;int mark[MAXN+48];inline LL doit_big()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (type[i]) &#123; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=1; for (register int j=1;j&lt;=n;j++) &#123; if (type[j] &amp;&amp; j&lt;=i) continue; int cnt=0; for (register int p=0;p&lt;int(v[j].size());p++) cnt+=mark[v[j][p]]; res+=1ll*cnt*(cnt-1)/2; &#125; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=0; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("b.in","r",stdin); freopen ("b.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int x,y;io.Get(n);io.Get(m);io.Get(k); for (register int i=1;i&lt;=k;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y); &#125; for (register int i=1;i&lt;=n;i++) if (int(v[i].size())&lt;=magic) type[i]=false; else type[i]=true; printf("%lld\n",doit_small()+doit_big()); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>根号暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces GYM 100518F: Funny Card Game 题解]]></title>
    <url>%2Fblog%2Fgym100518f%2F</url>
    <content type="text"><![CDATA[DescriptionAndrew and his k friends are playing a funny card game. They have a deck of n cards, each one contains a single integer $a_i$ . Andrew is a dealer. His friends are sitting in a circle around him and he deals cards to them. Andrew chooses one of his friends and starts dealing cards to him, one after another. After each card a player can either say “stop”, or say “more”. If the player says “more” he is dealt another card. After he says”stop”, he gets no more cards and his score is equal to the maximal number of times some value occursamong his cards. For example, if the player is dealt cards with values 2, 3, 4, 3, 2, 1, 2 and 5, his score is 3, because 2 occurs 3 times among his cards and no other value has more occurrences. Then the next player who has no cards yet is chosen and Andrew deals cards to him in the same way. The game continues until all but one friends have their cards. The last player gets all the remaining cards. Andrew’s friends has seen the order in which the cards are arranged in the deck. Now they want to choose such strategy that the sum of their scores was maximal possible. Also they want each player to be dealt at least one card. Help them to develop their strategy: for each player from 1 to k − 1 find the card that he must say “stop” after. The last player would receive the rest of the cards. Solution非常不错的dp题 一个复杂度为$O(n^2k)$的dp是非常好想的：考虑dp[i][j]表示当前看到第i张牌，已经划分出j段的最大权值，转移的时候枚举当前人的左端点k，从dp[k-1][j-1]转移来。 考虑优化这个dp,我们可以发现一个非常好的性质：对于dp[i][j]，假如最后一个元素不是第j个人的众数，我们可以直接从dp[i-1][j]转移来，相当于最后给第j个人加一张无用的牌i;假如最后一个元素是第j个人的众数，设a[i]=x,我们可以发现这个人的左端点处的牌一定也是x,因为如果不是x可以把最前面的一段不是x的牌砍掉，当前段众数个数不会变化且前面的答案可以更优。 所以我们可以直接从所有的a[k]=a[i]的k转移来，这个部分可以做一个前缀max优化，我们令maxn[i]表示从1~i所有和a[i]值相同的位置的dp值加上最后的一些a[i]的牌的数量的最大值。预处理每一个位置i之前的一个与它牌值相同的位置pre[i]，则dp[i][j]=max(maxn[pre[i]]+1,1+dp[i-1][j-1])，此时又可以用maxn[pre[i]]和dp[i][j]来更新maxn[i] 总时间复杂度$O(nk)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int k,n;int a[MAXN+48];struct node&#123; int val,from; inline bool operator &lt; (const node &amp;other) const &#123;return val&lt;other.val;&#125;&#125;b[MAXN+48];int pre[MAXN+48],pos[MAXN+48];int dp[101][MAXN+48],maxn[MAXN+48],maxpos[MAXN+48],from[101][MAXN+48];int List[MAXN+48],tot=0;inline void getans(int r,int i)&#123; if (!i) return; List[++tot]=i;getans(r-1,from[r][i]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif freopen ("funny.in","r",stdin); freopen ("funny.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;k) &amp;&amp; n &amp;&amp; k) &#123; for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),b[i].val=a[i],b[i].from=i; sort(b+1,b+n+1);int itot=0; for (register int i=1;i&lt;=n;i++) &#123; if (i==1 || b[i].val!=b[i-1].val) itot++; a[b[i].from]=itot; &#125; for (register int i=1;i&lt;=itot;i++) pos[i]=0; for (register int i=1;i&lt;=n;i++) pre[i]=pos[a[i]],pos[a[i]]=i; for (register int r=1;r&lt;=k;r++) &#123; for (register int i=0;i&lt;=n;i++) maxn[i]=0,maxpos[i]=0;maxn[0]=-INF; for (register int i=1;i&lt;=r-1;i++) dp[r][i]=-INF; for (register int i=r;i&lt;=n;i++) &#123; dp[r][i]=dp[r][i-1];from[r][i]=from[r][i-1]; maxn[i]=maxn[pre[i]]+1;maxpos[i]=maxpos[pre[i]]; if (dp[r-1][i-1]+1&gt;maxn[i]) &#123; maxn[i]=dp[r-1][i-1]+1; maxpos[i]=i-1; &#125; if (maxn[i]&gt;dp[r][i]) dp[r][i]=maxn[i],from[r][i]=maxpos[i]; &#125; &#125; printf("%d\n",dp[k][n]); tot=0;getans(k,n);reverse(List+1,List+k+1); for (register int i=1;i&lt;=k-1;i++) printf("%d ",List[i]); printf("\n"); &#125;#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFLSoj #260: 环 题解]]></title>
    <url>%2Fblog%2Fnflsoj260%2F</url>
    <content type="text"><![CDATA[Description对于一张 n 个点的竞赛图 G，其中 e 条边的方向已经确定，剩下的边朝向是两边等概率的。 求 G 中最小环的期望个数对 1e9+7 取模的结果。 特别地，若 G 无环，则我们认为这种情况下最小环个数为 0。 Input第一行两个数 n,e。 接下来 e 行，每行两个数 x,y 表示一条确定的边。 Output输出一行一个数表示答案。 Sample 1 &amp; 2见下发文件。 Constraints对于 30% 的数据，n≤300。 对于另 20% 的数据，e=0。 对于另 20% 的数据，e=n(n−1)/2。 对于 100% 的数据，1≤n≤1e5，1≤e≤1e6。 Solution竞赛图有这样一个性质：整张图要么是一个DAG，要么存在三元环。因为考虑每一个三元组(i,j,k)，根据抽屉原理三条边至少有两条边是同向的，此时第三条边如果和前两条同向就形成了三元环，否则就是一个DAG。(这里同向指顺时针和逆时针) 于是这题变成了竞赛图三元环计数，有一种线性的做法：考虑容斥，所有的无序三元组(i,j,k)的个数是$C_N^3$，考虑减去那些不是三元环的三元组，我们发现对于一个不是三元环的三元组，有且仅有一个点的度数为2，我们考虑在这种点上统计个数。 我们枚举每一个点，将其出边两两搭配就能得到所有的非三元环情况，注意每个点的n-1条边中有些边确定是出边，设数量为$p$，有些边确定不是出边，还有一些边没有定向，有$\frac{1}{2}$的概率是出边，设数量为$q$，于是一个点的答案是$\frac{p(p-1)}{2}+p\cdot \frac{q}{2}+\frac{q(q-1)}{2}\cdot \frac{1}{4}$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,e;int cnt[MAXN+48],deg[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(e); int x,y; for (register int i=1;i&lt;=e;i++) &#123; io.Get(x);io.Get(y); cnt[x]++;cnt[y]++;deg[x]++; &#125; int i2=quick_pow(2,MOD-2),i8=1ll*i2*i2%MOD*i2%MOD,i6=quick_pow(6,MOD-2); int ans=1ll*n*(n-1)%MOD*(n-2)%MOD*i6%MOD; for (register int i=1;i&lt;=n;i++) &#123; Sub(ans,1ll*deg[i]*(deg[i]-1)%MOD*i2%MOD); int doubt=(n-1)-cnt[i]; Sub(ans,1ll*deg[i]*doubt%MOD*i2%MOD); Sub(ans,1ll*doubt*(doubt-1)%MOD*i8%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>常用技术</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFLSoj #233: 染色 题解]]></title>
    <url>%2Fblog%2Fnflsoj233%2F</url>
    <content type="text"><![CDATA[Problem StatementWXH是天下第一的。一日，他正向众生播撒福音： WXH说——要有树。于是这世上便有了树：一棵n个节点的冒金光的树。 WXH说——要有颜色。于是这树上便有了颜色：n个节点依次从WXH处得到了WXH无私的馈赠—— m种颜色之一。 WXH说——同样的颜色不能靠的太近，也不能太远。于是，所有同色点对距离的最小值介于[L,R]之间的树被留下，而剩余的都被销毁。 WXH发现了一旁的你。WXH对你的无礼感到愤怒，并打算把你做成树的肥料。 你为了证明自己的价值，决定求出WXH一共能够得到多少棵不同的树。 WXH是慈悲的，因而你只要求出这个值对1,000,000,007取模的结果即可。 两棵树是不同的，当且仅当存在至少一个节点得到的颜色不同。 Input第一行四个空格隔开的整数 n,m,L,R,分别表示树的点数WXH的颜色数，以及 WXH钦定的最小值范围。 接下来 n−1行，每行两个空格隔开的整数 u,v，表示这棵冒金光的树上有一条边连接 u 与 v。 Output一行一个整数，表示不同的树的个数对 1,000,000,007取模的结果。 Sample Input3 3 1 2 1 2 2 3 Sample Output21 Sample Explanation除了三个点颜色互不相同的 3!=6种树之外，剩余的 27−6=21 棵树都是可能出现的。 Constraints对于所有数据，1≤n≤1e5，1≤m≤1e9，1&lt;=l,r&lt;=n-1 Subtask 1（15%）：n,m≤5； Subtask 2（10%）：L=R=n−1； Subtask 3（15%）：L=R=1； Subtask 4（20%）：n≤5000； Subtask 5（25%）：L=R； Subtask 6（15%）：无特殊限制。 by diamond_duke PS：由于某天下第一选手被卡常了，本题时限放宽为 1666 ms（std 在最慢的测试点上的运行时间只要约 300 ms）。 PPS：此题数据可能较弱，因此本题开放 hack，请不要恶意 hack。 Solution此题思路略难（逃 首先可以容斥，我们将问题转化成计算（最近点对距离大于等于L的方案数）减去（最近点对距离大于等于R+1的方案数），这样我们只要解决（最近点对距离大于等于x的方案数）这样一个子问题。 考虑最近点对距离大于等于x的这个约束，相当于对于所有距离小于x的点对，这两个点的颜色要求不同。进一步我们发现，对于每个点对只要用深度小的点去约束深度大的点，每个点最终可选的颜色数就是m-约束个数，因为如果有两个点A,B都能约束C，则A,B距离必然小于x，所以A,B的颜色必定不一样。 于是我们可以按照bfs序对原树进行搜索，每搜索到一个点，就查找一下已经被“激活”的点中有多少个和他距离小于x，乘到ans中，再将当前点“激活”即可。 接下来考虑如何计算与当前点距离小于x的点的个数。考虑点分树，即每个重心向以重心为根的所有孩子的子树的重心连边。这样的树的很好的性质是从任意点出发到根的距离都是log级别的。考虑从当前点的重心点出发顺着点分树向上走，每次计算过该重心的路径。从出发点到当前重心有一个距离dis，所以我们要查找当前重心所在树中深度不超过x-dis的点的个数（这个值根据树的深度标号方法可能有一点小出入），这个我们可以对每个重心建一个BIT来维护，但是要注意我们还要减去当前点所在子树的一些不合法的路径，所以还要记录当前点在重心的哪个儿子下面，在这个儿子的BIT里面再算一波。更新的时候就沿着点分树向各个BIT里面插就行了。 时间总复杂度$O(nlog^2n)$，码量略大。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m,L,R;vector&lt;int&gt; v[MAXN+48];int sgn[MAXN*80+48],toc[MAXN+48],tod[MAXN*80+48];int Head[MAXN*80+48],nxt[MAXN*80+48],to[MAXN*80+48],etot=1;inline void addedge(int s,int t) &#123;to[++etot]=t;nxt[etot]=Head[s];Head[s]=etot;&#125;int anc[MAXN+48][21];int depth[MAXN+48];int seq[MAXN*5+48],pos[MAXN*5],stot;inline void dfs_anc(int cur,int father)&#123; seq[++stot]=cur;pos[cur]=stot; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; anc[y][0]=cur; depth[y]=depth[cur]+1;dfs_anc(y,cur); seq[++stot]=cur; &#125; &#125;&#125;int ST[MAXN*5+48][21],Log[MAXN*5+48];inline void init_dist()&#123; depth[1]=1;dfs_anc(1,-1); assert(stot&lt;=MAXN*5); for (register int i=1;i&lt;=stot;i++) ST[i][0]=depth[seq[i]]; for (register int j=1;j&lt;=20;j++) for (register int i=1;i&lt;=stot;i++) &#123; ST[i][j]=ST[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=stot) ST[i][j]=min(ST[i][j],ST[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (register int i=2;i&lt;=stot;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int getlca(int u,int v)&#123; int l=pos[u],r=pos[v]; if (l&gt;r) swap(l,r); int k=Log[r-l+1]; return min(ST[l][k],ST[r-(1&lt;&lt;k)+1][k]);&#125;inline int getdist(int x,int y) &#123;return depth[x]+depth[y]-2*getlca(x,y);&#125;int id=0;namespace BIT&#123; int c[MAXN*80+48]; int starter[MAXN*3+48],len[MAXN*3+48];int tot; inline void clear() &#123;for (register int i=1;i&lt;=tot;i++) c[i]=0;&#125; inline void Create(int ind,int l) &#123; starter[ind]=tot+1;len[ind]=l; tot+=l; &#125; inline void update(int ind,int x,int delta) &#123; x+=starter[ind]-1; int N=starter[ind]+len[ind]-1; while (x&lt;=N) c[x]+=delta,x+=LOWBIT(x); &#125; inline int query(int ind,int x) &#123; int res=0;x+=starter[ind]-1; x=min(x,starter[ind]+len[ind]-1); while (x&gt;=starter[ind]) res+=c[x],x^=LOWBIT(x); return res; &#125; inline int calc(int ind,int left,int right) &#123;return query(ind,right)-query(ind,left-1);&#125;&#125;int sz[MAXN+48];bool visited[MAXN+48];inline void init(int cur,int father)&#123; sz[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y]) init(y,cur),sz[cur]+=sz[y]; &#125;&#125;inline int getroot(int cur,int father,int Sz)&#123; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y] &amp;&amp; sz[y]&gt;Sz/2) return getroot(y,cur,Sz); &#125; return cur;&#125;int q[MAXN+48];int head,tail;inline void doit(int id,int Sz,int Sgn)&#123; sgn[id]=Sgn; BIT::Create(id,Sz);&#125;inline void dfs(int cur,int father)&#123; init(cur,-1); doit(++id,sz[cur],-1);tod[id]=cur; if (father!=-1) addedge(id,father); int rt=getroot(cur,-1,sz[cur]); doit(++id,sz[cur],1);visited[rt]=true;int cid=id;toc[rt]=cid;tod[id]=rt; if (father!=-1) addedge(id,id-1); for (register int i=0;i&lt;int(v[rt].size());i++) &#123; int y=v[rt][i]; if (!visited[y]) dfs(y,cid); &#125;&#125;inline int querygo(int cur,int Len)&#123; int res=0,ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); if (sgn[i]==1) res+=BIT::calc(i,1,Len-dis); else res-=BIT::calc(i,1,Len-dis-2); &#125; return res;&#125;inline void updatego(int cur)&#123; int ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); BIT::update(i,dis+1,1); &#125;&#125;bool vv[MAXN+48];inline int solve(int Len)&#123; head=tail=1;q[head]=1; memset(vv,false,sizeof(vv)); int res=1;BIT::clear(); while (head&lt;=tail) &#123; int x=q[head++];vv[x]=true; res=1ll*res*(m-querygo(toc[x],Len))%MOD; updatego(toc[x]); for (register int i=0;i&lt;int(v[x].size());i++) &#123; int y=v[x][i]; if (!vv[y]) q[++tail]=y; &#125; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);io.Get(L);io.Get(R); int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; init_dist(); dfs(1,-1); io.Print(sub(solve(L)-solve(R+1)),'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;fixed&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>容斥</category>
        <category>BIT</category>
        <category>点分树</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
        <tag>清华集训模拟</tag>
        <tag>点分树</tag>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟赛]number 题解]]></title>
    <url>%2Fblog%2Fnumber%2F</url>
    <content type="text"><![CDATA[Description对于所有长度为$k$的满足$\sum_{i=1}^na_i=n$的不下降数列{$a_k$},其权值为$\sum_{i=1}^na_i^m$，求所有满足条件的数列的权值和。 数据范围: $n,m,k&lt;=4096$ Solution非常好的dp题 这题显然的一个思路是用类似背包的dp,令$dp[i][j][k]$表示当前考虑到第$i$个数，所有数的和是$j$，最大的数是$k$的方案数,转移的时候还要考虑下一个数是多少，所以这个dp是$O(n^4)$的，不能接受。 给出一个比较难想的dp思路:令$dp[i][j]$表示当前数列有$i$个数，和为j的方案数，有两种转移： 所有的数都加1，$dp[i][j]\rightarrow dp[i][j+i]$ 在数列的最前面添加一个1，$dp[i][j]\rightarrow dp[i+1]][j+1]$ 可以发现按照这个dp构造数列的方法，所有的满足条件的数列都能不重不漏的构造出来。 现在我们已经知道了方案数，考虑如何计算最后的权值。我们考虑对于一个数$x$，$dp[k-1][n-x]$对应的是序列中至少有一个$x$的方案数，$dp[k-2][n-2x]$对应的是序列中至少有两个$x$的方案数，以此类推。我们发现一个有$num$个$x$的序列会正好在$num$个“至少”的方案数中出现一次，所以我们只要枚举$x$和$num$，累加$dp[k-num][n-x\cdot num] *x^m$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=4096;int n,k,m;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("number.in","r",stdin); freopen ("number.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);io.Get(m); dp[0][0]=1; for (register int i=0;i&lt;=k-1;i++) for (register int j=0;j&lt;=n;j++) if (dp[i][j]) &#123; Add(dp[i+1][j+1],dp[i][j]); if (j+i&lt;=n) Add(dp[i][j+i],dp[i][j]); &#125; int ans=0; for (register int i=1;i&lt;=n;i++) &#123; int base=quick_pow(i,m); for (register int j=1;j&lt;=k &amp;&amp; i*j&lt;=n;j++) Add(ans,1ll*base*dp[k-j][n-i*j]%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>NOIP模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3636: 教义问答手册 题解]]></title>
    <url>%2Fblog%2Fbzoj3636%2F</url>
    <content type="text"><![CDATA[Description“汉中沃野如关中，四五百里烟蒙蒙。黄云连天夏麦熟，水稻漠漠吹秋风。”——摘自 黄裳《汉中行》 “泉岭精神不朽，汉中诸球永生。”——摘自《泉岭精神创立者语录》 “把神犇烤一烤，味道会更好。”——摘自《xhr语录》 “秀恩爱有利于身心健康！”——摘自《泉岭精神集大成者语录》 “楼上说的对！”——摘自《泉岭精神信徒语录合集》 “不会做积分，怎么找妹子！”——摘自《xhr语录》 “切实保护耕地以放置更多的哨戒炮。”——摘自《泉岭精神信徒语录合集》 “就算两个包子一起吃掉，也不能阻止我修筑梯田。”——摘自《泉岭精神创立者语录》 “我来自泉岭，他来自汉中，我们半道而逢。”——摘自《泉岭精神集大成者语录》 作为泉岭精神的缔造者、信奉者、捍卫者、传承者，Pear决定印制一些教义问答手册，以满足泉岭精神日益增多的信徒。Pear收集了一些有关的诗选、语录，其中部分内容摘录在了【题目背景】里。这些语录是按出现的时间排好序的——Pear很喜欢这样的作风，于是决定在按时间排好序的基础上，选择部分语录，制作成若干本教义问答手册。 一共有N条语录。Pear决定从中选出某一段时间内的所有语录，在此基础上印制大小为L的若干本教义问答手册。Pear对印制的手册有如下要求： 1.每本手册必须包含这个区间内连续的恰好L条语录。 2.不同手册包含的语录不能相同。 3.每条语录有一个“主题相关程度”，这个数可正可负。Pear希望所有手册的语录的“主题相关程度”之和尽可能大。 例如，对于区间[3,15]和L=3，一种选择方法是：[4,6]+[9,11]+[12,14]。这三个区间长度都恰好为L，且互不重叠。 Pear并没有决定选哪段时间的语录，因此他有Q次询问。每次询问，给出两个数[l,r]表示候选语录的范围是第l条到第r条。你能回答出每个询问的最大“主题相关程度”之和么？ Input第一行两个正整数N，L，含义如上所述。注意对于所有询问，L都是一样的。 第二行N个整数，绝对值&lt;=10000。第i个数表示第i条语录的“主题相关程度”。 接下来Q行，每行两个正整数l和r，表示询问区间。 Output输出Q行，每行表示这组询问的答案。注意，这个答案可以是0，如果区间负数过于多的话。 Sample Input15 3 3 1 5 -2 3 -2 -2 2 2 2 0 3 2 -1 0 9 8 10 10 10 9 11 2 14 5 14 5 13 12 13 7 13 2 10 Sample Output6 0 4 17 11 11 0 11 12 HINT【数据范围】 对于10%的数据，N=1000,Q=1000,L&lt;=50 对于另外20%的数据，N=100000,Q=100000,L&lt;=5 对于另外20%的数据，N=100000,Q=100000,L&lt;=10 对于100%的数据，N=100000,Q=100000,L&lt;=50 Source2014年国家集训队十五人互测 Solution这样的题目还是很有启发性的 刚开始看到这样的区间询问，想到的肯定是线段树，但线段树不能只求当前区间的最值，否则无法支持合并。所以我们对每个区间都要维护$L^2$个状态，令$f[x][y]$表示左边$x$个不选，右边$y$个不选的最大值，然后合并两个区间的时候需要枚举跨两边的一个长度为$L$的区间的位置，这样总复杂度是$O(nlognL^3)$，显然是不能通过的。 如果没有$Q$次询问，只是求整个区间的最大选择方案，那我们有一个显然的dp做法：令$dp[i]$表示当前考虑到第$i$个数的最大方案，显然有两种转移：不选这个数，从$dp[i-1]$转移来，或者选这个数所在的一个长度为$L$的区间，从$dp[i-L]+sum(i-L+1,i)$转移来，于是状态转移方程为$$dp[i]=max(dp[i-1],dp[i-L]+sum(i-L+1,i)$$ 如果有多次询问，考虑离线后分治。在$solve(l,r)$的时候，我们只处理跨过该块中间点$(l+r)/2$的区间，完全在左边和完全在右边的区间递归下去处理。 考虑如何处理跨中间的询问，其实处理方法和线段树的区间合并差不多，我们向左向右分别维护$L$个dp状态，$dp1[i][j]$表示从$mid$开始向前的$i$个点没选，从后向前考虑到$j$时的最大方案，$dp2[i][j]$表示从$mid+1$开始向后的$i$个点没选，从前向后考虑到$j$时的最大方案，这两个dp的转移和之前是一样的。然后要么拿两边的max更新，要么枚举跨中间的一个长度为$L$的区间更新，这样复杂度是一个$L$的，因为相当于你在线段树上只求母区间的$f[0][0]$ 分治的总复杂度$O(nlognL)$，可以通过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,L,Q;int a[MAXN+48],sum[MAXN+48];int ans[MAXN+48];inline int calc(int left,int right) &#123;return sum[right]-sum[left-1];&#125;struct Query&#123; int l,r,ind; inline void input() &#123;io.Get(l);io.Get(r);&#125;&#125;q[MAXN+48],tmp1[MAXN+48],tmp2[MAXN+48],tmp3[MAXN+48];int tot1,tot2,tot3;int dp1[51][MAXN+48],dp2[51][MAXN+48];inline void solve(int l,int r,int ql,int qr)&#123; if (l&gt;r) return; if (l==r) &#123; for (register int i=ql;i&lt;=qr;i++) ans[q[i].ind]=((a[l]&gt;=0 &amp;&amp; L&lt;=1)?a[l]:0); return; &#125; int mid=(l+r)&gt;&gt;1;tot1=tot2=tot3=0; for (register int i=ql;i&lt;=qr;i++) &#123; if (q[i].r&lt;=mid) &#123;tmp1[++tot1]=q[i];continue;&#125; if (q[i].l&gt;=mid+1) &#123;tmp2[++tot2]=q[i];continue;&#125; tmp3[++tot3]=q[i]; &#125; int pt=ql,ll=ql+tot1-1,rr=qr-tot2+1; for (register int i=1;i&lt;=tot1;i++) q[pt++]=tmp1[i]; for (register int i=1;i&lt;=tot3;i++) q[pt++]=tmp3[i]; for (register int i=1;i&lt;=tot2;i++) q[pt++]=tmp2[i]; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp1[gap][mid-gap+1]=0; for (register int i=mid-gap;i&gt;=l;i--) &#123; dp1[gap][i]=dp1[gap][i+1]; if (mid-gap-i+1&gt;=L) check_max(dp1[gap][i],dp1[gap][i+L]+calc(i,i+L-1)); &#125; &#125; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp2[gap][mid+gap]=0; for (register int i=mid+1+gap;i&lt;=r;i++) &#123; dp2[gap][i]=dp2[gap][i-1]; if (i-(mid+1+gap)+1&gt;=L) check_max(dp2[gap][i],dp2[gap][i-L]+calc(i-L+1,i)); &#125; &#125; for (register int i=1;i&lt;=tot3;i++) &#123; ans[tmp3[i].ind]=dp1[0][tmp3[i].l]+dp2[0][tmp3[i].r]; for (register int j=mid;j&gt;=mid-(L-1)+1;j--) if (j&gt;=tmp3[i].l &amp;&amp; j+L-1&lt;=tmp3[i].r) check_max(ans[tmp3[i].ind],calc(j,j+L-1)+dp1[mid-j+1][tmp3[i].l]+dp2[j+L-1-(mid+1)+1][tmp3[i].r]); &#125; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid-gap+1;i&gt;=l;i--) dp1[gap][i]=0; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid+gap;i&lt;=r;i++) dp2[gap][i]=0; solve(l,mid,ql,ll);solve(mid+1,r,rr,qr);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(L); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),sum[i]=sum[i-1]+a[i]; io.Get(Q); for (register int i=1;i&lt;=Q;i++) q[i].input(),q[i].ind=i; solve(1,n,1,Q); for (register int i=1;i&lt;=Q;i++) io.Print(ans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>常用技术</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoder SRM198DIV1C: Soma 题解]]></title>
    <url>%2Fblog%2Ftcsrm198div1c%2F</url>
    <content type="text"><![CDATA[DescriptionSoma is a three dimensional puzzle invented by Piet Hein. You have seven pieces which are formed by joining cubes at their faces. (They are all of the non-convex shapes that can be so formed with four or fewer cubes). Six of the pieces are formed from four cubes and one is formed by three cubes. There are 27 cubes total. The pieces can be described by the following arrays which show how high cubes are stacked in each grid cell, and are also shown in the picture below. 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 1 1 0 0 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 2 &nbsp;&nbsp;&nbsp;&nbsp; 2 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 2 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 The pieces can be translated and rotated into any orientation, to build larger shapes, but can not be reflected (as in a mirror) or disassembled. Pieces may touch, but not intersect. Each piece is used exactly once in a solution. Given pattern (a shape composed of 27 cubes, not necessarily connected), try to arrange the seven soma pieces into the same shape as pattern. In other words, you are constructing pattern using the seven pieces. Return the number of distinct solutions for pattern. What is meant by “distinct”: In a valid solution each cube in pattern will be occupied by a cube from exactly one of the seven pieces. You could assign a number between 1 and 7 inclusive to each pattern cube to indicate which piece occupies that pattern cube. Two solutions are distinct if this assignment is different at one or more pattern cubes. Thus removing a piece which has rotational symmetry, rotating it, and putting it back “in the same place” does not produce a new distinct solution. But a rearrangement of some or all of the pieces which is equivalent to rotating or reflecting the entire pattern (assuming pattern has such symmetry) is considered distinct by this definition. For example the pattern, “21112”, can be constructed in exactly two distinct ways using the pieces “211” and “12”. The distinct ways are “211”-“12” and “21”-“112”. The pattern will be specified in a String[] similar to the arrays showing the individual pieces above. Each character indicates how many cubes are stacked at that location, starting from a common plane at a height of zero. For example: {“333”, “333”, “333”} specifies a 3x3x3 cube which is possible to construct with the seven soma pieces in 11520 distinct (as defined above) ways, so return 11520. DefinitionClass: Soma Method: letMeCountTheWays Parameters: String[] Returns: int Method signature: int letMeCountTheWays(String[] pattern) (be sure your method is public) Notes If no rotational symmetries are involved, there are 24 possible orthogonal orientations resulting from rotations in three dimensions. Visualize the 3x2 “L” shaped piece (which has no rotational symmetry). The top (long end) of the “L” can point in six directions x,y,z,-x,-y,-z. For each of those, the short leg of the “L” can point in one of four directions. 6 x 4 = 24 Each of the other six pieces does have some rotational symmetry, and thus fewer possible distinct orientations. The rotation of a point about a line passing through the origin can be calculated using a single, vector by matrix, multiplication: [x y z]*M=[rx ry rz] where M is a 3 by 3 matrix, [x y z] is the original point and [rx ry rz] is the rotated point. Vector by matrix multiplication is defined as: for(i) { r[i]=0 ; for(j) { r[i]+=p[j]*M[j][i] } } where p is the original point and r is the rotated point. The matrix for 90 degree rotation about the x axis is: {&nbsp;{1,0,0},{0,0,1},{0,-1,0}&nbsp;} The matrix for 90 degree rotation about the y axis is: {&nbsp;{0,0,-1},{0,1,0},{1,0,0}&nbsp;} The matrix for 90 degree rotation about the z axis is: {&nbsp;{0,1,0},{-1,0,0},{0,0,1}&nbsp;} The easiest way to generate all possible orthogonal orientations is to rotate about the x axis (0,90,180 or 270 degrees), then about the y axis (0,90,180 or 270 degrees) then about the z axis (0,90,180,270 degrees). That is 64 combinations of rotations (4x4x4). Try all 64 and throw away those that produce duplicate results. Sequences of rotations in three dimensions are non-commutative. The order in which you apply the rotations matters. There are 240 fundamental patterns to form the cube, proven by the great mathematician, Prof. John H. Conway. 240 x 24 rotations x 2 (for mirror reflection) = 11520. There are 96 ways to rotate individual pieces in each of the 11520 “distinct” ways. 11520 x 96 = 1105920 which is the “over a million ways to build a cube” number the manufacturer uses. Constraints pattern will contain between 2 and 27 elements, inclusive. Each element of pattern will consist of between 2 and 27 characters, inclusive. Each element of pattern will have the same number of characters. Each character in each element of pattern will be a digit between ‘0’ and ‘9’ inclusive. The sum of all the digits in pattern will be exactly equal to 27. Examples0) {“333”, “333”, “333”} Returns: 11520 The cube. 1) {“345”, “234”, “123”} Returns: 2800 The crystal. 2) {“3330000”, “0033300”, “0000333”} Returns: 28 The wall. 3) {“21111111”, “21111111”, “21111111”} Returns: 0 The chase lounge, impossible. 4) {“67”, “77”} Returns: 1520 The tower. 5) {“010000000000000000000000000”, “110000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000022”, “000000000000000000000000022”, “000000000000000000000002222”, “000000000000000000000002222”} Returns: 76 Replication. 6) {“11100110001”, “01001100111”, “00000000000”, “20002012011”, “11011001001”} Returns: 1 Disjoint. 7) {“121”, “222”, “121”, “121”, “333”} Returns: 78 The monument. 8) {“020”, “010”, “010”, “020”, “343”, “353”} Returns: 42 The gallows. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution超级大模拟，不仅代码难写，而且搜索的时候还可能超时 首先预处理所有的soma的24种翻转并剔除掉重复的，旋转可以用题面中notes里的矩阵来实现，判断重复可以计算一下两个soma对应点的位移向量，如果全部一样就是相同的soma，只是位置不一样 搜索的时候找第一个没有被覆盖的格子，然后选一个soma往里面放就行 为了避免超时和尽量减少代码量，应该注意：STL处理方便 但是速度慢，内置数组处理较复杂 但是速度快，因此在时间不紧的预处理过程中 尽可能的使用STL模板，在搜索中尽可能使用标准的数组和指针 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n,m;struct Matrix&#123; int b[4][4]; Matrix () &#123;memset(b,0,sizeof(b));&#125; inline void clear() &#123;memset(b,0,sizeof(b));&#125; inline Matrix (int x,int y,int z) &#123;memset(b,0,sizeof(b));b[1][1]=x;b[1][2]=y;b[1][3]=z;&#125; inline void init_I() &#123;for (register int i=1;i&lt;=3;i++) b[i][i]=1;&#125; inline bool operator &lt; (const Matrix &amp;other) const &#123; if (b[1][3]!=other.b[1][3]) return b[1][3]&lt;other.b[1][3]; if (b[1][1]!=other.b[1][1]) return b[1][1]&lt;other.b[1][1]; return b[1][2]&lt;other.b[1][2]; &#125; inline bool operator == (const Matrix &amp;other) const &#123; for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) if (b[i][j]!=other.b[i][j]) return false; return true; &#125; inline Matrix operator + (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]+ma.b[i][j]; return res; &#125; inline Matrix operator - (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]-ma.b[i][j]; return res; &#125; inline Matrix operator * (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) for (register int k=1;k&lt;=3;k++) res.b[i][j]+=b[i][k]*ma.b[k][j]; return res; &#125;&#125;rx,ry,rz;inline Matrix quick_pow(Matrix x,int y)&#123; Matrix res;res.clear();res.init_I(); while (y) &#123; if (y&amp;1) res=res*x; x=x*x;y&gt;&gt;=1; &#125; return res;&#125;typedef vector&lt;Matrix&gt; soma;struct somapos&#123; int x,y,z; somapos () &#123;&#125; inline somapos(int xx,int yy,int zz) &#123;x=xx;y=yy;z=zz;&#125; inline bool operator &lt; (const somapos &amp;other) const &#123; if (z!=other.z) return z&lt;other.z; if (x!=other.x) return x&lt;other.x; return y&lt;other.y; &#125;&#125;P[48];int tot=0;soma base[48];vector&lt;soma&gt; candidate[48];int Cx[48][48][5],Cy[48][48][5],Cz[48][48][5];int ctot[48],wtot[48];inline soma Move(soma ori,Matrix pos,somapos topos)&#123; Matrix delta;delta.clear(); for (register int i=1;i&lt;=3;i++) delta.b[1][i]=-pos.b[1][i]; delta.b[1][1]+=topos.x;delta.b[1][2]+=topos.y;delta.b[1][3]+=topos.z; for (register int i=0;i&lt;int(ori.size());i++) ori[i]=ori[i]+delta; return ori;&#125;inline soma getsoma(soma ori,int dx,int dy,int dz)&#123; for (register int k=0;k&lt;int(ori.size());k++) for (register int i=2;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) assert(ori[k].b[i][j]==0); for (register int i=0;i&lt;int(ori.size());i++) &#123; ori[i]=ori[i]*quick_pow(rx,dx); ori[i]=ori[i]*quick_pow(ry,dy); ori[i]=ori[i]*quick_pow(rz,dz); &#125; sort(ori.begin(),ori.end()); return ori;&#125;inline bool issame(soma x,soma y)&#123; Matrix cmp=x[0]-y[0]; for (register int i=1;i&lt;int(x.size());i++) if (!(x[i]-y[i]==cmp)) return false; return true;&#125;inline void init_soma()&#123; for (register int i=1;i&lt;=7;i++) base[i].clear(),candidate[i].clear(); base[1].pb(Matrix(1,1,1));base[1].pb(Matrix(2,1,1));base[1].pb(Matrix(3,1,1));base[1].pb(Matrix(1,2,1)); base[2].pb(Matrix(1,1,1));base[2].pb(Matrix(2,1,1));base[2].pb(Matrix(3,1,1));base[2].pb(Matrix(2,2,1)); base[3].pb(Matrix(2,1,1));base[3].pb(Matrix(3,1,1));base[3].pb(Matrix(1,2,1));base[3].pb(Matrix(2,2,1)); base[4].pb(Matrix(1,1,1));base[4].pb(Matrix(2,1,1));base[4].pb(Matrix(1,2,1)); base[5].pb(Matrix(2,1,1));base[5].pb(Matrix(2,1,2));base[5].pb(Matrix(1,2,1));base[5].pb(Matrix(2,2,1)); base[6].pb(Matrix(1,1,1));base[6].pb(Matrix(1,1,2));base[6].pb(Matrix(1,2,1));base[6].pb(Matrix(2,2,1)); base[7].pb(Matrix(1,1,1));base[7].pb(Matrix(2,1,1));base[7].pb(Matrix(2,1,2));base[7].pb(Matrix(2,2,1)); rx.clear();ry.clear();rz.clear(); rx.b[1][1]=1;rx.b[2][3]=1;rx.b[3][2]=-1; ry.b[1][3]=-1;ry.b[2][2]=1;ry.b[3][1]=1; rz.b[1][2]=1;rz.b[2][1]=-1;rz.b[3][3]=1; for (register int i=1;i&lt;=7;i++) sort(base[i].begin(),base[i].end()); for (register int i=1;i&lt;=7;i++) for (register int dx=0;dx&lt;=3;dx++) for (register int dy=0;dy&lt;=3;dy++) for (register int dz=0;dz&lt;=3;dz++) &#123; soma ns=getsoma(base[i],dx,dy,dz);bool f=true; for (register int j=0;j&lt;int(candidate[i].size());j++) if (issame(candidate[i][j],ns)) &#123;f=false;break;&#125; if (f) candidate[i].pb(ns); &#125;&#125;bool exist[48][48][48];class Soma&#123; int ans; int a[48][48]; inline int dfs(int used) &#123; int res=0; if (used==127) return 1; int tox,toy,toz; for (register int i=1;i&lt;=27;i++) if (exist[P[i].x][P[i].y][P[i].z]) &#123;tox=P[i].x;toy=P[i].y;toz=P[i].z;break;&#125; for (register int i=1;i&lt;=7;i++) if (!(used&amp;(1&lt;&lt;(i-1)))) &#123; for (register int j=1;j&lt;=ctot[i];j++) &#123; int deltax=tox-Cx[i][j][1],deltay=toy-Cy[i][j][1],deltaz=toz-Cz[i][j][1]; bool valid=true; for (register int k=2;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; if (!exist[xx][yy][zz]) &#123;valid=false;break;&#125; &#125; if (valid) &#123; for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=false; &#125; used|=(1&lt;&lt;(i-1)); res+=dfs(used); for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=true; &#125; used^=(1&lt;&lt;(i-1)); &#125; &#125; &#125; return res; &#125; inline void toarray() &#123; for (register int i=1;i&lt;=7;i++) &#123; ctot[i]=int(candidate[i].size()); wtot[i]=((i==4)?3:4); for (register int j=1;j&lt;=ctot[i];j++) for (register int k=1;k&lt;=wtot[i];k++) &#123; Cx[i][j][k]=candidate[i][j-1][k-1].b[1][1]; Cy[i][j][k]=candidate[i][j-1][k-1].b[1][2]; Cz[i][j][k]=candidate[i][j-1][k-1].b[1][3]; &#125; &#125; &#125; public: inline int letMeCountTheWays(vector&lt;string&gt; pattern) &#123; n=int(pattern.size());m=int(pattern[0].size()); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) a[i][j]=pattern[i-1][j-1]-'0'; init_soma();toarray(); tot=0;memset(exist,false,sizeof(exist)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) for (register int k=1;k&lt;=a[i][j];k++) &#123; P[++tot]=somapos(i,j,k); exist[i][j][k]=true; &#125; sort(P+1,P+tot+1); for (register int i=1;i&lt;=27;i++) ind[P[i].x][P[i].y][P[i].z]=i; return dfs(0); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; int nn;vector&lt;string&gt; vv;string ss; Soma A; while (cin&gt;&gt;nn) &#123; vv.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;ss,vv.pb(ss); double t=clock(); cout&lt;&lt;A.letMeCountTheWays(vv)&lt;&lt;endl; cerr&lt;&lt;"Time: "&lt;&lt;(clock()-t)/CLOCKS_PER_SEC&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>大模拟</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2018模拟赛]money 题解]]></title>
    <url>%2Fblog%2Fmoney%2F</url>
    <content type="text"><![CDATA[Description给定$n$个节点，有$q$次操作: $0$ $a$ $b$ $c$，表示$a$向$b$连一条有向边，并给$a$赋值$c$ $1$ $a$ $b$，如果$b$是$a$的祖先，输出$a$到$b$路径上的权值最小值（包括$a$的权值，不包括$b$的权值） 保证整张图在任意时刻都是一个森林 $n\leq 100000$,$q\leq 1000000$ Solution非常好的思维题 如果整棵树是静态的，我们肯定希望维护祖先和最小值的倍增表，从而在$log$的时间查询 现在是动态的，但我们发现每个点的祖先和最小值倍增表的值只会添加不会删除，因为每个点的祖先是越来越多的，所以我们只要不重复的修改所有节点的祖先和最小值倍增表，最后的时间复杂度就会是数组的大小$O(nlogn)$ 考虑如何实现，我们对当前的每一颗树维护一个deque,deque里的每个节点又是一个单向链表，表示这棵树这一层的所有节点。 在更新祖先和最小值倍增表的过程中，考虑启发式合并，如果$a$所在的树的深度小于$b$所在的树的深度，我们抓着$a$里面的每个点去更新表格，随着深度的增加，更新的$2^k$的祖先的那个$k$也会增加，有点像two pointers；如果$a$所在的树的深度大于$b$所在的树的深度，我们抓着$b$里面的每个节点去找可能能更新到的$a$的节点，这个也是一个类似two pointers的东西。 在合并树的过程中，我们会发现相同深度的点是很好合并的，只要把第一个链表的结尾接上第二个链表的头就行了，这就是我们用链表存储信息的原因。合并的时候也要启发式，不然复杂度不对。 总时间复杂度$O(nlogn+mlogn)$，注意启发式合并的$log$和处理倍增表的$log$不是叠加的，所以不是$log^2n$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;struct List&#123; int bg,ed; List () &#123;&#125; inline List(int b,int e) &#123;bg=b;ed=e;&#125;&#125;;struct node&#123; int nxt;&#125;nodes[MAXN+48];inline List join(List x,List y)&#123; nodes[x.ed].nxt=y.bg; return List(x.bg,y.ed);&#125;int root[MAXN+48];struct tree&#123; vector&lt;List&gt; L,R; int sz,szl,szr; inline void clear() &#123;L.clear();R.clear();sz=szl=szr=0;&#125; inline void push_back(List nw) &#123;R.pb(nw);szr++;sz++;&#125; inline void push_front(List nw) &#123;L.pb(nw);szl++;sz++;&#125; inline List getind(int id) &#123;return (id&lt;=szl)?L[szl-id]:R[id-szl-1];&#125; inline void modify(int id,List nw) &#123; if (id&lt;=szl) L[szl-id]=nw; else R[id-szl-1]=nw; &#125;&#125;tree[MAXN+48];inline void init()&#123; for (register int i=1;i&lt;=n;i++) nodes[i].nxt=0,root[i]=i; for (register int i=1;i&lt;=n;i++) tree[i].clear(),tree[i].pb(List(i,i));&#125;int anc[MAXN+48][21],minn[MAXN+48][21];inline int getdepth(int u)&#123; int res=0; for (register int i=20;i&gt;=0;i--) if (anc[u][i]) res+=(1&lt;&lt;i),u=anc[u][i]; return res+1;&#125;inline int jump(int u,int depth)&#123; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),u=anc[u][i]; return u;&#125;inline int getmin(int u,int depth)&#123; int res=INF; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),res=min(res,minn[u][i]),u=anc[u][i]; return res;&#125;inline int query(int a,int b)&#123; int da=getdepth(a),db=getdepth(b); if (da&lt;=db) return 0; if (jump(a,da-db)!=b) return 0; return getmin(a,da-db);&#125;inline void update(int a,int b,int c)&#123; anc[a][0]=b;minn[a][0]=c; int A=root[a]; int da=tree[A].sz,db=getdepth(b); //update info if (da&lt;=db) &#123; int curdepth=0; for (register int i=1;i&lt;=da;i++) &#123; while ((1&lt;&lt;curdepth)&lt;i) curdepth++; List cur=tree[A].getind(i); for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=i-1+db;j++) for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; else &#123; int curdepth=0; for (register int i=db;i&gt;=1;i--) &#123; while ((1&lt;&lt;curdepth)&lt;(db-i+1)) curdepth++; for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=da-1+(db-i+1);j++) &#123; List cur=tree[A].getind((1&lt;&lt;j)-(db-i+1)+1); for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; &#125; //merge int Root=root[jump(b,db-1)],dep=tree[Root].sz; if (da&lt;=db) &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[Root].getind(i); List need=join(tree[A].getind(j),cur); tree[Root].modify(i,need); &#125; for (register int i=dep-db+1;i&lt;=da;i++) tree[Root].pb(tree[A].getind(i)); tree[A].clear(); &#125; else &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[A].getind(j); List need=join(cur,tree[Root].getind(i)); tree[A].modify(j,need); &#125; for (register int i=db+da+1;i&lt;=dep;i++) tree[A].pb(tree[Root].getind(i)); for (register int i=db;i&gt;=1;i--) tree[A].pf(tree[Root].getind(i)); tree[Root].clear();root[jump(b,db-1)]=A; &#125;&#125;int lastans=0;inline int getreal(int x) &#123;return (x+lastans)%n+1;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("money.in","r",stdin); freopen ("money.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m); init();int op,a,b,c; while (m--) &#123; io.Get(op);io.Get(a);io.Get(b); a=getreal(a);b=getreal(b); if (!op) io.Get(c),c=getreal(c); if (!op) update(a,b,c); else &#123; lastans=query(a,b); printf("%d\n",lastans); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>倍增</category>
        <category>启发式合并</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>倍增</tag>
        <tag>启发式合并</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #8E: Beads 题解]]></title>
    <url>%2Fblog%2Fcf8e%2F</url>
    <content type="text"><![CDATA[DescriptionOne Martian boy called Zorg wants to present a string of beads to his friend from the Earth — Masha. He knows that Masha likes two colours: blue and red, — and right in the shop where he has come, there is a variety of adornments with beads of these two colours. All the strings of beads have a small fastener, and if one unfastens it, one might notice that all the strings of beads in the shop are of the same length. Because of the peculiarities of the Martian eyesight, if Zorg sees one blue-and-red string of beads first, and then the other with red beads instead of blue ones, and blue — instead of red, he regards these two strings of beads as identical. In other words, Zorg regards as identical not only those strings of beads that can be derived from each other by the string turnover, but as well those that can be derived from each other by a mutual replacement of colours and/or by the string turnover. It is known that all Martians are very orderly, and if a Martian sees some amount of objects, he tries to put them in good order. Zorg thinks that a red bead is smaller than a blue one. Let’s put 0 for a red bead, and 1 — for a blue one. From two strings the Martian puts earlier the string with a red bead in the i-th position, providing that the second string has a blue bead in the i-th position, and the first two beads i - 1 are identical. At first Zorg unfastens all the strings of beads, and puts them into small heaps so, that in each heap strings are identical, in his opinion. Then he sorts out the heaps and chooses the minimum string in each heap, in his opinion. He gives the unnecassary strings back to the shop assistant and says he doesn’t need them any more. Then Zorg sorts out the remaining strings of beads and buys the string with index k. All these manupulations will take Zorg a lot of time, that’s why he asks you to help and find the string of beads for Masha. InputThe input file contains two integers n and k (2 ≤ n ≤ 50;1 ≤ k ≤ 1016) —the length of a string of beads, and the index of the string, chosen by Zorg. OutputOutput the k-th string of beads, putting 0 for a red bead, and 1 — for a blue one. If it s impossible to find the required string, output the only number -1. ExamplesInput 4 4 Output 0101 NoteLet’s consider the example of strings of length 4 — 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110. Zorg will divide them into heaps: {0001, 0111, 1000, 1110}, {0010, 0100, 1011, 1101}, {0011, 1100}, {0101, 1010}, {0110, 1001}. Then he will choose the minimum strings of beads in each heap: 0001, 0010, 0011, 0101, 0110. The forth string — 0101. Solution考虑按位确定答案，于是我们要能算出对于一个确定的前缀，有多少个合法的数是以这个前缀开头的。 首先我们可以观察到一个性质：所有的答案的第一位肯定是0，否则它的取反串肯定比他小。在确定了第一位是0之后，我们之后在计算个数的时候就不用考虑取反串和它本身的大小问题了 第二我们可以发现当前串的最后一位如果是0，那么原串的取反串的倒串就肯定比原串小；最后一位如果是1，那么原串的倒串肯定比原串小，所以一旦确定了最后一位，我们就又可以少考虑一种情况。 所以在计算个数的时候，我们先枚举最后一位是0还是1，这样我们自始至终就只要考虑原串和其倒串的大小关系或者是原串和其取反倒串的关系。 先讨论最后一位是0的情况，我们考虑按位枚举后缀，后缀的每一位和前缀的一位相对应。如果前缀的对应位是0，那么后缀的对应位放1就肯定是合法的了，中间可以2的若干次方直接计算答案，当然也可以放0继续和前缀匹配，如果前缀的对应位是1，就只能放1和其匹配。 设当前前缀长度是$len$,我们匹配的总位数是$Len=min(len,n-len)$,全部匹配完之后，我们又要分两种情况讨论： $len\geq \frac{n}{2}$,此时整个串已经完全确定，我们还需要检验一下中间的这些位是否满足条件，这个部分比较简单。 $len&lt;\frac{n}{2}$，此时我们中间还有一些空位要填，考虑如何快速计算有多少种填法符合条件，我们可以发现，如果中间填一个回文串肯定是符合条件的，回文串的个数很好计算，相当于将对应的位打包，个数是$2^{\left \lceil \frac{n-Len-Len}{2}\right \rceil}$。对于不是回文串的串，我们发现一个合法的填法取反肯定是不合法的，一个不合法的填法取反肯定是合法的，所以合法的和不合法的填法一一对应，我们用总填法数减去回文的填法数除以二即可 再讨论最后一位是1的情况，大部分和前面是一样的。我们可以一样的按位和前缀匹配，匹配完了之后$len\geq \frac{n}{2}$的做法也是一样的，但在$len&lt;\frac{n}{2}$的时候，非回文的填法还是那样算，但我们发现回文的填法并不全是合法的，如果$n-Len-Len$是偶数是没有问题的，如果是奇数，我们会发现，最中间的那个单独的一位只能是0不能是1，所以这是回文的合法个数等于回文的总个数除以二。 写起来不长，但很容易错。时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n;LL k;int a[148];LL pw[148];inline LL Count(int len)&#123; int Len=min(len,n-len);LL res=0; //not reverse for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==1) break; if (a[i]==1 &amp;&amp; a[j]==0) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; bool f=true; for (register int i=1;i&lt;=len;i++) if (a[i]) &#123;f=false;break;&#125; if (f) res--; // 000...0 is not allowed if (len==n) return res; //reverse,a[n]=1; for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; if ((n-Len-Len)%2==0) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; p/=2; res+=p+np/2; &#125; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==0) break; if (a[i]==1 &amp;&amp; a[j]==1) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);a[1]=0; pw[0]=1;for (register int i=1;i&lt;=n;i++) pw[i]=pw[i-1]+pw[i-1]; if (Count(1)&lt;k) &#123;printf("-1\n");return 0;&#125; for (register int i=2;i&lt;=n;i++) &#123; a[i]=0; register LL res=Count(i); if (k&gt;res) k-=res,a[i]=1; &#125; for (register int i=1;i&lt;=n;i++) printf("%d",a[i]); printf("\n");#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoder SRM565DIV1C: UnknownTree 题解]]></title>
    <url>%2Fblog%2Ftcsrm565div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given three int[]s: distancesA, distancesB, and distancesC. Each of these int[]s has exactly N elements. We are interested in trees that satisfy the following conditions: The tree has exactly N + 3 vertices. Each vertex has a different label. The set of all labels is { A, B, C, 0, 1, …, N-1 }. Each edge of the tree has a positive integer length. For each i (0 &lt;= i &lt; N), the distance between the vertex A and the vertex i is distancesA[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex B and the vertex i is distancesB[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex C and the vertex i is distancesC[i]. Find the number of trees that satisfy all of the conditions above, and return the number modulo 1,000,000,009. DefinitionClass: UnknownTree Method: getCount Parameters: int[], int[], int[] Returns: int Method signature: int getCount(int[] distancesA, int[] distancesB, int[] distancesC) (be sure your method is public) Notes The distance between two vertices s and t is defined as the sum of lengths of all edges on the only simple path between s and t. Two trees T1 and T2 are different when T1 has an edge u-v such that in T2 the edge u-v is either not present at all, or it has a different length than the edge u-v in T1. Constraints distancesA, distancesB, and distancesC will contain the same number of elements. distancesA, distancesB, and distancesC will contain between 1 and 50 elements, inclusive. Each element of distancesA, distancesB, and distancesC will be between 1 and 100,000,000, inclusive. Examples0) {1} {2} {3} Returns: 6 1) {1, 2} {1, 2} {1, 2} Returns: 1 2) {5, 4} {3, 2} {2, 1} Returns: 8 3) {2, 4, 2} {1, 3, 3} {4, 6, 4} Returns: 2 4) {4, 6, 1, 5, 3, 2, 5} {4, 2, 3, 1, 3, 2, 1} {5, 7, 2, 6, 4, 3, 6} Returns: 12 5) {6, 4, 5, 6, 8, 1, 5, 6, 4, 2} {4, 2, 3, 4, 6, 1, 3, 4, 2, 2} {6, 4, 5, 6, 8, 3, 5, 6, 4, 4} Returns: 9000 6) {8, 5, 6, 8, 6, 5, 6, 10, 8, 5, 10, 8, 7, 9, 7, 1, 11, 5, 9, 6, 6, 1, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 5, 3, 3, 4, 8, 6, 6, 8, 8, 9, 7, 5} {9, 6, 7, 9, 7, 6, 7, 11, 9, 6, 11, 9, 8, 10, 8, 2, 12, 6, 10, 7, 7, 4, 7, 10, 9, 5, 13, 8, 6, 8, 7, 9, 13, 9, 7, 7, 6, 9, 6, 4, 4, 5, 9, 7, 7, 9, 9, 10, 8, 6} {8, 9, 6, 8, 2, 5, 6, 10, 8, 5, 10, 8, 7, 9, 1, 5, 11, 5, 9, 6, 6, 7, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 1, 7, 3, 4, 8, 6, 6, 8, 8, 3, 7, 5} Returns: 770724166 7) {33030780, 30296205, 16842859, 28857842, 37928939, 27190807, 48689043, 33328845, 24254103, 3962046,31043603, 25699520, 11297547, 27045586, 31603483, 23207518, 44089781, 48470539, 52366295, 39786470,45623279, 21593844, 38639305, 27260993, 43899542, 36162768, 21640232, 43580853, 33826577, 30501815,51470990, 2157904, 27823597, 9550575, 39234641, 24163007, 34155133, 42504989, 35821444, 36054200,29026389, 29716374, 41764139, 19392309, 44258194, 19987908, 56722905, 46771885, 32668277, 40665175} {16191697, 13457122, 3776, 12018759, 21089856, 10351724, 31849960, 16489762, 7415020, 12877037,14204520, 8860437, 9035480, 10206503, 14764400, 6368435, 27250698, 31631456, 35527212, 22947387,28784196, 4754761, 21800222, 10421910, 27060459, 19323685, 4801149, 26741770, 16987494, 13662732,34631907, 18996987, 10984514, 7288508, 22395558, 7323924, 17316050, 25665906, 18982361, 19215117,12187306, 12877291, 24925056, 2553226, 27419111, 3148825, 39883822, 29932802, 15829194, 23826092} {19337227, 16602652, 3149306, 15164289, 24235386, 13497254, 34995490, 19635292, 10560550, 16030119,17350050, 12005967, 12188562, 13352033, 17909930, 3215353, 30396228, 34776986, 38672742, 26092917,31929726, 7907843, 24945752, 13567440, 30205989, 22469215, 7946679, 29887300, 20133024, 16808262,37777437, 22150069, 14130044, 10441590, 25541088, 10469454, 20461580, 28811436, 22127891, 22360647,15332836, 16022821, 28070586, 5706308, 30564641, 6294355, 43029352, 33078332, 18974724, 26971622} Returns: 101733071 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution非常好(fan)的分类讨论题 不妨尝试考虑A,B,C三个点在树中的位置关系，发现无外乎两种：Y字型，即三个点在树上有LCA,和链状。 先考虑Y字型，对于一棵树，它可能是Y字型的条件是树上到A,B,C三个点距离之和最小的点是唯一的，这个点就是A,B,C的LCA，设其为root。确定了这个LCA之后，我们就能确定AB,AC,BC三条链的长度：用root-A,root-B,root-C加一加就有。 接下来我们希望找出root-A,root-B,root-C上的所有点，我们可以发现到A和B距离等于AB且到A和C距离等于AC的点在root-A分支上，同理可以确定出root-B和root-C分支，这里要判掉几个不合法的情况：每个点到A/B/C和root都要有距离且同一个分支上的两个点到root的距离必须不同,每个点最多只能存在于一个分支上。 最后我们要确定这个“电风扇”下面挂的点有多少种方案，我们考虑以A为根把树提起来，尝试为每个不在“电风扇”里的点找父亲，父亲应该满足深度比当前点小且当前点与父亲到A/B/C的距离差相等（这个值实际上是当前点和父亲的边的权值），注意不要漏了A,B,C三个点。 再考虑链状，首先应该枚举中间的关键点是哪一个，这样有三种情况，以A为例，考虑确定AB和AC的长度，以AB为例，如果AB之间有其他点，那么这个点集是到A和到B的距离和最小的点的集合；如果AB之间没有点，那么树上所有的关键点到A和到B的距离差的绝对值应该相等，AC也是同理，这样有12种情况，接下来为每个点确定父亲，过程和上面一样。有些要特判的不合法情况也和上面一样。 在实现上，为了简便，可以把Y型的A,B,C分别与root匹配形成三组两个点的情况解决，链状可以把B和C分别和A匹配形成两组两个点的情况，从而节省代码量。 这题主要难在以下几点： 判断每个分支上有哪些点，要能发现距离和，距离差的性质 对不合法情况的特判比较繁琐 对于每个点找到合法父亲的个数，直接累乘就是方案数，这些方案确实都是合法的，但是一下子就看出来可以直接这样计算并不容易。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+9;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;bool visited[148];int distA[148],distB[148],distC[148],n;inline bool cmpA(int x,int y) &#123;return distA[x]&lt;distA[y];&#125;inline bool cmpB(int x,int y) &#123;return distB[x]&lt;distB[y];&#125;inline bool cmpC(int x,int y) &#123;return distC[x]&lt;distC[y];&#125;class UnknownTree&#123; inline bool equ(int x,int y,int z) &#123;return x==y &amp;&amp; x==z;&#125; inline int Y() &#123; int minn=INF,root=-1; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]&lt;minn) minn=distA[i]+distB[i]+distC[i]; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]==minn) &#123;if (root==-1) root=i; else return 0;&#125; int AB=distA[root]+distB[root],AC=distA[root]+distC[root],BC=distB[root]+distC[root]; memset(visited,false,sizeof(visited));visited[root]=true; vector&lt;int&gt; ptA,ptB,ptC;ptA.clear();ptB.clear();ptC.clear(); for (register int i=1;i&lt;=n;i++) &#123; if (i==root) continue; if (distA[i]+distB[i]==AB &amp;&amp; distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distA[i]&gt;=distA[root]) return 0; ptA.pb(i);visited[i]=true; &#125; if (distA[i]+distB[i]==AB &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distB[i]&gt;=distB[root]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distC[i]&gt;=distC[root]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptA.begin(),ptA.end(),cmpA); sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptA.size())-1;i++) if (distA[ptA[i]]==distA[ptA[i+1]]) return 0; for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-BC)) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-BC)) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int calc(int AB,int AC) &#123; if (!AB || !AC) return 0; vector&lt;int&gt; ptB,ptC;ptB.clear();ptC.clear(); memset(visited,false,sizeof(visited)); for (register int i=1;i&lt;=n;i++) &#123; if (distA[i]+distB[i]==AB) &#123; if (visited[i]) return 0; if (distC[i]!=AC+distA[i]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distB[i]!=AB+distA[i]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-(AB+AC))) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-(AB+AC))) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int Line(vector&lt;int&gt; B,vector&lt;int&gt; A,vector&lt;int&gt; C) &#123; for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; vector&lt;int&gt; AB,AC;AB.clear();AC.clear(); int maxn=-INF,minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distB[i])),minn=min(minn,myabs(distA[i]-distB[i])); if (maxn==minn) AB.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distB[i]); AB.pb(minn); maxn=-INF;minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distC[i])),minn=min(minn,myabs(distA[i]-distC[i])); if (maxn==minn) AC.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distC[i]); AC.pb(minn); int res=0; for (auto d1 : AB) for (auto d2 : AC) Add(res,calc(d1,d2)); return res; &#125; public: inline int getCount(vector&lt;int&gt; A,vector&lt;int&gt; B,vector&lt;int&gt; C) &#123; n=int(A.size()); for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; return add(add(add(Y()+Line(B,A,C))+Line(A,B,C))+Line(A,C,B)); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;int&gt; aa,bb,cc;int nn; UnknownTree A; while (cin&gt;&gt;nn) &#123; aa.clear();bb.clear();cc.clear();int x; for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,aa.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,bb.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,cc.pb(x); cout&lt;&lt;A.getcount(aa,bb,cc)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>思维</category>
        <category>分类讨论题</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>TopCoder</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFLSoj #228: 地理课 题解]]></title>
    <url>%2Fblog%2Fnflsoj228%2F</url>
    <content type="text"><![CDATA[Description地理课上，老师给出了一个巨大的地图，由于世界日新月异，会有一些道路在某一时刻被删除，也会有一些道路在某一时刻被修建。这里的道路均为双向的。 老师认为，有一些城市被分在了一个连通块中可以相互到达，而有一些城市不能够相互到达。而他想知道，每个时刻所有连通块大小的乘积是多少？ wzy看到这个地图的时候就蒙了，还好那只上天的喵及时帮助了他。现在他把这个毒瘤的地图拿过来给你，想试试看你能不能求出来。由于答案可能很大，输出乘积mod 1e9+7即可。 Input Format第一行两个数n,m，表示有n个点，m个时刻。接下来mm行每行三个数，要么是1 u v，要么是2 u v，分别表示添加一条无向边和删除一条无向边。 Output Format共m行，每行一个数表示连通块大小乘积mod 1,000,000,007。 Sample Input5 6 1 1 3 1 2 3 1 1 2 1 4 5 1 3 4 2 3 4 Sample Output2 3 3 6 5 6 上面是每个时刻操作后的图。乘积分别为：2×1×1×1=2，3×1×1=3，3×1×1=3，3×2=6，5，3×2=6. Constraints subtask1: 30pts，n≤1,000, m≤2,000n≤1,000, m≤2,000. subtask2: 20pts，满足没有删除操作。 subtask3: 50pts，n,m≤100,000,n,m≤100,000. 保证没有重边自环，不会删除不存在的边。 时间限制2s，空间限制512MB Solution考虑离线做法，对于每条边我们都能确定它存在的时间区间，然后我们在线段树的对应区间上加上这条边 加完之后我们对线段树做dfs,每遍历一个节点，就将这个点上的所有边连到DSU里面，然后向左右继续搜索，这样我们可以确定当我们搜索到叶子时，所有覆盖了这个时刻的边都被加入了DSU，于是可以快速算出答案；在离开一个节点的时候，我们要把这个节点加入的边删掉，于是我们要写一个可撤销的DSU 线段树上所有节点的边数之和是$nlogn$级别，因为要支持撤销，所以DSU中没有路径压缩，只有启发式合并，find_anc也要一个$log$，所以时间复杂度为$O(nlog^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;int fans[MAXN+48];int ans=1;int inv[MAXN+48];inline void init_inv()&#123; inv[0]=inv[1]=1; for (register int i=2;i&lt;=n;i++) inv[i]=MOD-1ll*(MOD/i)*inv[MOD%i]%MOD;&#125;namespace DSU&#123; int pre[MAXN+48],sz[MAXN+48]; int ptx[MAXN*20+48],pty[MAXN*20+48],szx[MAXN*20+48],szy[MAXN*20+48],tot; inline void init() &#123;tot=0;for (register int i=1;i&lt;=n;i++) pre[i]=i,sz[i]=1;&#125; inline int find_anc(int x) &#123;if (pre[x]==x) return x; return find_anc(pre[x]);&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123; x=find_anc(x);y=find_anc(y); if (sz[x]&gt;sz[y]) swap(x,y); ++tot;ptx[tot]=x;pty[tot]=y;szx[tot]=sz[x];szy[tot]=sz[y]; ans=1ll*ans*inv[sz[x]]%MOD;ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=y;sz[y]+=sz[x]; ans=1ll*ans*sz[y]%MOD; &#125; inline void undo() &#123; int x=ptx[tot],y=pty[tot]; ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=x;sz[x]=szx[tot];sz[y]=szy[tot];tot--; ans=1ll*ans*sz[x]%MOD;ans=1ll*ans*sz[y]%MOD; &#125;&#125;namespace SegmentTree&#123; vector&lt;Pair&gt; edge[MAXN*4+48]; inline void init() &#123;for (register int i=1;i&lt;=MAXN*4;i++) edge[i].clear();&#125; inline void update(int cur,int left,int right,Pair curedge,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;edge[cur].pb(curedge);return;&#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,curedge,l,mid); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,curedge,mid+1,r); &#125; inline void dfs(int cur,int l,int r) &#123; int cnt=0; for (register int i=0;i&lt;int(edge[cur].size());i++) if (!DSU::issame(edge[cur][i].x,edge[cur][i].y)) &#123; cnt++; DSU::update(edge[cur][i].x,edge[cur][i].y); &#125; if (l==r) fans[l]=ans; else &#123; int mid=(l+r)&gt;&gt;1; dfs(cur&lt;&lt;1,l,mid);dfs(cur&lt;&lt;1|1,mid+1,r); &#125; while (cnt--) DSU::undo(); &#125;&#125;map&lt;Pair,int&gt; Mp;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int op,x,y; SegmentTree::init();DSU::init();Mp.clear();init_inv(); for (register int i=1;i&lt;=m;i++) &#123; io.Get(op);io.Get(x);io.Get(y); assert(x!=y); if (x&gt;y) swap(x,y); if (op==1) Mp[mp(x,y)]=i; else SegmentTree::update(1,Mp[mp(x,y)],i-1,mp(x,y),1,m),Mp[mp(x,y)]=0; &#125; for (map&lt;Pair,int&gt;::iterator iter=Mp.begin();iter!=Mp.end();iter++) if (iter-&gt;y) SegmentTree::update(1,iter-&gt;y,m,iter-&gt;x,1,m); SegmentTree::dfs(1,1,m); for (register int i=1;i&lt;=m;i++) io.Print(fans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>并查集</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Regular Contest 092F: Two Faced Edges 题解]]></title>
    <url>%2Fblog%2Farc092f%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given a directed graph with N vertices and M edges. The vertices are numbered 1,2,…,N, and the edges are numbered 1,2,…,M. Edge i points from Vertex ai to Vertex bi. For each edge, determine whether the reversion of that edge would change the number of the strongly connected components in the graph. Here, the reversion of Edge i means deleting Edge i and then adding a new edge that points from Vertex bi to Vertex ai. Constraints 2≤N≤1000 1≤M≤200,000 1≤ai,bi≤N ai≠bi If i≠j, then ai≠aj or bi≠bj. InputInput is given from Standard Input in the following format: N M a1 b1 a2 b2 : aM bM OutputPrint M lines. In the i-th line, if the reversion of Edge i would change the number of the strongly connected components in the graph, print diff; if it would not, print same. Sample Input 13 3 1 2 1 3 2 3 Sample Output 1same diff same The number of the strongly connected components is 3 without reversion of edges, but it will become 1 if Edge 2 is reversed. Sample Input 22 2 1 2 2 1 Sample Output 2diff diff Reversion of an edge may result in multiple edges in the graph. Sample Input 35 9 3 2 3 1 4 1 4 2 3 5 5 3 3 4 1 2 2 5 Sample Output 3same same same same same diff diff diff diff Solution朴素的做法是$O(m^2)$的，考虑优化到$O(nm)$ 我们发现翻转一条边$u\rightarrow v$后连通块个数是否改变主要取决于两点： $v$能否到$u$ $u$能否不经过$u\rightarrow v$这条边到达$v$ 稍微计算一下可以发现，如果上面两条都不满足，连通块个数减一，满足其一连通块个数不变，都满足连通块个数加一 我们枚举每个端点$u$，考虑$u$的所有出边，$v$能否到$u$这件事情是比较容易判断的，我们只要将所有边反向，从$u$做一遍dfs,能到的所有的点就是原图中能到$u$的点，这个部分是$O(m)$的 $u$能否不经过$u\rightarrow v$到$v$比较麻烦，考虑如下做法： 我们将$u$所有指向的点$v_1,v_2…v_k$找出来，然后从$v_1$出发做dfs,要求不经过$u$，找出所有能到的点，然后依次考察$v_2,v_3…v_k$，如果能从$v_1$到的话说明要求的路径存在 再从$v_2$出发做相同的事情，对$v_3,v_4…v_k$做考察，以此类推。这样做看似是$O(m^2)$的，但是注意到如果我们搜到一个已经搜过的点，是不用向下继续搜的，因为“前人”一定已经继续向下搜过了，所以只要每次的visited数组不清空，所有点的搜索复杂度总和就是$O(m)$的 以上我们只考虑了从编号小的点出发走到编号大的点的情况，所以还要再反过来做一次，考虑从编号大的点走到编号小的点的情况 这样，每个点的一轮的总复杂度是$O(m)$，一共$n$个点，总时间复杂度$O(nm)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1000;const int MAXM=2e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];vector&lt;int&gt; vv[MAXN+48];bool visited1[MAXN+48],visited2[MAXN+48],ok[MAXN+48];int ans[MAXM+48];inline void dfs1(int cur)&#123; visited1[cur]=true; for (register int i=0;i&lt;int(vv[cur].size());i++) &#123; register int y=vv[cur][i]; if (!visited1[y]) dfs1(y); &#125;&#125;inline void dfs2(int cur)&#123; visited2[cur]=true; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; register int y=v[cur][i].x; if (!visited2[y]) dfs2(y); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int x,y; for (register int i=1;i&lt;=m;i++) &#123; io.Get(x);io.Get(y); v[x].pb(mp(y,i));vv[y].pb(x); &#125; for (register int i=1;i&lt;=n;i++) &#123; memset(visited1,false,sizeof(visited1)); memset(visited2,false,sizeof(visited2)); memset(ok,false,sizeof(ok)); dfs1(i);visited2[i]=true; for (register int j=0;j&lt;int(v[i].size())-1;j++) &#123; dfs2(v[i][j].x); for (register int k=j+1;k&lt;int(v[i].size());k++) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; memset(visited2,false,sizeof(visited2)); visited2[i]=true; for (register int j=int(v[i].size())-1;j&gt;=1;j--) &#123; dfs2(v[i][j].x); for (register int k=j-1;k&gt;=0;k--) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; for (register int j=0;j&lt;int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]); &#125; for (register int i=1;i&lt;=m;i++) printf(ans[i]?"diff\n":"same\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>图论</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoder SRM337DIV1C: CountPalindromes 题解]]></title>
    <url>%2Fblog%2Ftcsrm337div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementA palindrome is a string that reads the same from left to right as it does from right to left, ignoring spaces. We are building a machine that makes the best palindromes in the world and we need you to make a function that calculates the number of possible results before trying it for the first time. You will be given a String[] words and an int k. Each palindrome generated by the machine will be a single space separated list of words, without leading or trailing spaces, that contains at most k characters (including spaces). Each word is an element of words, and each word can be used zero or more times in each palindrome. Return the number of different palindromes that can be generated by the machine modulo 835454957. DefinitionClass: CountPalindromes Method: count Parameters: String[], int Returns: int Method signature: int count(String[] words, int k) (be sure your method is public) Notes Returning the answer modulo 835454957 means that you have to return the remainder of dividing the answer by 835454957. The empty string does not count as a palindrome. Constraints words will contain between 1 and 50 elements, inclusive. Each element of words will contain between 1 and 15 characters, inclusive. Each character of each element of words will be a lowercase letter (‘a’-‘z’). No two elements of words will be equal. k will be between 1 and 100, inclusive. Examples0) {“tragic”,”cigar”} 24 Returns: 1 The only palindrome with no more than 24 characters is “cigar tragic” with 12 characters. “cigar tragic cigar tragic” is also a valid palindrome, but has 25 characters. 1) {“z”,”zz”} 4 Returns: 5 The 5 different palindromes are (quotes for clarity): “z”,”zz”,”z z”,”z zz”,”zz z”. 2) {“aba”,”acaba”,”baca”,”cac”,”b”,”c”,”a”} 70 Returns: 370786966 Remember to return the answer modulo 835454957. 3) {“hello”} 100 Returns: 0 There is no way to make a palindrome. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution考虑dp 从中间向两边dp:设状态$dp[L][i][j][0/1]$，$L$表示当前构造的字符串长度,$0/1$表示当前是左边多出来一截还是右边多出来一截,$i$表示左/右边的最后一个字符串，$j$表示$i$字符串还剩的前缀最后位置/后缀起始位置，$dp[L][i][j][0/1]$里面存个数 转移的时候，我们只要枚举下一个接什么字符串，如果当前是左边多出来就向右边接，如果当前是右边多出来就向左边接，能否拼接可以预处理一下。 要注意的是为了避免算重，当恰好回文的时候，我们应该把状态固定在左边(或右边)，且应该固定向左边(或右边)加串，例如”zz zz”这个串先加左边再加右边和先加右边再加左边是一样的，不能算作两种 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=835454957;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;class CountPalindromes&#123; int n; char s[148][48];int len[148]; bool table_suf[148][48][148],table_pref[148][48][148]; int dp[148][58][21][2]; inline bool judge_evenpalindrome(int id,int pos) &#123; if (pos&lt;=len[id]-pos) &#123; for (register int i=pos;i&gt;=1;i--) if (s[id][i]!=s[id][pos+pos-i+1]) return false; return true; &#125; else &#123; for (register int i=pos+1;i&lt;=len[id];i++) if (s[id][i]!=s[id][pos-(i-(pos+1))]) return false; return true; &#125; &#125; inline bool judge_oddpalindrome(int id,int pos) &#123; if (pos-1&lt;=len[id]-pos) &#123; for (register int l=1,r=pos+pos-1;l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; else &#123; for (register int l=pos-(len[id]-pos),r=len[id];l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; &#125; public: inline int count(vector&lt;string&gt; words,int lim) &#123; n=int(words.size()); for (register int i=1;i&lt;=n;i++) &#123; for (register int j=0;j&lt;int(words[i-1].size());j++) s[i][j+1]=words[i-1][j]; len[i]=int(words[i-1].size());s[i][len[i]+1]='\0'; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i]+1;j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&lt;=min(len[i],j+len[k]-1);p++) if (s[i][p]!=s[k][len[k]-(p-j)]) &#123;f=false;break;&#125; table_suf[i][j][k]=f; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&gt;=max(1,j-len[k]+1);p--) if (s[i][p]!=s[k][j-p+1]) &#123;f=false;break;&#125; table_pref[i][j][k]=f; &#125; // cerr&lt;&lt;table_pref[1][3][1]&lt;&lt;"@"&lt;&lt;endl; memset(dp,0,sizeof(dp)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_evenpalindrome(i,j)) &#123; if (j&lt;len[i]-j) Add(dp[len[i]][i][j*2+1][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2][0],1); &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_oddpalindrome(i,j)) &#123; if (j-1&lt;len[i]-j) Add(dp[len[i]][i][j*2][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2-1][0],1); &#125; for (register int L=1;L&lt;=lim-1;L++) for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) &#123; if (dp[L][i][j][0]) &#123; if (j==0) &#123; for (register int k=1;k&lt;=n;k++) if (L+len[k]+1&lt;=lim) Add(dp[L+len[k]+1][k][len[k]][0],dp[L][i][j][0]); continue; &#125; for (register int k=1;k&lt;=n;k++) if (table_pref[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (j&gt;=len[k]) Add(dp[L+len[k]+1][i][j-len[k]][0],dp[L][i][j][0]); else Add(dp[L+len[k]+1][k][j+1][1],dp[L][i][j][0]); &#125; &#125; if (dp[L][i][j][1]) for (register int k=1;k&lt;=n;k++) if (table_suf[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (len[i]-j+1&gt;len[k]) Add(dp[L+len[k]+1][i][j+len[k]][1],dp[L][i][j][1]); else Add(dp[L+len[k]+1][k][len[k]-(len[i]-j+1)][0],dp[L][i][j][1]); &#125; &#125; int ans=0; for (register int L=1;L&lt;=lim;L++) for (register int i=1;i&lt;=n;i++) Add(ans,dp[L][i][0][0]); return ans; &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;string&gt; ss;string s;CountPalindrome A;int nn,kk; while (cin&gt;&gt;nn&gt;&gt;kk) &#123; ss.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,ss.pb(s); cout&lt;&lt;A.count(ss,kk)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFLSoj #228: 比赛 题解]]></title>
    <url>%2Fblog%2Fnflsoj218%2F</url>
    <content type="text"><![CDATA[Problem statement陈太阳非常喜欢打比赛。 最近有 n 个比赛，陈太阳参加第 i 个比赛能获得的快乐值是 ai，他准备选择某些比赛去虐场。 他选择的比赛的快乐值必须满足快乐值不下降，即如果陈太阳参加了第 $i$,$j$ 个比赛，且 $i&lt;j$，则必须有 $a_i\leq a_j$。 陈太阳如果不去打某个比赛他的心里就会难受，并且不打的时间越长他越难受。如果陈太阳选择不打某个比赛，并且他已经在这之前连续选择不打 x 个比赛了，那他就会损失 x+1 的快乐值。 请你计算陈太阳能获得的快乐值的最大值。注意他可以选择不参加所有比赛。 Input第一行一个整数 n。 接下来一行 n 个整数，表示 ai。 Output输出一个整数，表示答案。 Sample Input 17 1 3 2 7 3 2 4 Sample Output 17 Sample Input 27 -3 -4 -2 -2 -6 -8 -1 Sample Output 2-11 Constraints Subtask 11（30 pts）: 1≤n≤5000,1≤n≤5000； Subtask 22（70 pts）: 1≤n≤100000,1≤n≤100000。 Solution如果我们先不考虑不下降子序列的要求，那么这是一个比较显然的dp+斜率优化，推一波式子： $dp[i]$表示以i结尾的最大收益,有状态转移方程:$$dp[i]=a[i]+\max_{j=1}^{i-1}(dp[j]+\frac{(i-j)(i-j-1)}{2})$$ 考虑决策$j$比决策$k$优的条件：$$dp[j]+\frac{(i-j)(i-j-1)}{2}&lt;dp[k]+\frac{(i-k)(i-k-1)}{2}$$ 化简，按照斜率优化的套路移项，我们有$$i&lt;-\frac{(dp[j]-\frac{j(j+1)}{2})-(dp[k]-\frac{k(k+1)}{2})}{j-k}$$ 考虑到$i$是递增的，我们应该把$(j,dp[j]-\frac{j(j+1)}{2})$看做点，用单调队列维护斜率的相反数的一个下凸壳 然而现在还有一个不下降子序列的要求，相当于转移要在一个二维偏序上进行 考虑cdq分治，定义函数$solve(l,r)$表示我们当前正在计算$l$到$r$的dp状态，刚开始我们将数组按照$a[i]$排序，然后我们预处理每个区间的点按照$id$排序的结果$pos$数组，然后先$solve(l,mid)$(注意这里的区间是按照$a[i]$排序的),接着考虑$l$到$mid$对$mid+1$到$r$的贡献,我们按照$pos$数组从$l$到$r$扫描，如果这个点来自$l$就把它加到下凸壳里面，如果这个点来自$r$就在单调队列里面找一个最优决策点，想想可以发现的确是按照二维偏序进行的更新。 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e5;int n;int a[MAXN+48],id[MAXN+48];int pos[21][MAXN+48];bool isleft[MAXN+48];LL dp[MAXN+48];int q[MAXN+48];inline void mergesort(int l,int r,int d)&#123; if (l==r) &#123;pos[d][l]=id[l];return;&#125; int mid=(l+r)&gt;&gt;1; mergesort(l,mid,d+1);mergesort(mid+1,r,d+1); for (register int k1=l,k2=mid+1,pt=l;k1&lt;=mid || k2&lt;=r;pt++) &#123; if (k1&gt;mid) &#123;pos[d][pt]=pos[d+1][k2++];continue;&#125; if (k2&gt;r) &#123;pos[d][pt]=pos[d+1][k1++];continue;&#125; if (pos[d+1][k1]&lt;pos[d+1][k2]) pos[d][pt]=pos[d+1][k1++]; else pos[d][pt]=pos[d+1][k2++]; &#125;&#125;inline double calc(int id1,int id2)&#123; LL x1=id1,x2=id2,y1=-dp[id1]+1ll*id1*(id1+1)/2,y2=-dp[id2]+1ll*id2*(id2+1)/2; return double(y2-y1)/double(x2-x1);&#125;inline void solve(int l,int r,int d)&#123; if (l==r) &#123;dp[pos[d][l]]+=a[pos[d][l]];return;&#125; int mid=(l+r)&gt;&gt;1,head=1,tail=0; solve(l,mid,d+1); for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=true; for (register int i=l;i&lt;=r;i++) &#123; int cur=pos[d][i]; if (isleft[cur]) &#123; while (head&lt;tail &amp;&amp; calc(q[tail-1],q[tail])&gt;=calc(q[tail],cur)) tail--; q[++tail]=cur; &#125; else &#123; while (head&lt;tail &amp;&amp; calc(q[head],q[head+1])&lt;cur) head++; if (head&lt;=tail) check_max(dp[cur],dp[q[head]]-1ll*(cur-q[head]-1)*(cur-q[head])/2); &#125; &#125; for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=false; solve(mid+1,r,d+1);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),id[i]=i; sort(id+1,id+n+1,[&amp;](const int &amp;x,const int &amp;y) &#123;if (a[x]!=a[y]) return a[x]&lt;a[y];return x&lt;y;&#125;); for (register int i=1;i&lt;=n;i++) dp[i]=-1ll*i*(i-1)/2; mergesort(1,n,1);solve(1,n,1); LL ans=-1ll*n*(n+1)/2; for (register int i=1;i&lt;=n;i++) check_max(ans,dp[i]-1ll*(n-i+1)*(n-i)/2); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>常用技术</category>
        <category>斜率优化</category>
        <category>cdq分治</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NFLSoj</tag>
        <tag>斜率优化</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoder SRM664DIV1A: BearPlays 题解]]></title>
    <url>%2Fblog%2Ftcsrm664div1a%2F</url>
    <content type="text"><![CDATA[Problem StatementLimak is a little bear who loves to play. Today he is playing by moving some stones between two piles of stones. Initially, one of the piles has A and the other has B stones in it. Limak has decided to perform a sequence of K operations. In each operation he will double the size of the currently smaller pile. Formally, if the current pile sizes are labeled X and Y in such a way that X &lt;= Y, he will move X stones from the second pile to the first one. After this move the new pile sizes will be X+X and Y-X. You are given the ints A, B, and K. Determine the pile sizes after Limak finishes all his operations. Return the size of the smaller of those piles. Formally, suppose that the final pile sizes are labeled P and Q in such a way that P &lt;= Q. Return P. DefinitionClass: BearPlays Method: pileSize Parameters: int, int, int Returns: int Method signature: int pileSize(int A, int B, int K)(be sure your method is public) Notes Pay attention to the unusual time limit. Constraints A and B will be between 1 and 1,000,000,000, inclusive. K will be between 1 and 2,000,000,000, inclusive. Examples0) 4 7 2 Returns: 5 The process will look as follows: Initially, the pile sizes are 4 and 7. First operation: Limak doubles the pile of size 4 by moving 4 stones from the other pile to this pile. The new pile sizes are 8 and 3. Second operation: Limak doubles the pile of size 3. The final pile sizes are 5 and 6. As 5 &lt;= 6, the correct return value is 5. 1) 5 5 3 Returns: 0 The initial pile sizes are 5 and 5. In the first operation Limak will double one of them, so after the operation the new pile sizes will be 10 and 0. The second and third operation do nothing: in each of them Limak doubles the size of an empty pile. As 0 ≤ 10, the correct return value is 0. 2) 2 6 1 Returns: 4 After the only operation the pile sizes will be 4 and 4, hence the correct return value is 4. 3) 2 8 2000000000 Returns: 2 4) 900000000 350000000 3 Returns: 300000000 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution数学神思维题 首先的性质是$x+y$的和不会变，设$x+y=n$ 考虑如果当前$x\leq y$,则$x=2x$ 如果当前$x\ge y$,则$x=x-y=2x-(x+y)=2x-n\equiv 2x(mod$ &nbsp; $n)$ 综上，进行$k$轮之后,$x\equiv x*2^k(mod$ &nbsp; $n)$ 所以算出这个，返回$min(x,n-x)$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;class BearPlays&#123; int n; inline int quick_pow(int x,int y) &#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%n,y--; x=(1ll*x*x)%n;y&gt;&gt;=1; &#125; return res; &#125; public: inline int pileSize(int x,int y,int k) &#123; n=x+y; x=(1ll*x*quick_pow(2,k))%n; return min(x,n-x); &#125;&#125;;#ifdef LOCALint main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); BearPlays A; int nn,mm,kk; while (cin&gt;&gt;nn&gt;&gt;mm&gt;&gt;kk) cout&lt;&lt;A.pileSize(nn,mm,kk)&lt;&lt;endl; return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #908G: New Year and Original Order 题解]]></title>
    <url>%2Fblog%2Fcf908g%2F</url>
    <content type="text"><![CDATA[DescriptionLet S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555. Given a number X, compute modulo $10^9 + 7$. InputThe first line of input will contain the integer X ($1$ ≤ $X$ ≤ $10^{700}$). OutputPrint a single integer, the answer to the question. ExamplesInput 21 Output 195 Input 345342 Output 390548434 NoteThe first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. Solution很神的dp题 我们尝试考虑每一位的贡献，也就是要算第i位是j的数有多少个 容易想到一个$O(n^3)$的dp:令$dp[i][j][k][l][cmp]$表示当前考虑到第$i$位，大于等于j的数位有k个，j这个数位有l个，当前数与$n$的大小关系是cmp的情况下有多少种情况，转移只要枚举下一个数是多少即可 这样最后在算答案的时候，把这连续的$l$个$j$统计一下贡献即可 然而这题需要$O(n^2)$的复杂度，考虑优化：我们把上面的dp中$l$的那一维去掉，这样算dp的复杂度是$O(n^2)$的，但你会发现答案不好统计了，因为比如如果你有一串3，中间的那些3无法通过差分得到 于是有这样一个神结论：对于每个$sum=dp[n][j][k][0]+dp[n][j][k][1]$，对答案的贡献是$sum*\underbrace{11…111}_{j个1}$ 下面证这个结论的正确性：我们尝试考虑每个数按数位排好序的那个序列是怎样被计算到的 首先对于最左边的数码$x_1$，显然会有$x_1$个长度为n的dp中会算到这个排列，所以会加$x_1$个$\underbrace{11…111}_{n个1}$，一个很好的性质是，如果有若干个连续的相同数码，在上面的dp中非开头位不会体现在某个状态之中，一起跟着开头的那个数位算掉了 然后我们考虑第二小的数码$x_2$，乍一看感觉它会被算$x_2$次，加上前面的$x_1$次就不对了，但我们注意到$x_2$是比$x_1$大的，所以从不大于$x_1$的数码中对$x_2$这位加的贡献其实都不归当前的这个状态，所以实际上这时$x_2$只被计算了$x_2-x_1$次，加上前面的$x_1$次正好是正确的，以此类推，后面的都是正确的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=700;char s[MAXN+48];int n;int dp[MAXN+48][MAXN+48][10][2],ans[MAXN+48][10];int pw[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); memset(dp,0,sizeof(dp)); for (register int i=0;i&lt;=9;i++) dp[0][0][i][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) for (register int k=0;k&lt;=9;k++) &#123; if (dp[i][j][k][0]) &#123; //to 0 add(dp[i+1][j+(s[i+1]-'0'&gt;=k)][k][0],dp[i][j][k][0]); //to 1 for (register int nxt=0;nxt&lt;=s[i+1]-'0'-1;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][0]); &#125; if (dp[i][j][k][1]) &#123; for (register int nxt=0;nxt&lt;=9;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][1]); &#125; &#125; pw[1]=1; for (register int i=2;i&lt;=n;i++) pw[i]=(1ll*pw[i-1]*10+1)%MOD; int ans=0; for (register int j=0;j&lt;=n;j++) for (register int k=1;k&lt;=9;k++) add(ans,1ll*add(dp[n][j][k][0]+dp[n][j][k][1])*pw[j]%MOD); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Code Festival 2016 Final G: Zigzag MST 题解]]></title>
    <url>%2Fblog%2Fatcoder-codefestival2016finalg%2F</url>
    <content type="text"><![CDATA[Problem StatementWe have a graph with N vertices, numbered 0 through N−1. Edges are yet to be added. We will process Q queries to add edges. In the i-th (1≦i≦Q) query, three integers Ai,Bi and Ci will be given, and we will add infinitely many edges to the graph as follows: The two vertices numbered Ai and Bi will be connected by an edge with a weight of Ci. The two vertices numbered Bi and Ai+1 will be connected by an edge with a weight of Ci+1. The two vertices numbered Ai+1 and Bi+1 will be connected by an edge with a weight of Ci+2. The two vertices numbered Bi+1 and Ai+2 will be connected by an edge with a weight of Ci+3. The two vertices numbered Ai+2 and Bi+2 will be connected by an edge with a weight of Ci+4. The two vertices numbered Bi+2 and Ai+3 will be connected by an edge with a weight of Ci+5. The two vertices numbered Ai+3 and Bi+3 will be connected by an edge with a weight of Ci+6. … Here, consider the indices of the vertices modulo N. For example, the vertice numbered N is the one numbered 0, and the vertice numbered 2N−1 is the one numbered N−1. The figure below shows the first seven edges added when N=16,Ai=7,Bi=14,Ci=1: After processing all the queries, find the total weight of the edges contained in a minimum spanning tree of the graph. Constraints2 ≦ N ≦ 200,000 1 ≦ Q ≦ 200,000 0 ≦ Ai,Bi ≦ N−1 1 ≦ Ci ≦ 1e9 InputThe input is given from Standard Input in the following format: N Q A1 B1 C1 A2 B2 C2 : AQ BQ CQ OutputPrint the total weight of the edges contained in a minimum spanning tree of the graph. Sample Input 17 1 5 2 1 Sample Output 121 The figure below shows the minimum spanning tree of the graph: Note that there can be multiple edges connecting the same pair of vertices. Sample Input 22 1 0 0 1000000000 Sample Output 21000000001 Also note that there can be self-loops. Sample Input 35 3 0 1 10 0 2 10 0 4 10 Sample Output 342 Solution对kruskal算法的灵活运用 我们考虑kruskal算法的精髓，不在于每条边连接的是哪两个点，而在于任意两点之间是否连通 对于每组边，首先我们考虑(Bi,Ai+1),因为(Ai,Bi)的边权比(Bi,Ai+1)小，所以我们一定会先处理(Ai,Bi),如果这条边没加进去，说明Ai和Bi已经连通了，如果这条边加进去了，那么此时Ai和Bi变得连通了，于是我们会发现处理(Bi,Ai+1)时Ai和Bi一定是连通的，所以这是Ai+1这个点我们可以改连到Ai上，把这条边换成(Ai,Ai+1) 依次类推，第二条边(Ai+1,Bi+1),Ai+1,Ai,Bi都是连通的，所以我们可以把Bi+1连到Bi上 最终我们会发现，对于每一组边，我们都是先在Ai和Bi之间连边，然后从Ai和Bi出发顺时针连边，所以我们可以把它拆成三部分：Ai和Bi的横跨边，从Ai出发的链和Bi出发的链 Ai和Bi的横跨边一共只有1e5条，可以不管。对于剩下的链,我们会发现一些很好的性质:如果某一条链当前在连的过程中，发现要连的两个点已经连通了，那么可以立刻停止这条链的连接过程，因为注意到每条链的边权都是公差为2的等差数列，所以已经连起来的那条边属于的链后面的边都会比当前链后面的边的边权小，当前链直接被废掉 因为一共只会向图中连n-1条边，所以直接用堆维护这个过程，复杂度正确 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;int n,m;struct node&#123; int A,B,C; inline void input() &#123;io.Get(A);io.Get(B);io.Get(C);&#125;&#125;a[MAXN+48];inline Pair query(int id,int ti)&#123; if (ti==1) return mp(a[id].A,a[id].B); if ((a[id].A+1)%n==a[id].B &amp;&amp; !(ti&amp;1)) return mp(0,0); if (ti&amp;1) &#123; Pair res=mp(a[id].B+ti/2-1,a[id].B+ti/2); res.x%=n;res.y%=n; return res; &#125; else &#123; Pair res=mp(a[id].A+ti/2-1,a[id].A+ti/2); res.x%=n;res.y%=n; return res; &#125;&#125;namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=0;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;priority_queue&lt;pair&lt;int,pair&lt;Pair,bool&gt; &gt; &gt; q;int main ()&#123; io.Get(n);io.Get(m); for (register int i=1;i&lt;=m;i++) &#123; a[i].input(); q.push(mp(-a[i].C,mp(mp(a[i].A,a[i].B),false))); if (a[i].A+1!=a[i].B) q.push(mp(-a[i].C-1,mp(mp(a[i].A,(a[i].A+1)%n),true))); q.push(mp(-a[i].C-2,mp(mp(a[i].B,(a[i].B+1)%n),true))); &#125; LL ans=0;DSU::init(); for (register int cnt=0;cnt&lt;n-1;) &#123; int len=q.top().x;Pair res=q.top().y.x;bool type=q.top().y.y;q.pop(); if (DSU::issame(res.x,res.y)) continue; cnt++;ans-=len; DSU::update(res.x,res.y); if (type) &#123; res.x=(res.x+1)%n;res.y=(res.y+1)%n; len-=2; q.push(mp(len,mp(res,type))); &#125; &#125; io.Print(ans,'\n'); io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #1045A: Last Chance 题解]]></title>
    <url>%2Fblog%2Fcf1045a%2F</url>
    <content type="text"><![CDATA[DescriptionIt is the year 2969. 1000 years have passed from the moon landing. Meanwhile, the humanity colonized the Hyperspace™ and lived in harmony. Until we realized that we were not alone. Not too far away from the Earth, the massive fleet of aliens’ spaceships is preparing to attack the Earth. For the first time in a while, the humanity is in real danger. Crisis and panic are everywhere. The scientists from all around the solar system have met and discussed the possible solutions. However, no progress has been made. The Earth’s last hope is YOU! Fortunately, the Earth is equipped with very powerful defense systems made by MDCS. There are N aliens’ spaceships which form the line. The defense system consists of three types of weapons: SQL rockets – every SQL rocket can destroy at most one spaceship in the given set. Cognition beams – every Cognition beam has an interval [l,r]and can destroy at most one spaceship in that interval. OMG bazooka – every OMG bazooka has three possible targets, however, each bazooka can destroy either zero or exactly two spaceships. In addition, due to the smart targeting system, the sets of the three possible targets of any two different OMG bazookas are disjoint (that means that every ship is targeted with at most one OMG bazooka). Your task is to make a plan of the attack which will destroy the largest possible number of spaceships. Every destroyed spaceship should be destroyed with exactly one weapon. InputThe first line contains two integers: the number of your weapons N(1≤N≤5000)and the number of spaceships M(1≤M≤5000). In the next N lines, each line starts with one integer that represents type (either 0, 1 or 2). If the type is 0, then the weapon is SQL rocket, the rest of the line contains strictly positive number K(∑K≤100000) and array ki (1≤ki≤M) of K integers. If the type is 1, then the weapon is Cognition beam, the rest of the line contains integers l and r(1≤l≤r≤M). If the type is 2 then the weapon is OMG bazooka, the rest of the line contains distinct numbers a, b and c (1≤a,b,c≤M). OutputThe first line should contain the maximum number of destroyed spaceships —X. In the next X lines, every line should contain two numbers A and B, where A is an index of the weapon and B is an index of the spaceship which was destroyed by the weapon A. Exampleinput3 50 1 42 5 4 11 1 4 output42 13 21 42 5 NoteSQL rocket can destroy only 4th spaceship. OMG Bazooka can destroy two of 1st, 4th or 5th spaceship, and Cognition beam can destroy any spaceship from the interval [1,4]. The maximum number of destroyed spaceship is 4, and one possible plan is that SQL rocket should destroy 4th spaceship, OMG bazooka should destroy 1st and 5th spaceship and Cognition beam should destroy 2nd spaceship. Solution这题的宗旨是你要相信$1e5$的网络流是能跑的，然后你就真的过了（大雾 网络流的模型还是很显然的，考虑对每种武器建一个点，超级源点向这些点连流量为$1$的边（对于第三种武器，连流量为2的边），每个目标建一个点，这些点向超级汇点连流量为$1$的边 考虑三种武器怎么建： 第一种武器比较简单，从武器点向覆盖的集合连流量为1的边即可 第二种武器是区间，一条一条暴力连肯定会爆炸，考虑用线段树优化建边，我们可以把目标想象成线段树的叶子，然后向上垒出一棵线段树，线段树上的每个点向左右孩子连流量为$INF$的边，然后武器点只要像正常线段树一样查询一波，向所有查询到的区间$(left&lt;=l 且 r&lt;=right)$连边即可，这样点数仍然是$O(m)$的，边数是$O(nlogm)的$ 第三种武器，我们发现很难控制一选就要选两个这个条件，但是我们可以好好利用题目中的性质：任意两个第三种武器的集合是不交的。我们可以发现，只要向武器点连流量为2的边，武器点向对应目标连流量为1的边，不加控制答案就是对的，理由如下： 首先如果这条流量为2的边被流满了，那么它肯定选了两个 如果这条流量为2的边没流，那么它肯定不用选 如果这条流量为2的边流了1，首先可以确定的是，它指向的三个点不可能只有一个被选了，否则因为这个点还能流，所以当前的这个流肯定不是最大流。继而我们发现，我们可以直接把它对应的三个点中，任意一个被其他武器“占领”的点强行占为己有，这样带来的影响是，其他某个武器可能会因此变得无用，但最大流跑出的答案肯定是对的 接下来考虑如何构造答案。根据上面所述，第三种武器是要“抢占”别人的目标的，所以先处理掉。然后我们处理第一种武器，注意如果目标已经被第三种占领了就把这个武器直接扔掉。 第二种武器比较烦，因为比较难从残量网络中直接看出每个武器占用了哪个点，我们只能看出这些武器占领的点的总集合，所以我们换用一个贪心的手法来为每个区间分配一个点：考虑将所有的区间按照左端点从小到大排序，然后我们从左到右枚举每一个目标，这时我们要找出那些区间左端点在这个点左边的可能可行的区间，显然这个集合是单调增的，对于这些区间我们把它扔到按右端点从小到大排序的堆里，每次我们找区间右端点在这个点之右且最靠左的区间来覆盖这个点，这样的贪心策略显然是对的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=5e4;const int MAXM=1e6;int n,m,t,ind;int toid[MAXN+48],tonode[MAXN+48];int L[MAXN+48],R[MAXN+48],type[MAXN+48];bool visited[MAXN+48],chosen[MAXN+48];int head[MAXM+48],cur[MAXM+48],to[MAXM+48],nxt[MAXM+48],f[MAXM+48],tot=1;vector&lt;Pair&gt; ans;int seq[MAXN+48],stot;priority_queue&lt;Pair&gt; q;inline bool cmp_l(int x,int y) &#123;return L[x]&lt;L[y];&#125;inline bool cmp_x(Pair x,Pair y) &#123;return x.y&lt;y.y;&#125;namespace flow&#123; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[MAXM+48],Head,Tail,depth[MAXM+48]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; register int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; return depth[t]!=-1; &#125; inline int dfs(int x,int maxf) &#123; if (!maxf || x==t) return maxf; int minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; if (ans&gt;=maxf) break; &#125; &#125; if (!ans) depth[x]=-1; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;namespace SegmentTree&#123; inline void build(int cur,int left,int right) &#123; if (left==right) &#123; ++ind; toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,n+left,INF); return; &#125; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid);build(cur&lt;&lt;1|1,mid+1,right); ++ind;toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,toid[cur&lt;&lt;1],INF); flow::addedge(ind,toid[cur&lt;&lt;1|1],INF); &#125; inline void update(int cur,int left,int right,int l,int r,int id) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; flow::addedge(id,toid[cur],1); return; &#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,l,mid,id); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,mid+1,r,id); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);ind=n+m; SegmentTree::build(1,1,m);int num,x; for (register int i=1;i&lt;=n;i++) &#123; io.Get(type[i]); switch(type[i]) &#123; case 0: &#123; io.Get(num); for (register int j=1;j&lt;=num;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; case 1: &#123; io.Get(L[i]);io.Get(R[i]); SegmentTree::update(1,L[i],R[i],1,m,i); break; &#125; case 2: &#123; for (register int j=1;j&lt;=3;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; &#125; &#125; t=ind+1; for (register int i=1;i&lt;=n;i++) if (type[i]!=2) flow::addedge(0,i,1); else flow::addedge(0,i,2); for (register int i=1;i&lt;=m;i++) flow::addedge(n+i,t,1); io.Print(flow::dinic(),'\n'); for (register int i=1;i&lt;=m;i++) for (register int j=head[n+i];j;j=nxt[j]) if (to[j]==t) &#123; if (!f[j]) chosen[i]=true; break; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i],cnt=0; if (type[y]==2 &amp;&amp; f[i]&lt;2) &#123; for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; if (cnt&lt;2) for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !visited[to[j]-n] &amp;&amp; chosen[to[j]-n]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==0 &amp;&amp; !f[i]) for (register int j=head[y];j;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; if (!visited[to[j]-n]) visited[to[j]-n]=true,ans.pb(mp(y,to[j]-n)); break; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==1 &amp;&amp; !f[i]) seq[++stot]=y; &#125; sort(seq+1,seq+stot+1,cmp_l);int pt=1; for (register int i=1;i&lt;=m;i++) if (chosen[i] &amp;&amp; !visited[i]) &#123; while (pt&lt;=stot &amp;&amp; L[seq[pt]]&lt;=i) q.push(mp(-R[seq[pt]],seq[pt])),pt++; while (!q.empty() &amp;&amp; -q.top().x&lt;i) q.pop(); assert(!q.empty()); ans.pb(mp(q.top().y,i));q.pop(); &#125; sort(ans.begin(),ans.end(),cmp_x); for (auto y : ans) io.Print(y.x,' '),io.Print(y.y,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>网络流</category>
        <category>最大流</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>最大流</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4934: kangaroo 题解]]></title>
    <url>%2Fblog%2Fbzoj4934%2F</url>
    <content type="text"><![CDATA[Description有一个园子，里面有n个草丛排成一排，标号1~n，有一个袋鼠，从s出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达t。显然他会跳跃n-1次为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同，具体地，如果他现在在now,他是从prev跳跃一次到达now的，然后他跳跃一次到达next，那么如果prev&lt;now，就必须有now&lt;next，如果now&lt;prev，就必须有next&lt;now问从s到t的方案数，模1e9+7两个路线不同，当且仅当草丛被访问的顺序不同保证至少有一种方案初始时可以往任意方向跳。 修正下：那么如果prev&lt;now，就必须有next&lt;now,如果now&lt;prev,就必须有now&lt;next Input 一行三个整数，n，s，t 2&lt;=n&lt;=2000 1&lt;=s&lt;=n 1&lt;=t&lt;=n Output一行一个整数，代表答案 Sample Input4 2 3 Sample Output2 Solution最后的序列肯定长成一个不断上下的折线 如果考虑从左到右确定折线，就不免要维护每个数是否已经被选过，无法逃离指数级的算法 考虑把所有的数从小到大往里面放，我们会发现，如果有一个“上扬“的结构，那它的后面肯定不能再接东西了，否则就会形成一个连续三个的”上扬”,从而不符合题意，也就是一个数只能单独成一块，或者连接两个端点“下垂”的块，除非是$S$或$T$才能去形成“上扬”结构 于是dp的思路就很明显了，考虑$dp[i][j]$表示已经将$1～i$扔进了排列，当前形成了$j$个连通块的方案数 考虑$i+1$的方法 单独建一个新连通块,$dp[i][j]\rightarrow dp[i+1][j+1]$ 如果是$S$或$T$，可以选择一个连通块接在它的前面或后面，但要注意除非$S$和$T$等于$n$，$S$不能和$T$在一个联通块中，否则这个图就连不起来了 连接两个连通块，当前有$j$个连通块，所以显然有$j(j-1)$种连法，但要注意$S$所在的连通块前面不能有连通块，所以如果$i+1&gt;=S$要$-=j$，$T$所在的连通块后面不能有连通块，所以如果$i+1&gt;=T$要$-=j$，这样$TS$型连通块会被减两次，所以如果$i+1&gt;=S$且$i+j&gt;=T$要$+1$，还要注意如果$i+1&lt;n$的话$S$不能和$T$连起来，所以还要减一 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=2000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,S,T;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif // io.Get(n);io.Get(S);io.Get(T); scanf("%d%d%d",&amp;n,&amp;S,&amp;T); dp[0][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) if (dp[i][j]) &#123; // cerr&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;dp[i][j]&lt;&lt;endl; //create a new node dp[i+1][j+1]=add(dp[i+1][j+1]+dp[i][j]); //add before a node if (i+1==S) &#123; register int valid=j; if (i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //add after a node if (i+1==T) &#123; register int valid=j; if (i+1&gt;=S &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //connect two nodes if (i+1!=S &amp;&amp; i+1!=T &amp;&amp; j&gt;=2) &#123; register int valid=1ll*j*(j-1)%MOD; if (i+1&gt;=S) valid=sub(valid-(j-1)); //can't connect a node before S if (i+1&gt;=T) valid=sub(valid-(j-1)); //can't connect a node after T if (i+1&gt;=S &amp;&amp; i+1&gt;=T) valid=add(valid+1); //T-S is deleted twice if (i+1&gt;=S &amp;&amp; i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); //S-T is not allowed dp[i+1][j-1]=add(dp[i+1][j-1]+1ll*dp[i][j]*valid%MOD); &#125; &#125; // io.Print(dp[n][1],'\n'); printf("%d\n",dp[n][1]); // io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #992E: Nastya and King-Shamans 题解]]></title>
    <url>%2Fblog%2Fcf992e%2F</url>
    <content type="text"><![CDATA[DescriptionNastya likes reading and even spends whole days in a library sometimes. Today she found a chronicle of Byteland in the library, and it stated that there lived shamans long time ago. It is known that at every moment there was exactly one shaman in Byteland, and there were n shamans in total enumerated with integers from 1 to n in the order they lived. Also, each shaman had a magic power which can now be expressed as an integer. The chronicle includes a list of powers of the n shamans. Also, some shamans can be king-shamans, if they gathered all the power of their predecessors, i.e. their power is exactly the sum of powers of all previous shamans. Nastya is interested in whether there was at least one king-shaman in Byteland. Unfortunately many of the powers are unreadable in the list, so Nastya is doing the following: Initially she supposes some power for each shaman.After that she changes the power of some shaman q times (the shamans can differ) and after that wants to check if there is at least one king-shaman in the list. If yes, she wants to know the index of any king-shaman.Unfortunately the list is too large and Nastya wants you to help her. InputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105). The second line contains n integers a1, …, an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman. After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi. OutputPrint q lines, the i-th of them should contain - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change. If there are multiple king-shamans after each change, print the index of any of them. Examplesinput 2 11 31 2 output -1 input 3 42 2 31 11 22 43 6 output 32-13 input 10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0 output 1-19-14-11 NoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2. In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3. Solution注意到$a[i]=sum[i-1]$的话，那么$sum[i]=2*sum[i-1]$，似乎存在倍增的关系，尝试从这个角度入手 我们对原序列维护线段树，线段树记录区间和&amp;区间最大值,每次单点修改后，我们记录一个初始前缀和cursum，然后在序列中找第一个比cursum大的数a[i]，这个根据我们维护的区间最大值可以线段树二分在log的时间内求出，然后我们验证a[i]是否是king，如果是则结束，否则把cursum更新成sum[i]，从头来过。可以看出因为cursum每次至少乘2，所以最多只会做log(1e9)次，加上每次线段树二分的log，我们可以在$O(nlognlog(1e9))$的时间复杂度解决这个问题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int #define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rlen,wlen; fastio () &#123;rlen=wlen=0;&#125; inline char Getchar() &#123; if (rlen==S) rlen=0,fread(rbuf,1,S,stdin); return rbuf[rlen++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; T res=0;char ch;bool f; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=res; &#125; inline void flush() &#123;fwrite(wbuf,1,wlen,stdout);rlen=0;&#125; inline void Writechar(char ch) &#123; wbuf[wlen++]=ch; if (wlen==S) flush(); &#125; template &lt;class T&gt; inline void Print(T res,char ch) &#123; char s[48];int pt; if (res==0) &#123; pt=1; s[1]='0'; &#125; else &#123; bool f=true;if (res&lt;0) f=false,res=-res; pt=0;while (res) s[++pt]=res%10+'0',res/=10; if (!f) s[++pt]='-'; &#125; while (pt&gt;=1) Writechar(s[pt--]); Writechar(ch); &#125;&#125;io;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct node &#123; int left,right; int maxn;LL sum; &#125;tree[MAXN*4]; inline void pushup(int cur) &#123; tree[cur].maxn=max(tree[cur&lt;&lt;1].maxn,tree[cur&lt;&lt;1|1].maxn); tree[cur].sum=tree[cur&lt;&lt;1].sum+tree[cur&lt;&lt;1|1].sum; &#125; inline void build(int cur,int left,int right) &#123; tree[cur].left=left;tree[cur].right=right; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid); build(cur&lt;&lt;1|1,mid+1,right); pushup(cur); &#125; else &#123; tree[cur].maxn=tree[cur].sum=a[left]; &#125; &#125; inline void update(int cur,int pos,int newval) &#123; if (tree[cur].left==tree[cur].right) &#123; tree[cur].maxn=tree[cur].sum=newval; return; &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (pos&lt;=mid) update(cur&lt;&lt;1,pos,newval); else update(cur&lt;&lt;1|1,pos,newval); pushup(cur); &#125; inline LL querysum(int cur,int left,int right) &#123; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) return tree[cur].sum; LL res=0; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (left&lt;=mid) res+=querysum(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) res+=querysum(cur&lt;&lt;1|1,left,right); return res; &#125; inline int findpos(int cur,int left,int right,LL need) &#123; if (left&gt;right) return -1; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) &#123; if (tree[cur].maxn&lt;need) return -1; if (tree[cur].left==tree[cur].right) return tree[cur].left; if (tree[cur&lt;&lt;1].maxn&gt;=need) return findpos(cur&lt;&lt;1,left,right,need); else return findpos(cur&lt;&lt;1|1,left,right,need); &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; int res=-1; if (left&lt;=mid) res=findpos(cur&lt;&lt;1,left,right,need); if (res!=-1) return res; if (mid+1&lt;=right) res=findpos(cur&lt;&lt;1|1,left,right,need); return res; &#125;&#125;inline int solve()&#123; LL cursum=SegmentTree::querysum(1,1,1);int lastpos=1; if (!cursum) return 1; for (;;) &#123; int pos=SegmentTree::findpos(1,lastpos+1,n,cursum); if (pos==-1) return -1; if (SegmentTree::querysum(1,pos,pos)==SegmentTree::querysum(1,1,pos-1)) return pos; cursum=SegmentTree::querysum(1,1,pos); lastpos=pos; &#125;&#125;int main ()&#123; io.Get(n);io.Get(q); for (register int i=1;i&lt;=n;i++) io.Get(a[i]); SegmentTree::build(1,1,n); while (q--) &#123; register int pos,x; io.Get(pos);io.Get(x); SegmentTree::update(1,pos,x); io.Print(solve(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>线段树</category>
        <category>倍增</category>
        <category>线段树二分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6405: Make ZYB Happy 题解]]></title>
    <url>%2Fblog%2Fhdu6405%2F</url>
    <content type="text"><![CDATA[DescriptionIt’s known to all that ZYB is godlike, so obviously he has a large number of titles, such as jsking, bijingzyb and nbazyb. ZYB likes his titles very much. Each of ZYB’s titles is a string consisting of lower case letters ‘a’-‘z’ associated with a happiness value hi, which shows how much ZYB likes this title. If you say any substring of some title with happiness value x, he will get x happiness points. Moreover, a string may appear in more than one title. In this case, the happiness points ZYB gets are multiplied. If the string you say is not the substring of any of his titles, he gets no happiness point. For example, let’s say ZYB has two titles: zybnb (with happiness value 3) and ybyb (with happiness value 5). If you say y, b or yb, ZYB will get 15 happiness points; if you say z, zy or zyb, ZYB will only get 3 happiness points; if you say ybz or ybac he will get 0 happiness points. One day, you find ZYB pretty sad. As a big fan of ZYB, you want to say a word to ZYB to cheer him up. However, ZYB is really busy, so you can only say no more than m letters. As you haven’t seen ZYB for a long time, you are so excited that you forget what you want to say, so you decide to choose to say a nonempty string no longer than m and only containing ‘a’-‘z’ with equal probability. You want to know the expectations of happiness points you will bring to ZYB for different m. InputThe first line contains an integer n (1≤n≤104), the number of titles ZYB has. The i-th of the next n lines contains a nonempty string ti, which only contains lower case letters ‘a’-‘z’, representing the i-th title. The sum of lengths of all titles does not exceed 3×105. Then follows a line with n integers hi (1≤hi≤106), the happiness value of i-th title. The next line is a single integer Q (1≤Q≤3×105), the number of queries. For the next Q lines, each contains a single integer m (1≤m≤106), meaning that you can say no more than m letters to ZYB. The input data contains only one test case. OutputFor each query, display a single line of integer, representing the answer. It can be proved that the answer can be uniquely written as p/q where p and q are non-negative integers with gcd(p,q)=gcd(q,109+7)=1, and you should display p*q−1mod(109+7), where q−1 means the multiplicative inverse of q modulo 109+7. Sample Input2zybnbybyb3 541234 Sample Output769230776425925929891125950633120399 HintFor the first query, you can bring him 3 happiness points if you say “z” or “n”, and 15 happiness points if you say “y” or “b”; all other strings of length 1 bring no happiness point to ZYB. Therefore, the expectation is (2×3+2×15)/26 = 18/13, and the answer is 18×13^(-1) mod (10^9+7) = 769230776. Source2018 Multi-University Training Contest 8 Solution学习了一下广义后缀自动机 广义后缀自动机其实和普通后缀自动机一模一样，可以把它看做在trie上建立的SAM,实现上只要先建好一个串的SAM,然后后面的串把last置成root再来就可以了，中间不需要任何改动 首先对所有的串建立广义SAM,然后考虑题目的需求，对于广义SAM的每个节点，我们需要计算有多少个串包含它，然后把它们的happy值做累乘，这个的话，只要抓着每个串到SAM里面跑一遍，每跑到一个状态就同时顺着parent树更新所有的祖先，为了保证复杂度，每个节点记一个visited，如果已经被访问过了，那么它的祖先们肯定也都被访问过了，所以可以终止向上，这样保证每个点最多被访问一次，使得复杂度是$O(\sum len)$的 求出每个节点的累乘值后，考虑到每个节点所代表的子串长度都是在$min[i]$到$max[i]$范围内的，所以可以用一个差分数组来维护权值，具体来说，$sum[min[i]]+=\Pi_{happy},sum[max[i]+1]-=\Pi_{happy}$即可，这个数组做一遍前缀和就可以得到对于每种长度，所有可能子串的权值和 最后还要除以每种长度的子串个数，注意到子串是完全随机的，所以总个数显然是$26^{len}$,于是这题就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void getstring(string &amp;s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) s+=string(1,ch); &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=4e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int n,q;string s[MAXN+48];int h[MAXN+48];int sum[MAXN+48],ans[MAXN+48],maxlen;namespace SAM&#123; const int MAXN=1e6; int maxn[MAXN+48],nxt[MAXN+48][27],par[MAXN+48],h[MAXN+48],visited[MAXN+48],root,last,tot; inline void init() &#123;root=last=tot=1;&#125; inline void extend(char ch) &#123; int w=ch-'a'+1,p=last,np=++tot;maxn[np]=maxn[p]+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=++tot;maxn[nq]=maxn[p]+1; memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[q]=par[np]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline void insert(string s) &#123; last=root;int len=int(s.size()); for (register int i=0;i&lt;=len-1;i++) extend(s[i]); &#125; inline void go(string s,int ind,int val) &#123; int pos=root,len=int(s.size()); for (register int i=0;i&lt;len;i++) &#123; pos=nxt[pos][s[i]-'a'+1];int tmp=pos; while (tmp &amp;&amp; visited[tmp]!=ind) &#123; visited[tmp]=ind; //带着编号进去就不用清空visited if (!h[tmp]) h[tmp]=val; else h[tmp]=(1ll*h[tmp]*val)%MOD; tmp=par[tmp]; &#125; &#125; &#125;&#125;int main ()&#123; int i,qlen;io.Get(n);SAM::init(); for (i=1;i&lt;=n;i++) &#123; io.getstring(s[i]); SAM::insert(s[i]); maxlen=max(maxlen,int(s[i].size())); &#125; for (i=1;i&lt;=n;i++) io.Get(h[i]); for (i=1;i&lt;=n;i++) SAM::go(s[i],i,h[i]); for (i=2;i&lt;=SAM::tot;i++) &#123; int L=SAM::maxn[SAM::par[i]]+1,R=SAM::maxn[i]; sum[L]=add(sum[L]+SAM::h[i]);sum[R+1]=sub(sum[R+1]-SAM::h[i]); &#125; int ss=0,cur=1,vv=0; for (i=1;i&lt;=maxlen;i++) &#123; cur=(1ll*cur*26)%MOD; ss=add(ss+cur); sum[i]=add(sum[i]+sum[i-1]); vv=add(vv+sum[i]); ans[i]=1ll*vv*quick_pow(ss,MOD-2)%MOD; &#125; io.Get(q); while (q--) &#123; io.Get(qlen); qlen=min(qlen,maxlen); //注意一下这个细节 io.Print(ans[qlen],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>字符串</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6428: Calculate 题解]]></title>
    <url>%2Fblog%2Fhdu6428%2F</url>
    <content type="text"><![CDATA[DescriptionGiven A, B, C, Calculate $$ \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3)) (mod 2^{30}) $$ Where $\phi (n)$ denotes the number of positive integers ≤ n that are relatively prime to n. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there are three integers A, B, C in one line, as described above. 1 ≤ T ≤ 10, 0 &lt; A, B, C ≤ 10^7 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 2^30. Sample Input496 93 95970 906 89392460 95043 542459760979 8053227 7156842 Sample Output111453628070648388873924623507672 Source2018 Multi-University Training Contest 10 Solution考虑莫比乌斯反演 \begin{split}ans &amp;= \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3))\ &amp;= \sum_{d=1}^A\phi (d)\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=d]\end{split} 令$f(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=n]$ 令$F(n)=\sum_{n\mid d}f(d)$ $gcd(i,j^2,k^3)$是$n$的倍数等价于$i$,$j^2$,$k^3$都是$n$的倍数，所以 $$F(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{d\mid i,d\mid j^2,d\mid k^3} 1$$ 考虑$x\mid y^k$的充要条件，设$x=\Pi_ip_i^{a_i}$,则应满足$\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil} \mid y$ 令$f_k(x)=\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil}$,则 $$F(n)=\left \lfloor \frac{A}{f_1(n)}\right \rfloor \left\lfloor \frac{B}{f_2(n)}\right\rfloor \left\lfloor \frac{C}{f_3(n)} \right\rfloor $$ 根据莫比乌斯反演 $$f(n)=\sum_{n\mid d}F(d)\mu (\frac{d}{n})=\sum_{n\mid d}\left \lfloor \frac{A}{f_1(d)}\right \rfloor \left\lfloor \frac{B}{f_2(d)}\right\rfloor \left\lfloor \frac{C}{f_3(d)} \right\rfloor \mu (\frac{d}{n})$$ 将此式带回$ans$式,有 $$ans=\sum_{d=1}^A\phi (d)f(d)=\sum_{d=1}^A\phi (d)\sum_{d\mid t}\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \mu (\frac{t}{d})$$ 发现$\mu$和$\phi$很像卷积的关系，所以转而枚举$t$,我们有 \begin{split}ans &amp;=\sum_{t=1}^A\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \sum_{d\mid t}\phi (d)\mu (\frac{t}{d})&amp;=\sum_{t=1}^A(\phi \ast \mu)(t)\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor\end{split} 现在只要线性筛出$f_k(n)$和$(\phi \ast \mu)(n)$,$f_k(n)$是积性函数比较显然,对于$(\phi \ast \mu)(n)$是积性函数，下面给出一个简短的证明:证明：考虑$(\phi \ast \mu)(a)和(\phi \ast \mu)(b)$,其中$a$,$b$互质&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(\phi \ast \mu)(a)$可以写成$\sum \phi(x)\mu(y)[xy=a]$的形式，同理$(\phi \ast \mu)(b)$可以写成$\sum \phi(X)\mu(Y)[XY=b]$的形式&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 考虑$(\phi \ast \mu)(a)$和$(\phi \ast \mu)(b)$相乘，拆开括号后，每一项应该都是$\phi(x)\mu(y)\phi(X)\mu(Y)的形式$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为$(a,b)=1$,所以$(x,X)=1,(y,Y)=1$,因为$\phi$和$\mu$都是积性函数，所以上式可以写成$\phi(xX)\mu(yY)$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 注意到$xXyY=ab$,因为$xy$遍历了$a$的所有拆分,$XY$遍历了$b$的所有拆分，所以$xX$和$yY$必然也遍历了$ab$的所有拆分，又因为$(a,b)=1$,所以所有的$xX$必然互不相同,同时所有的$yY$也互不相同&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 所以，当$(a,b)=1$时,$(\phi \ast \mu)(ab)=(\phi \ast \mu)(a)(\phi \ast \mu)(b)$,$(\phi \ast \mu)(n)$是积性函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Q.E.D.$ $f_1(n)$不用筛，我们注意到线性筛有一个非常好的性质，每个数都是被它最小的质因数筛去的，举一个例子，如果有一个数是$2^2\cdot 3^2\cdot 5$,那筛掉它的一定是$2$,剩下的是$2\cdot 3^2\cdot 5$,而$2\cdot 3^2\cdot 5$又是被$2$筛掉的,剩下的是$3^2\cdot 5$…依次类推，我们会发现一个数的相同质因数总是会在一起，所以如果我们对每一个数记录一个$cnt$表示筛掉它的质数现在有几个，在$i%prime[j]==0$的环节$cnt$累加,否则$cnt$置为$1$,然后判断一下$cnt%k$是否为1就能维护$f_k(n)$,具体细节可以看看代码 对于$(\phi \ast \mu)(n)$,首先当n是质数的时候,$(\phi \ast \mu)(n)=\phi (n)\mu (1)+\phi(1) \mu(n)=n-2$,进而当$n=p^k$,其中$p$是质数时,$(\phi \ast \mu)(n)=(\phi \ast \mu)(p^k)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)+\phi(p^{k-2})\mu(p^2)+…+\phi(p)\mu(p^{k-1})+\phi(1)\mu(p^k)$, 根据莫比乌斯函数的定义,后面的$p$的次数大于等于二的项都是0,所以$(\phi \ast \mu)(n)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)=(p^k-p^{k-1})\cdot 1+(p^{k-1}-p^{k-2})\cdot (-1)=p^k-2\cdot p^{k-1}+p^{k-2}$根据这个就足够进行线性筛了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e7;bool isprime[MAXN+48];int prime[MAXN+48],tot;int phi[MAXN+48],mu[MAXN+48],mup[MAXN+48],f2[MAXN+48],f3[MAXN+48];int cnt[MAXN+48],pw[MAXN+48];inline void init()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=mu[1]=mup[1]=f2[1]=f3[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) &#123; prime[++tot]=i; phi[i]=i-1;mu[i]=-1;mup[i]=i-2; f2[i]=f3[i]=i;cnt[i]=1;pw[i]=i; &#125; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]!=0) &#123; phi[i*prime[j]]=phi[i]*(prime[j]-1); mu[i*prime[j]]=-mu[i]; mup[i*prime[j]]=mup[i]*mup[prime[j]]; f2[i*prime[j]]=f2[i]*prime[j]; f3[i*prime[j]]=f3[i]*prime[j]; cnt[i*prime[j]]=1;pw[i*prime[j]]=prime[j]; &#125; else &#123; phi[i*prime[j]]=phi[i]*prime[j]; mu[i*prime[j]]=0;cnt[i*prime[j]]=cnt[i]+1;pw[i*prime[j]]=pw[i]*prime[j]; mup[i*prime[j]]=mup[i/pw[i]]*(pw[i*prime[j]]-2*pw[i*prime[j]]/prime[j]+pw[i*prime[j]]/prime[j]/prime[j]); f2[i*prime[j]]=f2[i]*((cnt[i*prime[j]]%2==1)?prime[j]:1); f3[i*prime[j]]=f3[i]*((cnt[i*prime[j]]%3==1)?prime[j]:1); break; &#125; &#125; &#125;&#125;uint A,B,C;int main ()&#123; int ca;io.Get(ca);init(); while (ca--) &#123; io.Get(A);io.Get(B);io.Get(C); uint ans=0; for (register int i=1;i&lt;=A;i++) ans+=(A/i)*(B/f2[i])*(C/f3[i])*mup[i]; io.Print(ans&amp;((1&lt;&lt;30)-1),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller_Rabin强伪素性测试]]></title>
    <url>%2Fblog%2Fmiller_rabin%2F</url>
    <content type="text"><![CDATA[Miller_Rabin强伪素性测试主要基于下面两个定理 费尔马小定理：若$gcd(a,p)=1$,则$a^{p-1}\equiv 1(mod$ &nbsp; $p)$ 二次探测定理：若p是质数且$a^2\equiv 1(mod$ &nbsp; $p)$,则$a\equiv \pm 1(mod$ &nbsp; $p)$ (对于2给出一个简单的证明: 若$a^2\equiv 1(mod$ &nbsp; $p)$,那么$p\mid a^2-1$,即$p\mid (a+1)(a-1)$,这里我们不讨论$p=2$的情况，因为p是质数，所以p不可能同时整除$a-1$和$a+1$,所以要么$p\mid a-1$,要么$p\mid a+1$,即$a\equiv \pm 1(mod$ &nbsp; $p)$) 也就是说，一旦找到任何一个$a$不满足上述条件，那么$p$一定不是质数 为什么定理1不够用还要定理2呢，因为有一种数叫Carmichael数，它们都是合数，且均满足对于$\forall a$,有$a^{p-1}\equiv 1(mod$ &nbsp; $p)$,这种数在1e8范围内只有255个，但是也足够多了 所以我们考虑下面的方法： 对于$p-1$,把它写成$p-1=2^kt$的形式,其中$p\equiv 1(mod$ &nbsp; $2)$ 随机一个小于p的数a, 快速幂算出$a^t$ 当前数是$a^t$,自乘的结果是$a^{2t}$,再自乘的结果是$a^{2^2t}$,依次类推，自乘k次后这个数就会变成$a^{2^kt}$,即$a^{p-1}$ 在3的过程中，参考上面的两条定理，我们可以得到： 如果最后这个数不等于1，那么p不是质数 如果在某一个时刻，这个数在模$p$意义下等于1,而上一时刻不等于$\pm 1$，那么$p$不是质数 我们称2和3为一次测试，一个数$p$,不是质数且通过一次测试的概率约为25%,所以多随机几次失败的概率就微乎其微]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Miller_Rabin强伪素性测试</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Miller_Rabin强伪素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard_Rho分解质因数]]></title>
    <url>%2Fblog%2Fpollard_rho%2F</url>
    <content type="text"><![CDATA[Pollard_Rho的核心思想大概是两个: 生日攻击理论 假设当前要分解的数$p=a*b$，$a$和$b$很稀有，但是$a$和$b$的倍数却有很多，所以只要找到一个数$c$，使得$gcd(c,p)&gt;1$即可 所以算法大概是这样： 在[2,n-1]之间随机一些数$x_1,x_2…x_k$,$k$大概是$n^{\frac{1}{4}}$级别 判断是否存在$gcd(\mid x_i-x_j\mid ,p)&gt;1$ 但把这些x全部预处理出来的方法太傻了，事实上我们可以先造两个数出来，然后不断地生成伪随机数，pollard告诉我们,$x_{i+1}=(x_i^2+a)%N$是一个非常好的随机函数，这里的$a$是随机的，通常随机一个不会出锅如果真的出锅了就再随机一个 不过这个随机算法有一点问题：这样随机下去之后，$x_i$会重复。如果把所有的$x_i$都存下来然后哈希显然又显得烦了一些，有两种判圈算法可以帮我们在发现入圈之后跳出去 Floyd判圈法：它的核心思想是这样的：假设乌龟和兔子在某种形状的跑道上跑，兔子的速度比乌龟快，那么除了在起点的时刻，如果兔子遇到了乌龟，说明跑道上存在环，套用在pollard_rho上，就是$x_{i+1}=(x_i^2+a)%N$这个函数，准备$x$和$y$两个变量，一个每次做一下，一个每次做两下，模拟乌龟和兔子 Brent判圈法：还是用乌龟和兔子举例子，乌龟不动，兔子每跑一步，就判断一下是否和兔子相遇，一旦兔子跑的步数是2的次幂，就把乌龟移到兔子的位置。这个算法比Floyd要好一些]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Pollard_Rho分解质因数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>讲稿</tag>
        <tag>Pollard_Rho分解质因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6437: Videos 题解]]></title>
    <url>%2Fblog%2Fhdu6437%2F</url>
    <content type="text"><![CDATA[DescriptionC-bacteria takes charge of two kinds of videos: ’The Collection of Silly Games’ and ’The Collection of Horrible Games’. For simplicity’s sake, they will be called as videoA and videoB. There are some people who want to watch videos during today, and they will be happy after watching videos of C-bacteria. There are n hours a day, m videos are going to be show, and the number of people is K. Every video has a type(videoA or videoB), a running time, and the degree of happi- ness after someone watching whole of it. People can watch videos continuous(If one video is running on 2pm to 3pm and another is 3pm to 5pm, people can watch both of them). But each video only allows one person for watching. For a single person, it’s better to watch two kinds to videos alternately, or he will lose W happiness. For example, if the order of video is ’videoA, videoB, videoA, videoB, …’ or ’B, A, B, A, B, …’, he won’t lose happiness; But if the order of video is ’A, B, B, B, A, B, A, A’, he will lose 3W happiness. Now you have to help people to maximization the sum of the degree of happiness. InputMultiple query. On the first line, there is a positive integer T, which describe the number of data. Next there are T groups of data. for each group, the first line have four positive integers n, m, K, W : n hours a day, m videos, K people, lose W happiness when watching same videos).and then, the next m line will describe m videos, four positive integers each line S, T, w, op : video is the begin at S and end at T, the happiness that people can get is w, and op describe it’s tpye(op=0 for videoA and op=1 for videoB). There is a blank line before each groups of data. T&lt;=20, n&lt;=200, m&lt;=200, K&lt;=200, W&lt;=20, 1&lt;=S&lt;T&lt;=n, W&lt;=w&lt;=1000,op=0 or op=1 OutputYour output should include T lines, for each line, output the maximum happiness for the corresponding datum. Sample Input210 3 1 101 5 1000 05 10 1000 13 9 10 010 3 1 101 5 1000 05 10 1000 03 9 10 0 Sample Output20001990 Source2018 Multi-University Training Contest 10 Solution这题一眼网络流 我们可以对每个时刻建点，给每个点一个编号(A/B,1~n)表示上一个看的电影是A/B,当前是第i个小时，把人想象成流量 首先，一个人可以在某一个时刻什么也不干，所以(A,i)应该向(A,i+1)连一条流量为INF,费用为0的边，(B,i)应该向(B,i+1)连一条流量为INF，费用为0的边 每一步电影可以看做一条边，如果是A类型的电影，时刻从a到b,那么(A,a)应该向(B,b)连一条流量为1，费用为val的边，如果是B类型的电影，时刻从a到b,那么(B,a)应该向(A,b)连一条流量为1，费用为val的边，可以看出，这样连边如果看的电影类型交替是没有额外花费的 如果连续看同样的电影会有w的代价，所以(A,i)应该向(B,i)连一条流量为INF,费用为-w的边，同时(B,i)应该向(A,i)连一条流量为INF,费用为-w的边 最后设置源点和汇点，s向(A,1)和(B,1)连流量为INF,费用为0的边，(A,n)和(B,n)向t连流量为INF，费用为0的边 最后只要跑流量为k的最小费用流即可，最后要把答案取反 因为一开始就有负权边，所以有两种解决方案： 先跑一遍spfa，再跑带势的dijkstra 先把负权边流满，重新构图再跑费用流 考场上懒直接按1做了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=1e8;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=10000;int n,m,k,w;namespace flow&#123; int head[200048],nxt[200048],to[200048],f[200048],w[200048],tot=1,t; inline void addedge(int s,int t,int l,int cost) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=l;w[tot]=cost; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;w[tot]=-cost; &#125; int prevv[200048],preve[200048]; int h[200048]; priority_queue&lt;Pair&gt; q;int dist[200048]; inline void init() &#123; t=n*2+2; for (register int i=0;i&lt;=t;i++) head[i]=0; for (register int i=0;i&lt;=t;i++) h[i]=0; tot=1; &#125; bool dijkstra() &#123; int i,x,y,dd; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;q.push(mp(0,t)); while (!q.empty()) &#123; x=q.top().y;dd=-q.top().x;q.pop(); if (dd&gt;dist[x]) continue; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]+h[x]-h[y]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]+h[x]-h[y]; prevv[y]=x;preve[y]=i; q.push(mp(-dist[y],y)); &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; int qq[MAXN+48],Head,Tail;bool inq[MAXN+48]; bool spfa() &#123; int i,x,y; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;qq[Head=Tail=1]=t;inq[t]=true; while (Head&lt;=Tail) &#123; x=qq[Head++];inq[x]=false; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]; prevv[y]=x;preve[y]=i; if (!inq[y]) inq[y]=true,qq[++Tail]=y; &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; inline int min_cost_flow() &#123; int i,u,res,minf; for (i=0;i&lt;=t;i++) h[i]+=dist[i]; minf=INF; for (u=n*2+1;u!=t;u=prevv[u]) minf=min(minf,f[preve[u]]); res=minf*h[n*2+1]; for (u=n*2+1;u!=t;u=prevv[u]) &#123; f[preve[u]]-=minf; f[preve[u]^1]+=minf; &#125; return res; &#125; inline int ek() &#123; int ans=0; if (spfa()) &#123; do &#123; ans+=min_cost_flow(); &#125; while (dijkstra()); &#125; return -ans; &#125;&#125;int main ()&#123; int i,ca,s,t,v,op;io.Get(ca); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k);io.Get(w); flow::init(); for (i=1;i&lt;=n*2;i++) flow::addedge(0,i,INF,0),flow::addedge(i,n*2+1,INF,0); flow::addedge(n*2+2,0,k,0); for (i=1;i&lt;=n;i++) flow::addedge(i,n+i,INF,w),flow::addedge(n+i,i,INF,w); for (i=1;i&lt;=n-1;i++) flow::addedge(i,i+1,INF,0),flow::addedge(n+i,n+i+1,INF,0); for (i=1;i&lt;=m;i++) &#123; io.Get(s);io.Get(t);io.Get(v);io.Get(op); flow::addedge(op*n+s,(op^1)*n+t,1,-v); &#125; io.Print(flow::ek(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6434: Count 题解]]></title>
    <url>%2Fblog%2Fhdu6434%2F</url>
    <content type="text"><![CDATA[DescriptionMultiple query, for each n, you need to get $$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)=1]$$ InputOn the first line, there is a positive integer T, which describe the number of queries. Next there are T lines, each line give a positive integer n, as mentioned above. T&lt;=1e5, n&lt;=2e7 OutputYour output should include T lines, for each line, output the answer for the corresponding n. Sample Input4978438233666 Sample Output194041389511106589963 Source2018 Multi-University Training Contest 10 Solution我刚开始的思路是：转而考虑枚举i+j和j，但发现j的范围与i+j有关，最后不好算 我们考虑枚举一个a,i+j=2i-a,i-j=a,可以看出这样的a和j是一一对应的，且a+j=n 所以我们转而求 $$\sum_{i=1}^n\sum_{a=1}^{n-1}[gcd(2i-a,a)=1]$$ 根据辗转相减求gcd的原理，我们有$gcd(a+b,b)=gcd(a,b)$，所以$gcd(2i-a,a)=gcd(2i,a)$ 于是我们转而求 $$\sum_{i=1}^n\sum_{j=1}^{n-1}[gcd(2i,a)=1]$$ 首先a肯定是奇数，然后这时可以把2扔掉，只判断i和a是否互质 如果i是偶数，那么小于i的与i互质的数必然全都是奇数，都可以作为a，所以这时答案是$phi(i)$ 如果i是奇数，考虑任意一个小于i且与i互质的数p，则i-p也和i互质，而且p和i-p必然一奇一偶，所以所有小于i且与i互质的数中，奇数偶数各占一半，所以这时答案是$\frac{phi(i)}{2}$ 所以只要线性筛一波欧拉函数，然后前缀和一下就好了，时间复杂度O(n+T) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e7;int phi[MAXN+48],prime[MAXN+48],tot;bool isprime[MAXN+48];inline void init_phi()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i,phi[i]=i-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]) phi[i*prime[j]]=phi[i]*(prime[j]-1); else phi[i*prime[j]]=phi[i]*prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;LL ans[MAXN+48];inline void init_ans()&#123; ans[1]=0; for (register int i=2;i&lt;=MAXN;i++) if (i&amp;1) ans[i]=ans[i-1]+phi[i]/2; else ans[i]=ans[i-1]+phi[i];&#125;int main ()&#123; int ca,i,n;io.Get(ca); init_phi();init_ans(); while (ca--) &#123; io.Get(n); io.Print(ans[n],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6432: Cyclic 题解]]></title>
    <url>%2Fblog%2Fhdu6432%2F</url>
    <content type="text"><![CDATA[DescriptionCount the number of cyclic permutations of length n with no continuous subsequence [i, i + 1 mod n]. Output the answer modulo 998244353. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there is a single integer n in one line, denoting the length of cyclic permutations. 1 ≤ T ≤ 20, 1 ≤ n ≤ 100000 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 998244353. Sample Input3456 Sample Output1836 Source2018 Multi-University Training Contest 10 Solution考场上我已经想到了容斥竟然还没推出式子，卑劣地使用了OEIS，太惭愧了 容斥的思路是显然的，每次要算至少包含i个[i,i+1]片段的序列有多少种(这个“至少”指的是对于任意i个片段，这个序列都被算了一次)，这个怎么算呢？ 我们考虑所有的[i,i+1]片段，一共有[1,2],[2,3]…[n-1,n],[n,1]n种 我们考虑选出其中的i种，这i种将会在序列中出现，这个是$C_n^i$，然后我们将这些片段中的数捆在一起，比如如果选中了[1,2],[3,4]就把1和2捆在一起,3和4捆在一起; 如果选中了[1,2],[2,3]就把1,2,3三个数捆在一起。显然不论怎么选，最后一定会有n-i捆数，这些捆有$(n-i)!$种排列方法，考虑到这是一个置换群，所以1必须放在第一个，所以实际上是$(n-i-1)!$排列方法 这样我们得到了至少有i个片段的序列个数是$C_n^i(n-i-1)!$，注意到这个式子只在i=0~n-1的时候适用，当i=n时，显然有n个片段的排列只有一个，即1,2,3…n 所以最后的答案是 $$ans=(-1)^n+\sum_{i=0}^{n-1}(-1)^iC_n^i(n-i-1)!$$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int inv[MAXN+48],finv[MAXN+48],fac[MAXN+48];inline void init_inv()&#123; fac[0]=fac[1]=1; for (register int i=2;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y) &#123;return 1ll*fac[x]*finv[y]%MOD*finv[x-y]%MOD;&#125;int main ()&#123; int i,n,ans,ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);ans=0; for (i=0;i&lt;=n-1;i++) &#123; int delta=1ll*C(n,i)*fac[n-i-1]%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; if (n&amp;1) ans=sub(ans-1); else ans=add(ans+1); io.Print(ans,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6412: 公共子序列 题解]]></title>
    <url>%2Fblog%2Fhdu6412%2F</url>
    <content type="text"><![CDATA[Description光羽一点都不喜欢高代，某一次高代课上，光羽特意挑了最后一排的位置，睡着睡着，他忽然想到了这道字符串水题！ 度度熊有k(k≥2)个序列s1,s2,..,sk，每个序列的长度均为n，且序列中每个数均是1到n之间某个整数，请问这k个串有多少个长度大于0的公共子序列？ 解释：在每个序列中都选出一些位置，并将这些位置对应的字符顺次拼接起来，当它们都相等时，称其为公共子序列。 答案可能很大，请对$10^9+7$取模。 Input第一行一个数，表示数据组数T。 每组数据第一行两个数k,n；接下来k行，每行一个长度为n的序列si。 数据组数T=80，分别有20组数据满足k=2,3,4,5。 每组数据均满足1≤n≤1000，且s1,s2,…,sk中每一个数在1到n之间等概率随机生成！！ 随机生成！！ 随机生成！！ 随机生成！！ Output每组数据输出一行，每行仅包含一个数，表示公共子序列个数。 Sample Input42 31 2 12 3 13 31 2 32 3 11 2 34 33 2 23 1 32 3 13 2 15 33 1 33 1 11 2 32 3 31 3 3 Sample Output4428 Source2018“百度之星”程序设计大赛 - 复赛 Solution这么naive的题我赛场没有做出来，这种随机相关的题见的太少了…… 两个串的公共子串个数有非常简单的$O(n^2)$的dp可以解决，如果没有特殊性质，那么$k=5$时的复杂度应该是$O(n^5)$的，所以必须利用好随机这个性质 我刚开始一直在往最长公共子串很短这方面想，但这并没有什么用。我们可以考虑常规dp里的每个状态，记录的第一，二，三…个串的公共子串的最后位置p1,p2,p3…pn，要满足$s1[p1]=s2[p2]=s3[p3]=…=sn[pn]$,在随机的情况下，每个数列都接近一个排列，所以这样的状态数不会很多，期望是$O(n)$的，所以只要先搜索出所有合法的状态，再做一个$O(n^2)$的dp就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,k;int a[6][MAXN+48];vector&lt;int&gt; v[6][MAXN+48];struct node&#123; int pos[6]; inline bool operator &lt; (const node &amp;other) const &#123; for (register int i=1;i&lt;=k;i++) if (pos[i]&gt;=other.pos[i]) return false; return true; &#125;&#125;sta[MAXN*10+48],ins;int tot;int dp[MAXN*10+48];inline void dfs(int step,int type)&#123; if (step==k+1) &#123; sta[++tot]=ins; return; &#125; for (register int i=0;i&lt;int(v[step][type].size());i++) ins.pos[step]=v[step][type][i],dfs(step+1,type);&#125;inline int solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=1; for (register int i=1;i&lt;=tot;i++) if (sta[i]&lt;sta[cur]) dp[cur]=add(dp[cur]+solve(i)); return dp[cur];&#125;inline void Clear()&#123; for (register int i=1;i&lt;=k;i++) for (register int j=1;j&lt;=n;j++) v[i][j].clear();&#125;int main ()&#123; int i,j,ca;io.Get(ca); while (ca--) &#123; io.Get(k);io.Get(n);Clear(); for (i=1;i&lt;=k;i++) for (j=1;j&lt;=n;j++) io.Get(a[i][j]),v[i][a[i][j]].pb(j); tot=0; for (i=1;i&lt;=n;i++) dfs(1,i); memset(dp,-1,sizeof(dp));int ans=0; for (i=1;i&lt;=tot;i++) ans=add(ans+solve(i)); io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6403: Card Game 题解]]></title>
    <url>%2Fblog%2Fhdu6403%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob are playing a card game. In this card game, a number is written on each face of the playing card. The rule of the game is described as follows: Alice arranges the cards in a row, and for each of the cards, she chooses one of its faces to place it up; Bob turns over minimum number of cards to make all numbers on the front faces unique. They play the game some times, and Bob always succeeds making the numbers unique. However, both of them are not sure whether the number of cards flipped is minimum. Moreover, they want to figure out the number of different ways of turning over minimum number of cards to make the numbers unique. Two ways are considered equal if and only if the sets of flipped cards are equal. Please write a program to help them! InputThe first line of the input is a single integer T (1≤T≤50), the number of test cases. Each test case begins with a single line of integer n (1≤n≤105), the number of cards on the table. Then follow n lines, specifying the cards that Alice arranges. Each of these n lines contains two integers x,y (1≤x,y≤2n), meaning that Alice places a card with number x on the front face and number y on the back face. It is guaranteed that the sum of n over all test cases does not exceed 106. OutputFor each test case, display two integers in a line, the minimum number of cards to turn over, and the number of different ways of flipping modulo 998244353, respectively. If it is impossible to turn over cards to make all numbers unique, display -1 -1 instead. Sample Input341 21 34 54 621 11 131 23 45 6 Sample Output2 4-1 -10 1 HintIn the first sample test case, Bob may turn over one of the first two cards and one of the last two cards, so there are four different ways of turning over two cards tomake all numbers on the front faces unique. Obviously, this can’t be done with less than two cards flipped. In the second sample test case, it is impossible to make all numbers on the front faces unique. In the third sample test case, all numbers on the front faces are already distinct. Source2018 Multi-University Training Contest 8 Solution非常赞的图论建模题 我们可以考虑把每场卡片看成一条无向边，把数字看成点，比如卡片上的数字是u和v，就在u和v之间连一条边，这样我们的任务就是给每条边定向（显然有一种方向权值是0，另外一种方向权值是1），使得每个点被不多于一条边指向（即每条边指向的点是这张卡片最后的数字），且权值和最小 我们可以发现两个重要的性质 如果出现了一个环，那么这个环只有两种定向方式：逆时针和顺时针，即环上的每个点都会被指到 如果某个联通块中有两个环，那么必然无解。因为考虑连接两个环的路径，因为路径的两头的点都属于环中，根据性质1，这两个点都在环上被指到了，那么这条路径中的边数会比点数多1，无论如何也不可能合法定向 所以每个联通块要么是基环外向树，要么是树，分情况讨论： 基环外向树：考虑环上挂的若干棵树，因为根节点在环上已经被指到了，所以树中所有连接到根节点的边必须向下定向，同理根节点的孩子们都被指到了，所以根节点的孩子们的边也要向下定向……所以说，基环树上的每棵树的定向方式都是唯一的，即所有边都向下，然后环有两种情况，分别判一下就好。尤其要注意自环的情况，自环无论如何只可能有一种情况 树：树中有n-1条边和n个点，所以必然有且仅有一个点没有被指到，考虑一旦确定了这个没有被指到的点，以它为根，那么整棵树的定向就确定了。我们可以先考虑随便抓一个点i作为根算一遍，得到一个初始答案ans,然后再做一遍深搜枚举根，设当前根为j,我们会发现这时i到j的路径上的边会反向，其他边不变，这个可以边搜边记录，可以比较轻松的解决 至此所有情况讨论完毕，时间复杂度$O(n)$，对代码能力要求稍高 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n;vector&lt;int&gt; v[MAXN+48];bool incir[MAXN+48];struct Edge&#123; int u,v; inline void input() &#123;io.Get(u);io.Get(v);&#125;&#125;edge[MAXN+48];inline int getanother(int id,int u)&#123; return edge[id].u==u?edge[id].v:edge[id].u;&#125;int cid,cnt;int depth[MAXN+48],fa[MAXN+48],vis[MAXN+48],exist[MAXN+48];//fa didn't store his father but the id of the edge to his fatherinline void dfs(int cur,int father)&#123; fa[cur]=father;int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (!depth[y]) &#123; depth[y]=depth[cur]+1; dfs(y,id); &#125; else if (id!=father &amp;&amp; depth[y]&lt;=depth[cur]) &#123; cnt++; cid=id; &#125; &#125;&#125;int minn,minmethod;namespace cycle&#123; int cirlist[MAXN+48],ctot; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father &amp;&amp; !incir[y]) &#123; if (cur==edge[id].u) minn++; dfs(y,id); &#125; &#125; &#125; inline void solve() &#123; ctot=0;int u=edge[cid].u,v=edge[cid].v; if (depth[u]&lt;depth[v]) swap(u,v); for (register int cur=u;cur!=v;cur=getanother(fa[cur],cur)) cirlist[++ctot]=cur,incir[cur]=true; cirlist[++ctot]=v;incir[v]=true; for (register int i=1;i&lt;=ctot;i++) dfs(cirlist[i],-1); if (ctot==1) return; int cnt1=0,cnt2=0; //from down to up for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].u==cirlist[i]) cnt1++; if (edge[cid].u==cirlist[ctot]) cnt1++; //from up to down for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].v==cirlist[i]) cnt2++; if (edge[cid].u==cirlist[1]) cnt2++; minn+=min(cnt1,cnt2); if (cnt1==cnt2) minmethod=add(minmethod+minmethod); &#125;&#125;namespace tree&#123; int Minn,Cnt,ans; inline void update(int curans) &#123; if (curans&lt;Minn) Minn=curans,Cnt=1; else if (curans==Minn) Cnt++; &#125; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father) &#123; if (edge[id].u==cur) ans++; dfs(y,id); &#125; &#125; &#125; inline void Dfs(int cur,int father) &#123; update(ans);int i,id,y,delta; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id==father) continue; if (edge[id].u==cur) delta=1; else delta=-1; ans-=delta;Dfs(y,id); ans+=delta; &#125; &#125; inline void solve(int root) &#123; Minn=INF;Cnt=0; ans=0;dfs(root,-1); Dfs(root,-1); minn+=Minn;minmethod=(1ll*minmethod*Cnt)%MOD; &#125;&#125;inline void Clear()&#123; for (register int i=1;i&lt;=n*2;i++) depth[i]=0,v[i].clear(),incir[i]=false,vis[i]=false; minn=0;minmethod=1;&#125;int main ()&#123; int ca;io.Get(ca);int i; while (ca--) &#123; io.Get(n);Clear(); bool f=true; for (i=1;i&lt;=n;i++) &#123; edge[i].input(); if (edge[i].u!=edge[i].v) v[edge[i].u].pb(i),v[edge[i].v].pb(i); else v[edge[i].u].pb(i); exist[edge[i].u]=true;exist[edge[i].v]=true; if (edge[i].u==edge[i].v) &#123; if (vis[edge[i].u]) f=false; vis[edge[i].u]=true; &#125; &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; for (i=1;i&lt;=n*2;i++) if (!depth[i] &amp;&amp; exist[i]) &#123; cnt=0;cid=0; depth[i]=1;dfs(i,-1); if (cnt&gt;1) &#123;f=false;break;&#125; if (cnt==1) cycle::solve(); else tree::solve(i); &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; io.Print(minn,' ');io.Print(minmethod,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>思维</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6406: Taotao Picks Apples 题解]]></title>
    <url>%2Fblog%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1,h2,⋯,hn, you are required to answer some independent queries. Each query is two integers p,q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1≤T≤10), the number of test cases. Each test case begins with a line of two integers n,m (1≤n,m≤105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1,h2,⋯,hn (1≤hi≤109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1≤p≤n) and q (1≤q≤109), as described in the problem statement. OutputFor each query, display the answer in a single line. Sample Input15 31 2 3 4 41 55 52 3 Sample Output153 HintFor the first query, the heights of the apples were 5, 2, 3, 4, 4, so Taotao would only pick the first apple. For the second query, the heights of the apples were 1, 2, 3, 4, 5, so Taotao would pick all these five apples. For the third query, the heights of the apples were 1, 3, 3, 4, 4, so Taotao would pick the first, the second and the fourth apples. Source2018 Multi-University Training Contest 8 Solution我们可以先预处理原数列中会摘哪些苹果，这样对于每次询问，如果这次修改的苹果是pos，那么原数列中位置在pos前的那些苹果还是会被摘，这个可以二分一下找出在它之前的苹果个数 设之前的最后一个苹果的高度是h, 位置pos的新苹果高度为nv，分两种情况讨论： h&lt;nv 则下一个苹果是nv，在往下一个苹果是pos之后的第一个比nv大的苹果 h&gt;=nv 则下一个苹果是pos之后的第一个比h大的苹果 我们可以看出两种情况都需要支持查找在某个位置p之后，第一个比某个值val大的值在什么位置，显然我们可以二分这个位置，然后查找这个区间的max，如果max&gt;val则在位置以左，否则在位置以右，静态的查询max可以用ST表，这样复杂度可以控制在一个log 找到这关键的pos以右的第一个苹果之后，我们可以发现这之后的苹果都是原始数列的苹果，所以我们可以刚开始从后往前预处理一下从某个苹果开始向后能摘多少个苹果，加一下就好了 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;int n,m;int a[MAXN+48];int maxn[MAXN+48][21],Log[MAXN+48];inline void construct_ST()&#123; int i,j; for (i=1;i&lt;=n;i++) maxn[i][0]=a[i]; for (j=1;j&lt;=20;j++) for (i=1;i&lt;=n;i++) &#123; maxn[i][j]=maxn[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=n) maxn[i][j]=max(maxn[i][j],maxn[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (i=2;i&lt;=MAXN;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return max(maxn[l][Log[k]],maxn[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int find(int pos,int cmp)&#123; int l=pos,r=n,mid,res=-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_ST(pos,mid)&gt;cmp) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int dp[MAXN+48];inline void init_dp()&#123; for (register int i=n;i&gt;=1;i--) &#123; dp[i]=1; int res=find(i+1,a[i]); if (res!=-1) dp[i]+=dp[res]; &#125;&#125;int seq[MAXN+48],tot;inline int bsearch(int cmp)&#123; int l=1,r=tot,res=0,mid; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (seq[mid]&gt;=cmp) r=mid-1; else res=mid,l=mid+1; &#125; return res;&#125;int main ()&#123; int ca;io.Get(ca);int i,pos,nv; while (ca--) &#123; io.Get(n);io.Get(m); for (i=1;i&lt;=n;i++) io.Get(a[i]); construct_ST();init_dp();tot=0; seq[++tot]=1; for (i=2;i&lt;=n;i++) if (a[i]&gt;a[seq[tot]]) seq[++tot]=i; while (m--) &#123; io.Get(pos);io.Get(nv); int pp=bsearch(pos),ans=pp; if (!pp || a[seq[pp]]&lt;nv) &#123; ans++; int res=find(pos+1,nv); if (res!=-1) ans+=dp[res]; &#125; else &#123; int res=find(pos+1,a[seq[pp]]); if (res!=-1) ans+=dp[res]; &#125; io.Print(ans); &#125; &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>常用技术</category>
        <category>ST表</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6397: Character Encoding 题解]]></title>
    <url>%2Fblog%2Fhdu6397%2F</url>
    <content type="text"><![CDATA[DescriptionIn computer science, a character is a letter, a digit, a punctuation mark or some other similar symbol. Since computers can only process numbers, number codes are used to represent characters, which is known as character encoding. A character encoding system establishes a bijection between the elements of an alphabet of a certain size n and integers from 0 to n−1. Some well known character encoding systems include American Standard Code for Information Interchange (ASCII), which has an alphabet size 128, and the extended ASCII, which has an alphabet size 256. For example, in ASCII encoding system, the word wdy is encoded as [119, 100, 121], while jsw is encoded as [106, 115, 119]. It can be noticed that both 119+100+121=340 and 106+115+119=340, thus the sum of the encoded numbers of the two words are equal. In fact, there are in all 903 such words of length 3 in an encoding system of alphabet size 128 (in this example, ASCII). The problem is as follows: given an encoding system of alphabet size n where each character is encoded as a number between 0 and n−1 inclusive, how many different words of length m are there, such that the sum of the encoded numbers of all characters is equal to k? Since the answer may be large, you only need to output it modulo 998244353. InputThe first line of input is a single integer T (1≤T≤400), the number of test cases. Each test case includes a line of three integers n,m,k (1≤n,m≤$10^5$,0≤k≤$10^5$), denoting the size of the alphabet of the encoding system, the length of the word, and the required sum of the encoded numbers of all characters, respectively. It is guaranteed that the sum of n, the sum of m and the sum of k don’t exceed $5×10^6$, respectively. OutputFor each test case, display the answer modulo 998244353 in a single line. Sample Input42 3 32 3 43 3 3128 3 340 Sample Output107903 Source2018 Multi-University Training Contest 8 Solution这题我刚开始直接无脑上了多项式快速幂，然后就T飞了，于是被戴大爷教做人……真的是知识越多越反动 我们考虑如果没有每个数在0~n-1这个条件的话，那就是一个简单的盒子可空的隔板法问题，现在加上这个限制，我们考虑容斥，那么最后的方案可以写成这样 $$ans=\sum_{i=0}^{lim}(-1)^i*f(至少有i个数大于n-1)$$ 现在考虑$f(至少有i个数大于n-1)$怎么算，我们可以先钦定哪i个位置比n-1大，这个是$C_m^i$，然后剩下的依旧是一个简单的隔板法，于是就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=3e5;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD,y&gt;&gt;=1; &#125; return res;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int fac[MAXN+48],finv[MAXN+48];inline void init_inv()&#123; fac[0]=1; for (register int i=1;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || y&lt;0 || x&lt;y) return 0; return ((1ll*fac[x]*finv[y])%MOD*finv[x-y])%MOD;&#125;int n,m,k;int main ()&#123; int ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k); int ans=0; for (register int i=0;i&lt;=m &amp;&amp; n*i&lt;=k;i++) &#123; int delta=(1ll*C(m,i)*C(k-n*i+m-1,m-1))%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #1019B: The hat 题解]]></title>
    <url>%2Fblog%2Fcf1019b%2F</url>
    <content type="text"><![CDATA[DescriptionThis is an interactive problem. Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice. As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists. You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. InputAt the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students. You are allowed to ask no more than 60 questions. OutputTo ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109). When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn’t exist, you should output «! -1». In both cases you should immediately terminate the program. The query that contains your answer is not counted towards the limit of 60 queries. Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language. HackingUse the following format for hacking: In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students. In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or - 1. The hacked solution will not have direct access to the sequence ai. Examplesinput 822 output ? 4? 8! 4 input 6123210 output ? 1? 2? 3? 4? 5? 6! -1 NoteInput-output in statements illustrates example interaction. In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2 In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. Solution交互题毁我青春……本人不擅长做动脑子的题，这个花了整场比赛才做出来，于是rnk在2题里面垫底。。。 既然次数只有60次，感觉每次肯定要查询相对的两个人，相当于查询30组，估计是二分相关 我们永远考虑位置相对的两个扇形，设上面的扇形上的数字从a到A,下面的扇形上的数字从b到B 通过仔细的观察，我们能发现一些结论： 如果$abs(a-b)\equiv 1(mod 2)$，那么这两个扇形区域内必然没有任何一组数相等 如果$a&gt;b$且$A&lt;B$，那这两个扇形区域内必然有一组数相等 如果(a,A),(b,B)两个区间不相交，那么这两个扇形区域内必然没有任何一组数相等 进而我们可以发现，对于相对的两个扇形，我们二分出中间的一条线，把他们切成两组扇形，这两组扇形要么有一组铁定无解，要么至少有一组铁定有解，无论是哪一种情况，我们都可以把另一半扔掉，在必定有解的那一半里继续二分 这就是大概的思路了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);inline int getint()&#123; bool f;char ch;int res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n;int a,A,b,B,m,M;inline int myabs(int x) &#123;return x&gt;=0?x:-x;&#125;inline bool check_invalid()&#123; if (myabs(a-b)%2==0) return false; if (myabs(A-B)%2==0) return false; return true;&#125;inline bool Contain(int l1,int r1,int l2,int r2)&#123; if (l1&gt;l2 &amp;&amp; r1&lt;r2) return true; if (l1&lt;l2 &amp;&amp; r1&gt;r2) return true; return false;&#125;inline bool Away(int l1,int r1,int l2,int r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return r1&lt;l2 || r2&lt;l1;&#125;int main ()&#123; n=getint(); if (n==2) &#123; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? 2\n");fflush(stdout);scanf("%d",&amp;A); if (a==A) printf("! 1\n"); else printf("! -1\n"); return 0; &#125; int la=1,lA=n/2; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? %d\n",lA);fflush(stdout);scanf("%d",&amp;A); printf("? %d\n",la+n/2);fflush(stdout);scanf("%d",&amp;b); printf("? %d\n",lA+n/2);fflush(stdout);scanf("%d",&amp;B); if (a==b) &#123; printf("! 1\n"); return 0; &#125; if (A==B) &#123; printf("! %d\n",lA); return 0; &#125; if (check_invalid()) &#123;printf("! -1\n");return 0;&#125; while (lA-la&gt;1) &#123; int mid=(la+lA)&gt;&gt;1,to=mid+n/2; printf("? %d\n",mid);fflush(stdout);scanf("%d",&amp;m); printf("? %d\n",to);fflush(stdout);scanf("%d",&amp;M); if (m==M) &#123; printf("! %d\n",mid); return 0; &#125; if (Contain(a,m,b,M)) &#123;lA=mid;A=m;B=M;continue;&#125; if (Contain(m,A,M,B)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(a,m,b,M)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(m,A,M,B)) &#123;lA=mid;A=m;B=M;continue;&#125; &#125; if (a==b) &#123;printf("! %d\n",la);return 0;&#125; if (A==B) &#123;printf("! %d\n",lA);return 0;&#125; printf("! -1\n");return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
</search>
