<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[ZOJ3877]Earthstone Keeper 题解]]></title>
    <url>%2Fblog%2Fzoj3877%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一张$n\times m$的地图，地图的每个格子有如下几种可能 .，表示该格子非常普通。 #，表示该格子是障碍物，不能通行。 a~z,表示该格子是陷阱，其威力为$1$到$26$，陷阱每经过一次都会对勇士产生其威力大小的伤害。 A~Z，表示该格子是怪物，其威力为$1$到$26$，当经过怪物所在的格子或怪物所在格子相邻的格子时，怪物会跳出来与勇士搏斗，勇士在杀死它的过程中会受到其威力大小的伤害，怪物杀死后不会复活。 勇士的行走是四连通的，每走一步需要花$1$单位的时间。 勇士要从$(s_x,s_y)$走到$(e_x,e_y)$，问最少受到多少伤害，以及受到伤害最小的前提下最少花多少时间。 SolutionClick to view the solution乍一看感觉是一个沙雕最短路题，但仔细想想发现在处理怪物的时候有一点小玄妙，不知该如何控制两次经过怪物的相邻格只算一次怪物的伤害。一个显然的性质是，因为没有负权，所以最优的路径肯定不会重复经过同一个点，即最优路径是一条简单路径。继而我们可以发现勇士是不会在经过怪物本身所在的位置的时候与怪物搏斗的，因为在上一步怪物就已经跳出来了。所以如果把怪物下放到其相邻的四个格子里，中间格子实际上等价于.。继而我们可以发现，怪物相邻的四个格子，两两距离都是$2$，这必定是最好的路径，也就是说，如果勇士处在一个怪物的相邻格内，想到另外一个相邻格内，他一定会选择穿过怪物所在格直接抵达。预处理每个非怪物格子被哪些怪物控制了，建图的时候，其他的地方正常四连通建图，在有怪物的地方，将它周围的四个格子两两连边长为$2$的边。这样的好处在于可以方便的避免怪物伤害的重复计算，如果当前要走$x\rightarrow y$这条边，我们只要将控制$y$但不控制$x$的伤害计算在内即可，因为最优路径中，如果经过多个被同一个怪物控制的格子这些格子在路径中一定是相邻的。跑最短路的时候以伤害为第一关键字，时间为第二关键字即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define uing unsigned int#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))#define rep(i,l,r) for (register int i=int(l);i&lt;=int(r);i++)#define REP(i,r,l) for (register int i=int(r);i&gt;=int(l);i--)const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;int n,m,sx,sy,ex,ey;char Map[548][548];int val[548][548];vector&lt;Pair&gt; v[548][548];vector&lt;int&gt; monster[548][548];int s[548][548],d[548][548];int dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,1,0,-1&#125;;inline int getind(int x,int y) &#123;return (x-1)*m+y;&#125;inline void getcor(int id,int &amp;x,int &amp;y) &#123;x=id/m;if (id%m) x++;y=id-(x-1)*m;&#125;priority_queue&lt;pair&lt;Pair,int&gt; &gt; q;bool inq[548][548];inline void input()&#123; Get(n,m,sx,sy,ex,ey); rep(i,1,n) scanf("%s",Map[i]+1);&#125;inline void Clear()&#123; rep(i,1,n) rep(j,1,m) monster[i][j].clear(),v[i][j].clear(),inq[i][j]=false;&#125;inline int getsafe(int x1,int y1,int x2,int y2)&#123; int res=0; if (islower(Map[x2][y2])) res+=Map[x2][y2]-'a'+1; rep(i,0,int(monster[x2][y2].size())-1) &#123; bool f=true; rep(j,0,int(monster[x1][y1].size())-1) if (monster[x1][y1][j]==monster[x2][y2][i]) &#123;f=false;break;&#125; if (f) &#123; int xx,yy;getcor(monster[x2][y2][i],xx,yy); res+=Map[xx][yy]-'A'+1; &#125; &#125; return res;&#125;inline void dijkstra()&#123; rep(i,1,n) rep(j,1,m) s[i][j]=d[i][j]=INF; s[sx][sy]=d[sx][sy]=0;inq[sx][sy]=true; q.push(mp(mp(0,0),getind(sx,sy))); while (!q.empty()) &#123; int id=q.top().y;q.pop(); int cx,cy,tox,toy;getcor(id,cx,cy); inq[cx][cy]=false; rep(i,0,int(v[cx][cy].size())-1) &#123; int tmp=v[cx][cy][i].x;getcor(tmp,tox,toy); int vs=getsafe(cx,cy,tox,toy); if (s[cx][cy]+vs&lt;s[tox][toy] || (s[cx][cy]+vs==s[tox][toy] &amp;&amp; d[cx][cy]+v[cx][cy][i].y&lt;d[tox][toy])) &#123; s[tox][toy]=s[cx][cy]+vs; d[tox][toy]=d[cx][cy]+v[cx][cy][i].y; if (!inq[tox][toy]) inq[tox][toy]=true,q.push(mp(mp(-s[tox][toy],-d[tox][toy]),getind(tox,toy))); &#125; &#125; &#125;&#125;inline void solve()&#123; rep(i,1,n) rep(j,1,m) if (Map[i][j]!='#' &amp;&amp; !isupper(Map[i][j])) &#123; rep(dir,0,3) &#123; int x=i+dx[dir],y=j+dy[dir]; if (1&lt;=x &amp;&amp; x&lt;=n &amp;&amp; 1&lt;=y &amp;&amp; y&lt;=m &amp;&amp; isupper(Map[x][y])) monster[i][j].pb(getind(x,y)); &#125; &#125; rep(i,1,n) rep(j,1,m) if (Map[i][j]!='#' &amp;&amp; !isupper(Map[i][j])) &#123; rep(dir,0,3) &#123; int x=i+dx[dir],y=j+dy[dir]; if (1&lt;=x &amp;&amp; x&lt;=n &amp;&amp; 1&lt;=y &amp;&amp; y&lt;=m &amp;&amp; Map[x][y]!='#' &amp;&amp; !isupper(Map[x][y])) v[i][j].pb(mp(getind(x,y),1)); &#125; &#125; rep(i,1,n) rep(j,1,m) if (isupper(Map[i][j])) &#123; vector&lt;int&gt; neighbor;neighbor.clear(); rep(dir,0,3) &#123; int x=i+dx[dir],y=j+dy[dir]; if (1&lt;=x &amp;&amp; x&lt;=n &amp;&amp; 1&lt;=y &amp;&amp; y&lt;=m &amp;&amp; Map[x][y]!='#') neighbor.pb(getind(x,y)); &#125; rep(pt1,0,int(neighbor.size())-1) rep(pt2,0,int(neighbor.size())-1) if (pt1!=pt2) &#123; int x1,y1;getcor(neighbor[pt1],x1,y1); v[x1][y1].pb(mp(neighbor[pt2],2)); &#125; &#125; dijkstra(); printf("%d %d\n",s[ex][ey],d[ex][ey]);&#125;int main ()&#123;#ifndef ONLINE_JUDGE double T=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;Get(ca); while (ca--) &#123; input(); Clear(); solve(); &#125;#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-T)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ3049][十二省联考2019]字符串问题 题解]]></title>
    <url>%2Fblog%2Floj3049%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$N$的字符串$S$，记$[l,r]$表示$s_ls_{l+1}\dots s_{r-1}s_{r}$。现在有$na$个A类字符串和$nb$个B类字符串，第$i$个A类字符串是$[la_i,ra_i]$，第$i$个B类字符串是$[lb_i,rb_i]$。 有$m$组支配关系，第$i$组为$(x_i,y_i)$表示第$x_i$个A类串支配第$y_i$个B类串。 求一个最长的由若干个A类字符串拼接而成的字符串$T=A_{id_1}A_{id_2}\dots A_{id_k}$（$id_i$是可以重复的）满足：对于$\forall x&lt;k$，$\exists B_i$使得$A_{id_x}$支配$B_i$且$B_i$是$A_{id_{x+1}}$的前缀。 求$T$的最长长度（即$\sum_{i=1}^{k} \mid A_{id_i}\mid$），若$T$可以无限长输出$-1$。 对于$80\%$的数据满足任意$A_i$长度大于任意$B_j$ 所有数字同阶，为$2\times 10^5$级别。 SolutionClick to view solution1(based on SAM)朴素的暴力思路大致如下：建图，对于所有的A类串向其支配的B类串连边，对于所有的B类串向以它为前缀的A类串连边，A类串对应点权值为该串长度,B类串对应点权值为0。先判断一下如果图中有环输出$-1$，否则在DAG上跑一个$dp$求权值最大的路径。建图的瓶颈在于判断前缀的复杂度过高且边数可能很多，需要字符串结构来简化前缀之间的关系。先考虑$80\%$的分数。顾名思义SAM处理的是后缀问题而现在题目中的是前缀限制，所以我们先将$S$串翻转，同时所有的A类串和B类串翻转，这样约束就变成了某个B是某个A的后缀。我们对$S$串建SAM，考察SAM的parent树，可以发现祖先节点是后代节点的后缀。所以只要我们把所有的$A_i$和$B_i$对应到parent树上，parent树本身就非常好的刻画了前缀关系。对应过程也不难，我们在建SAM的过程中记录每个右端点对应的最长后缀的节点的编号。我们发现，从这个点出发到根的路径，其长度是单调递减的，所以对于某个串$A_i$或$B_i$，我们只要从最长节点出发在树上倍增即可。这个做法无法得到满分的问题在于，有一些$B_i$和$A_i$会对应到parent树的同一个节点上，这些串之间是有长度大小关系的，所以我们的建图还需要更加精细。我们先将parent树的每个点拆成入点和出点，这样所有归属于该节点的$A_i$和$B_i$夹在这两个点中间。显然入点要向出点连一条边表示可以继续向下寻找。我们把归属于这个点的所有$A_i$按长度从小到大排序，所有$B_i$按长度从小到大排序。对于$A$类串我们也要拆点，从入点向出点连一条边，入点权值为$0$出点权值为该串长度，出点向该串支配的B类串连边。从小到大排成一排后，相邻的A类串左边的入点向右边的入点连边。考虑如何处理$A_i$和$B_i$的长度关系，对于每个$B_i$我们向比它长的最短的$A_j$的入点连边，这样由于之前在入点之间连的那些边，$B_i$相当于向所有比它长的A类串连了边，又由于权值在出点上，所以如果你没有真正选择这个A类串的话是不会误算权值的。由于两个序列长度都是递增的，可以利用单调性线性连边。此外，每个B类串还要向parent树该节点的出点连边，表示向下寻找更长的A类串。parent树该节点的入点要向本节点内第一个A类串连边表示可以在这个节点内选择一个A类串继续走下去。图终于建完了最后在图上跑$dp$即可。时间复杂度$O(nlogn)$（这个log来自倍增和点内部的排序）。 Click to view solution2(based on SA)朴素的暴力思路大致如下：建图，对于所有的A类串向其支配的B类串连边，对于所有的B类串向以它为前缀的A类串连边，A类串对应点权值为该串长度,B类串对应点权值为0。先判断一下如果图中有环输出$-1$，否则在DAG上跑一个$dp$求权值最大的路径。建图的瓶颈在于判断前缀的复杂度过高且边数可能很多，需要字符串结构来简化前缀之间的关系。先考虑$80\%$的分数。字符串上的一个区间相当于后缀的前缀。我们对$S$建后缀数组，lcp数组，用ST表预处理以便$O(1)$询问两个后缀的lcp，不在话下。注意特判两个相同位置的lcp啊啊啊啊此时我们并不需要让B类串对应的点出现在图中，只需要用B类串去刻画关系。我们把所有的A类串按照它们在后缀数组中的位置排序，对于一个$A_i$的支配串$B_j$，我们在后缀数组中查询和它的lcp等于$B_j$长度的那些位置，这些位置的串都是以$B_j$为前缀的，这些位置肯定是一个区间，可以通过二分+求lcp算出。将这个区间再映射到A类串序列中，相当于$A_i$要向一个区间内的所有$A_j$连边。优化区间连边是喜闻乐见的问题，对于A串序列我们在上面堆一棵线段树，按照线段树的边去建图，这样给一个区间连边等价于给线段树上的log个节点连边。这个做法无法获得满分的原因是我们在求lcp的时候，并没有去关注该区间内所有的A类串是否都比当前B类串长，事实上那些短于当前B类串的A类串是不能连边的，这样连边的就不是一个区间，看似不能做了。通过一些优化可以解决这个问题。我们把所有的A类串和B类串放在一起按照长度从大到小排序，维护一棵主席树。对于一个A类串，我们把它插入到主席树里，注意同时把主席树中的儿子关系建在图中，对于一个B类串，现在处于主席树中的A类串都是比它长的，我们仍像之前一样二分出区间，给主席树上的这个区间连边，相当于只给长度大于当前B类串的点连了边。最后跑一个$dp$即可。总时间复杂度$O(nlogn)$，常数略大。 CodeClick to view code1(based on SAM)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;char s[MAXN+48];int len;int na,nb,m;int posa[MAXN+48],lena[MAXN+48],posb[MAXN+48],lenb[MAXN+48];vector&lt;int&gt; bel[MAXN+48];int tot;vector&lt;int&gt; ta[MAXN*2],tb[MAXN*2];vector&lt;int&gt; vv[MAXN*10+48];int d[MAXN*10+48],val[MAXN*10+48];int head,tail,q[MAXN*10+48];LL dp[MAXN*10+48];inline void addedge(int x,int y) &#123;vv[x].pb(y);d[y]++;&#125;inline bool cmp_lena(int x,int y) &#123;return lena[x]&lt;lena[y];&#125;inline bool cmp_lenb(int x,int y) &#123;return lenb[x]&lt;lenb[y];&#125;namespace SAM&#123; int nxt[MAXN*2][27],maxn[MAXN*2],minn[MAXN*2],par[MAXN*2],last,Root; vector&lt;int&gt; v[MAXN*2];int anc[MAXN*2][21],pos[MAXN+48]; inline int Create() &#123;++tot;maxn[tot]=0;memset(nxt[tot],0,sizeof(nxt[tot]));par[tot]=0;return tot;&#125; inline void init() &#123;tot=0;Root=last=Create();&#125; inline void extend(char ch,int ind) &#123; int p=last,np=Create(),w=ch-'a'+1;last=np;maxn[np]=maxn[p]+1;pos[ind]=np; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=Root;return;&#125; int q=nxt[p][w];if (maxn[q]==maxn[p]+1) &#123;par[np]=q;return;&#125; int nq=Create();maxn[nq]=maxn[p]+1;memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[np]=par[q]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; &#125; inline void construct() &#123; init(); for (register int i=1;i&lt;=len;i++) extend(s[i],i); &#125; inline void dfs(int cur) &#123; if (cur!=Root) minn[cur]=maxn[par[cur]]+1; anc[cur][0]=par[cur]; for (register int i=1;i&lt;=20;i++) anc[cur][i]=anc[anc[cur][i-1]][i-1]; for (auto y : v[cur]) dfs(y); &#125; inline void build() &#123; for (register int i=1;i&lt;=tot;i++) v[i].clear(); for (register int i=2;i&lt;=tot;i++) v[par[i]].pb(i); dfs(Root); &#125; inline int getnode(int cur,int len) &#123; if (minn[cur]&lt;=len &amp;&amp; len&lt;=maxn[cur]) return cur; for (register int i=20;i&gt;=0;i--) &#123; if (anc[cur][i]&lt;=1) continue; if (minn[anc[cur][i]]&gt;len) cur=anc[cur][i]; &#125; return par[cur]; &#125; inline void buildedge() &#123; for (register int i=2;i&lt;=tot;i++) addedge(tot+par[i],i); for (register int i=1;i&lt;=tot;i++) addedge(i,tot+i); &#125;&#125;inline LL solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=0; for (auto y : vv[cur]) check_max(dp[cur],solve(y)); return dp[cur]+=val[cur];&#125;bool ff;inline void input()&#123; scanf("%s",s+1);len=strlen(s+1); for (register int i=1,j=len;i&lt;j;i++,j--) swap(s[i],s[j]); Get(na);int l,r,x,y; for (register int i=1;i&lt;=na;i++) &#123; Get(l,r); posa[i]=len-l+1;lena[i]=r-l+1; &#125; Get(nb); for (register int i=1;i&lt;=nb;i++) &#123; Get(l,r); posb[i]=len-l+1;lenb[i]=r-l+1; &#125; for (register int i=1;i&lt;=na;i++) bel[i].clear(); Get(m); for (register int i=1;i&lt;=m;i++) Get(x,y),bel[x].pb(y);&#125;inline void Clear()&#123; for (register int i=1;i&lt;=len*4+na*2+nb;i++) vv[i].clear(),d[i]=0,val[i]=0; for (register int i=1;i&lt;=len*2;i++) ta[i].clear(),tb[i].clear(); head=1;tail=0; for (register int i=1;i&lt;=len*4+na*2+nb;i++) dp[i]=-1;&#125;inline void solve()&#123; SAM::construct();SAM::build();int x; for (register int i=1;i&lt;=na;i++) x=SAM::getnode(SAM::pos[posa[i]],lena[i]),ta[x].pb(i); for (register int i=1;i&lt;=nb;i++) x=SAM::getnode(SAM::pos[posb[i]],lenb[i]),tb[x].pb(i); SAM::buildedge(); for (register int i=1;i&lt;=tot;i++) sort(ta[i].begin(),ta[i].end(),cmp_lena),sort(tb[i].begin(),tb[i].end(),cmp_lenb); for (register int i=1;i&lt;=na;i++) addedge(tot*2+i,tot*2+na+i),val[tot*2+na+i]=lena[i]; for (register int i=1;i&lt;=tot;i++) &#123; for (register int j=0;j&lt;int(tb[i].size());j++) addedge(tot*2+na*2+tb[i][j],tot+i); if (int(ta[i].size())) addedge(i,tot*2+ta[i][0]); for (register int j=0;j&lt;int(ta[i].size())-1;j++) addedge(tot*2+ta[i][j],tot*2+ta[i][j+1]); int pt=0; for (register int j=0;j&lt;int(tb[i].size());j++) &#123; while (pt&lt;int(ta[i].size()) &amp;&amp; lenb[tb[i][j]]&gt;lena[ta[i][pt]]) pt++; if (pt&lt;=int(ta[i].size())-1) addedge(tot*2+na*2+tb[i][j],tot*2+ta[i][pt]); &#125; &#125; for (register int i=1;i&lt;=na;i++) for (register int j=0;j&lt;int(bel[i].size());j++) addedge(tot*2+na+i,tot*2+na*2+bel[i][j]); int T=tot*2+na*2+nb,cnt=0; for (register int i=1;i&lt;=T;i++) if (!d[i]) q[++tail]=i; while (head&lt;=tail) &#123; int cur=q[head++];cnt++; for (auto y : vv[cur]) &#123; d[y]--; if (!d[y]) q[++tail]=y; &#125; &#125; if (cnt&lt;T) &#123;puts("-1");return;&#125; LL ans=0; for (register int i=1;i&lt;=T;i++) check_max(ans,solve(i)); printf("%lld\n",ans);&#125;int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;Get(ca); while (ca--) &#123; input(); Clear(); solve(); &#125; io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125; Click to view code2(based on SA)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define uint unsigned int#define ull unsigned long long#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;const int MAXN=2e5;char s[MAXN+48];int len;int na,la[MAXN+48],ra[MAXN+48];int nb,lb[MAXN+48],rb[MAXN+48];int m;vector&lt;int&gt; v[MAXN+48];struct node&#123; int type,pos,len,id; node () &#123;&#125; inline node (int _t,int _p,int _l,int _i) &#123;type=_t;pos=_p;len=_l;id=_i;&#125; inline bool operator &lt; (const node &amp;other) const &#123; if (len!=other.len) return len&gt;other.len; return type&lt;other.type; &#125;&#125;str[MAXN*2+48];int stot;int lcp[MAXN+48],rnk[MAXN+48],sa[MAXN+48];namespace SA&#123; int fir[MAXN+48],sec[MAXN+48],tmp[MAXN+48],cnt[MAXN+48],maxind,tot; inline bool compare_sa(int x,int y,int k) &#123; if (fir[x]!=fir[y]) return fir[x]&lt;fir[y]; int tmp1=(x+k&lt;=len?fir[x+k]:-1),tmp2=(y+k&lt;=len?fir[y+k]:-1); return tmp1&lt;tmp2; &#125; inline void construct_sa() &#123; maxind='z'; memset(cnt+1,0,maxind&lt;&lt;2); for (register int i=1;i&lt;=len;i++) cnt[s[i]]++; for (register int i=1;i&lt;=maxind;i++) cnt[i]+=cnt[i-1]; for (register int i=len;i&gt;=1;i--) sa[cnt[s[i]]--]=i; fir[sa[1]]=1;for (register int i=2;i&lt;=len;i++) fir[sa[i]]=fir[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]); for (register int k=1;k&lt;=len;k&lt;&lt;=1) &#123; tot=0;memset(cnt+1,0,maxind&lt;&lt;2); for (register int i=len-k+1;i&lt;=len;i++) sec[++tot]=i; for (register int i=1;i&lt;=len;i++) if (sa[i]&gt;k) sec[++tot]=sa[i]-k; for (register int i=1;i&lt;=len;i++) cnt[fir[sec[i]]]++; for (register int i=1;i&lt;=maxind;i++) cnt[i]+=cnt[i-1]; for (register int i=len;i&gt;=1;i--) sa[cnt[fir[sec[i]]]--]=sec[i]; tmp[sa[1]]=1;for (register int i=2;i&lt;=len;i++) tmp[sa[i]]=tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i],k); memcpy(fir+1,tmp+1,len&lt;&lt;2);maxind=fir[sa[len]];if (maxind&gt;=len) break; &#125; &#125; inline void construct_lcp() &#123; for (register int i=1;i&lt;=len;i++) rnk[sa[i]]=i; int h=0; for (register int i=1;i&lt;=len;i++) &#123; int j=sa[rnk[i]-1]; if (h) h--; while (i+h&lt;=len &amp;&amp; j+h&lt;=len &amp;&amp; s[i+h]==s[j+h]) h++; lcp[rnk[i]-1]=h; &#125; &#125;&#125;int ST[MAXN+48][21],Log[MAXN+48];inline void init_ST()&#123; Log[0]=Log[1]=0;for (register int i=2;i&lt;=len;i++) Log[i]=Log[i&gt;&gt;1]+1; for (register int i=1;i&lt;=len-1;i++) ST[i][0]=lcp[i]; for (register int j=1;j&lt;=20;j++) for (register int i=1;i&lt;=len-1;i++) &#123; ST[i][j]=ST[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=len) check_min(ST[i][j],ST[i+(1&lt;&lt;(j-1))][j-1]); &#125;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return min(ST[l][Log[k]],ST[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int query_lcp(int pos1,int pos2)&#123; if (pos1&gt;pos2) swap(pos1,pos2); if (pos1==pos2) return len-sa[pos1]+1; return query_ST(pos1,pos2-1);&#125;vector&lt;int&gt; vv[MAXN*20+48];int d[MAXN*20+48],val[MAXN*20+48],sgt[MAXN+48],ps[MAXN+48];int seq[MAXN+48];inline bool cmpa(int x,int y) &#123;return rnk[la[x]]&lt;rnk[la[y]];&#125;inline void addedge(int x,int y) &#123;vv[x].pb(y);d[y]++;&#125;LL dp[MAXN*21+48];int head,tail,q[MAXN*21+48];inline LL solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=0; for (auto y : vv[cur]) check_max(dp[cur],solve(y)); return dp[cur]+=val[cur];&#125;inline Pair getrange(int id)&#123; int l,r,pos=na+1,mid,cmp=rb[id]-lb[id]+1; l=1;r=na; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (rnk[lb[id]]&lt;rnk[la[seq[mid]]]) pos=mid,r=mid-1; else l=mid+1; &#125; Pair res=mp(pos,pos-1); l=1;r=pos-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_lcp(rnk[la[seq[mid]]],rnk[lb[id]])&gt;=cmp) res.x=mid,r=mid-1; else l=mid+1; &#125; l=pos;r=na; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_lcp(rnk[la[seq[mid]]],rnk[lb[id]])&gt;=cmp) res.y=mid,l=mid+1; else r=mid-1; &#125; return res;&#125;int tot;namespace SegmentTree&#123; int lson[MAXN*20+48],rson[MAXN*20+48],Root; inline int Create() &#123;++tot;lson[tot]=rson[tot]=0;d[tot]=val[tot]=0;vv[tot].clear();return tot;&#125; inline void init() &#123;tot=nb;Root=Create();&#125; inline void insert(int cur,int last,int pos,int id,int l,int r) &#123; if (l==r) &#123;sgt[id]=cur;val[cur]=ra[id]-la[id]+1;return;&#125; lson[cur]=lson[last];rson[cur]=rson[last]; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) lson[cur]=Create(),insert(lson[cur],lson[last],pos,id,l,mid); else rson[cur]=Create(),insert(rson[cur],rson[last],pos,id,mid+1,r); &#125; inline void addinterval(int cur,int left,int right,int id,int l,int r) &#123; if (left&gt;right) return; if (!cur) return; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;addedge(id,cur);return;&#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) addinterval(lson[cur],left,right,id,l,mid); if (mid+1&lt;=right) addinterval(rson[cur],left,right,id,mid+1,r); &#125; inline void buildedge() &#123; for (register int cur=nb+1;cur&lt;=tot;cur++) &#123; if (lson[cur]) addedge(cur,lson[cur]); if (rson[cur]) addedge(cur,rson[cur]); &#125; &#125;&#125;inline void input()&#123; scanf("%s",s+1);len=strlen(s+1);stot=0; Get(na);for (register int i=1;i&lt;=na;i++) Get(la[i],ra[i]),str[++stot]=node(0,la[i],ra[i]-la[i]+1,i); Get(nb);for (register int i=1;i&lt;=nb;i++) Get(lb[i],rb[i]),str[++stot]=node(1,lb[i],rb[i]-lb[i]+1,i); Get(m);int x,y; for (register int i=1;i&lt;=na;i++) v[i].clear(); for (register int i=1;i&lt;=m;i++) Get(x,y),v[x].pb(y);&#125;bool visited[MAXN+48];inline void Clear()&#123; for (register int i=1;i&lt;=nb;i++) vv[i].clear(),d[i]=0,val[i]=0; for (register int i=1;i&lt;=na*20+nb;i++) dp[i]=-1; head=1;tail=0; SegmentTree::init();&#125;inline void solve()&#123; SA::construct_sa();SA::construct_lcp(); init_ST(); sort(str+1,str+stot+1); for (register int i=1;i&lt;=na;i++) seq[i]=i; sort(seq+1,seq+na+1,cmpa); for (register int i=1;i&lt;=na;i++) ps[seq[i]]=i; for (register int i=1;i&lt;=stot;i++) if (str[i].type==0) &#123; int curRoot=SegmentTree::Create(); SegmentTree::insert(curRoot,SegmentTree::Root,ps[str[i].id],str[i].id,1,na); SegmentTree::Root=curRoot; &#125; else &#123; Pair r=getrange(str[i].id); SegmentTree::addinterval(SegmentTree::Root,r.x,r.y,str[i].id,1,na); &#125; for (register int i=1;i&lt;=na;i++) for (register int j=0;j&lt;int(v[i].size());j++) addedge(sgt[i],v[i][j]); SegmentTree::buildedge(); for (register int i=1;i&lt;=tot;i++) if (!d[i]) q[++tail]=i; int cnt=0; while (head&lt;=tail) &#123; int cur=q[head++];cnt++; for (auto y : vv[cur]) &#123; d[y]--; if (!d[y]) q[++tail]=y; &#125; &#125; if (cnt&lt;tot) &#123;puts("-1");return;&#125; LL ans=0; for (register int i=1;i&lt;=tot;i++) check_max(ans,solve(i)); printf("%lld\n",ans);&#125;int main ()&#123;#ifndef ONLINE_JUDGE double T=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;Get(ca); while (ca--) &#123; input(); Clear(); solve(); &#125;#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-T)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>二分</category>
        <category>线段树</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>倍增</category>
        <category>主席树</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
        <tag>SAM</tag>
        <tag>倍增</tag>
        <tag>LOJ</tag>
        <tag>主席树</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ3052][十二省联考2019]春节十二响 题解]]></title>
    <url>%2Fblog%2Floj3052%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个$n$个节点的树，每个点有一个权值$v_i$。你可以把树上的节点分成若干组，要求每组中的任意两点不能有祖先－后代关系。 定义每个组的大小为该组内点权最大值，定义一个划分方案的权值为所有组的大小之和。求划分方案的最小权值。 $n\leq 2\times 10^5$ SolutionClick to view the solution数据中一条链的部分分对正解很有提示作用，然而笔者看错了题，使用了思路方向完全不同的贪心，从而只获得了暴力分。显然对于一条从根到叶子的链，这些节点两两不能分在同一组。对于一个根节点连出的两条链，我们考虑如何合并这两条链，感觉上，最大的和最大的，次大的和次大的合并，以此类推会比较好，因为两个很大的值不会分别占据一个组而是合在一起，可以少消耗一些空间。实践证明这个贪心是对的这样一个启发式合并的思路就很明显了。对于每个点我们维护以该点为根的子树内的点最终形成的一条链，可以用set维护使其有序。对于一个点的两个儿子，我们把链较短的那个的所有点往长的那个里面按照上面的贪心规则合并即可。总时间复杂度$O(nlog^2n)$。如果要去掉log可能需要考虑长链剖分，但这题双log能过笔者太懒 CodeClick to view the code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define uint unsigned int#define ull unsigned long long#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=2e5;int n;vector&lt;int&gt; v[MAXN+48];int M[MAXN+48];multiset&lt;int&gt; s[MAXN+48];int id[MAXN+48];int seq1[MAXN+48],seq2[MAXN+48];inline int merge(int root1,int root2)&#123; if (!root1 || !root2) return root1^root2; if (int(s[root1].size())&lt;int(s[root2].size())) swap(root1,root2); int sz=int(s[root2].size()),cnt=1; for (multiset&lt;int&gt;::iterator iter1=s[root1].begin(),iter2=s[root2].begin();cnt&lt;=sz;cnt++,iter1++,iter2++) seq1[cnt]=-(*iter1),seq2[cnt]=-(*iter2); for (register int i=1;i&lt;=sz;i++) s[root1].erase(s[root1].begin()); for (register int i=1;i&lt;=sz;i++) s[root1].insert(-max(seq1[i],seq2[i])); return root1;&#125;inline void dfs(int cur)&#123; if (!int(v[cur].size())) &#123; id[cur]=cur; s[cur].insert(-M[cur]); return; &#125; id[cur]=0; for (auto y : v[cur]) dfs(y),id[cur]=merge(id[cur],id[y]); s[id[cur]].insert(-M[cur]);&#125;int main ()&#123;#ifndef ONLINE_JUDGE freopen ("a.in","r",stdin); freopen ("a.out","w",stdout);#endif Get(n);int x; for (register int i=1;i&lt;=n;i++) Get(M[i]); for (register int i=2;i&lt;=n;i++) Get(x),v[x].pb(i); dfs(1); LL ans=0; for (multiset&lt;int&gt;::iterator iter=s[id[1]].begin();iter!=s[id[1]].end();iter++) ans-=(*iter); printf("%lld\n",ans);return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>贪心</category>
        <category>启发式合并</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>LOJ</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ3048][十二省联考2019]异或粽子 题解]]></title>
    <url>%2Fblog%2Floj3048%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有$n$个数$a_1,a_2,\dots a_n$，定义一个区间$[l,r]$的权值为$a_l$到$a_r$的异或和。 现要求找出权值最大的前$k$个区间（不能重复选同一个区间），求这些区间的权值和。 $n\leq 500000,max_{i=1}^n a_i\leq 2^{32}$ SolutionClick to view the solution这题在考场上写二分答案log方成功被卡成暴力分我们先做一个转化，求出数列$a_i$的前缀异或和数组$xsum_i$，这样区间$[l,r]$的权值等于$xsum_{l-1} \oplus xsum_r$。对于这种求前$k$大的题目，一般的思路是将所有的方案分成若干类，维护一个堆，先将所有类的最大值插入堆，然后每次取堆顶后，将该元素对应类的次大加入堆，以此类推。这里一个天然的分类方法就是按照区间的右端点分类。那么我们现在只要解决一个问题：对于一个给定的数$r$，以$r$为右端点的权值第$k$大的区间是哪个？这个问题等价于求在$0$到$r-1$中和$xsum_r$异或值第$k$大的数$xsum_{pos}$，到这一步思路很明显了，我们对$xsum_i$数组建一棵可持久化Trie树，对于查询$(r,k)$，我们抓着$xsum_r$在对应的Trie树上二分，类似于线段树二分的技巧，如果当前位$xsum_i$为$0$，就先看$1$儿子子树内数的个数是否超过$k$来判断下一步往哪里走，否则就先看$0$儿子的子树。这样查询的复杂度是单log的。总时间复杂度$O(n\cdot 32)$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=5e5;int n,k;uint a[MAXN+18],xsum[MAXN+48];int root[MAXN+48];namespace Trie&#123; int nxt[MAXN*33+48][2],cnt[MAXN*33+48],tot; inline int Create() &#123;++tot;nxt[tot][0]=nxt[tot][1]=0;cnt[tot]=0;return tot;&#125; inline void init() &#123; tot=0;root[0]=Create();int cur=root[0];cnt[cur]=1; for (register int i=31;i&gt;=0;i--) &#123; nxt[cur][0]=Create(); cur=nxt[cur][0];cnt[cur]++; &#125; &#125; inline void insert(int &amp;cur,int last,uint val,int layer) &#123; if (!cur) cur=Create(); nxt[cur][0]=nxt[last][0];nxt[cur][1]=nxt[last][1];cnt[cur]=cnt[last]+1; if (layer==-1) return; int w=(val&gt;&gt;layer&amp;1);nxt[cur][w]=Create(); insert(nxt[cur][w],nxt[last][w],val,layer-1); &#125; inline uint query(int cur,int k,uint val,int layer) &#123; if (layer==-1) return 0; int w=((val&gt;&gt;layer&amp;1)^1),cmp=cnt[nxt[cur][w]]; if (k&lt;=cmp) return query(nxt[cur][w],k,val,layer-1)|(1ll&lt;&lt;layer); else return query(nxt[cur][w^1],k-cmp,val,layer-1); &#125;&#125;struct node&#123; uint val;int pos,rnk; node () &#123;&#125; inline node (uint _v,int _p,int _r) &#123;val=_v;pos=_p;rnk=_r;&#125; inline bool operator &lt; (const node &amp;other) const &#123;return val&lt;other.val;&#125;&#125;;priority_queue&lt;node&gt; q;int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n,k); for (register int i=1;i&lt;=n;i++) Get(a[i]); xsum[1]=a[1];for (register int i=2;i&lt;=n;i++) xsum[i]=xsum[i-1]^a[i]; Trie::init();for (register int i=1;i&lt;=n;i++) root[i]=Trie::Create(),Trie::insert(root[i],root[i-1],xsum[i],31); for (register int i=1;i&lt;=n;i++) q.push(node(Trie::query(root[i-1],1,xsum[i],31),i,1)); LL ans=0; while (k--) &#123; int pos=q.top().pos,rnk=q.top().rnk;ans+=q.top().val;q.pop(); if (rnk==pos) continue; q.push(node(Trie::query(root[pos-1],rnk+1,xsum[pos],31),pos,rnk+1)); &#125; printf("%lld\n",ans);#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>Trie树</category>
        <category>可持久化Trie树</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>LOJ</tag>
        <tag>Trie树</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ3051][十二省联考2019]皮配 题解]]></title>
    <url>%2Fblog%2Floj3051%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 无法概括，直接看题面。 SolutionClick to view the solution最喜欢这种大dp题了，虽然考场开小数组挂成暴力先考虑$k=0$的情况。仔细分析可以发现，城市对阵营的选择和学校对导师的选择是独立的。因为不论该城市选择哪个阵营，学校都可以加入鸭派系或R派系。因此可以分开来做两个$dp$。$dp1[i][j]$表示考虑到第$i$个城市，现在红阵营共有$j$个人的方案数，转移非常显然。$dp2[i][j]$表示考虑到第$i$个学校，现在鸭派系共有$j$个人的方案数，两个dp是一样的。最后两个dp分别把合法的答案累加，再把两个答案乘起来即可。结合朴素暴力这样可以获得$70$分。当$k\neq 0$的时候情况变得复杂，因为对于那些有偏好的学校，阵营的选择是会对派系产生影响的。我们先把不包含任何特殊学校的城市拿出来，这些城市对阵营的选择和之前无异，直接套用上面的$dp1$。我们再把所有的没有偏好的学校拿出来，不论城市怎么选这些学校可以自由的选择派系，直接套用上面的$dp2$。接下来我们要决策的是$k$个特殊学校和所有包含特殊学校的城市。我们把特殊学校排成一排，保证来自同一个城市的学校相邻。令$dp[i][j][k][0/1]$表示当前考虑到第$i$所学校，已经决策过的城市中选择红阵营的总人数为$j$，已经决策过的学校中选择鸭派系的总人数为$k$，当前学校所在城市选择了红/蓝阵营。因为保证一个学校的人数不超过$10$，所以总状态数为$30\times 2500\times 300\times 2$，可以承受。转移的时候，每到一个新城市的第一个学校，要决策一下当前城市选择的阵营，学校的决策和$dp2$差不多，注意一下如果有偏好就只能选择另一边。三个$dp$做完后我们考虑如何合并。对于一个状态$dp[i][j][k][0/1]$，$j$会对$dp1$的人数进行约束，如果太多会超过限制，如果太少另一边的人数会超过限制。推一下发现合法的范围是一个区间。同理$k$对$dp2$的约束也是一个区间。所以我们只要预处理$dp1$和$dp2$的前缀和数组，就可以$O(1)$对每个状态合并答案了。总时间复杂度$O(n^2+10\cdot nk^2)$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define uint unsigned int#define ull unsigned long long#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; char ch;bool f;T res; while (!isdigit(ch=getchar()) &amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1000;const int MAXM=2500;int n,c,k;int C0,C1,D0,D1;int num[MAXN+48];vector&lt;int&gt; v[MAXN+48];int cnt[MAXN+48],bel[MAXN+48];int type[MAXN+48];bool spe[MAXN+48];vector&lt;int&gt; city1,school1,city2;int dp1[MAXN+48][MAXM+48],dp2[MAXN+48][MAXM+48];int sum1[MAXM+48],sum2[MAXM+48];int dp[2][31][MAXM+48][301];int all;inline void Clear()&#123; all=0; for (register int i=1;i&lt;=n;i++) cnt[i]=0,v[i].clear(),type[i]=-1,spe[i]=false,bel[i]=0; city1.clear();city2.clear();school1.clear(); for (register int i=0;i&lt;=c;i++) for (register int j=0;j&lt;=C0;j++) dp1[i][j]=0; for (register int i=0;i&lt;=n;i++) for (register int j=0;j&lt;=D0;j++) dp2[i][j]=0; for (register int i=0;i&lt;=C0;i++) sum1[i]=0; for (register int i=0;i&lt;=D0;i++) sum2[i]=0; for (register int op=0;op&lt;=1;op++) for (register int i=0;i&lt;=k;i++) for (register int j=0;j&lt;=C0;j++) for (register int m=0;m&lt;=i*10;m++) dp[op][i][j][m]=0;&#125;inline void doit_dp1()&#123; dp1[0][0]=1; int numc=int(city1.size()); for (register int i=0;i&lt;numc;i++) &#123; int cur=city1[i]; for (register int j=0;j&lt;=C0;j++) if (dp1[i][j]) &#123; if (cnt[cur] &amp;&amp; j+cnt[cur]&lt;=C0) Add(dp1[i+1][j+cnt[cur]],dp1[i][j]); Add(dp1[i+1][j],dp1[i][j]); &#125; &#125; sum1[0]=dp1[numc][0]; for (register int i=1;i&lt;=C0;i++) sum1[i]=add(sum1[i-1]+dp1[numc][i]); dp2[0][0]=1; int numn=int(school1.size()); for (register int i=0;i&lt;numn;i++) &#123; int cur=school1[i]; for (register int j=0;j&lt;=D0;j++) if (dp2[i][j]) &#123; if (j+num[cur]&lt;=D0) Add(dp2[i+1][j+num[cur]],dp2[i][j]); Add(dp2[i+1][j],dp2[i][j]); &#125; &#125; sum2[0]=dp2[numn][0]; for (register int i=1;i&lt;=D0;i++) sum2[i]=add(sum2[i-1]+dp2[numn][i]);&#125;inline int query1(int l,int r)&#123; if (l&gt;r) return 0; l=max(l,0); return sub(sum1[r]-((l==0)?0:sum1[l-1]));&#125;inline int query2(int l,int r)&#123; if (l&gt;r) return 0; l=max(l,0); return sub(sum2[r]-((l==0)?0:sum2[l-1]));&#125;int seq[MAXN+48],block[MAXN+48],tot;inline void doit_dp2()&#123; dp[0][0][0][0]=1; for (register int i=0;i&lt;tot;i++) for (register int j=0;j&lt;=C0;j++) for (register int m=0;m&lt;=300;m++) &#123; if (dp[0][i][j][m]) &#123; if (block[i+1]==block[i]) &#123; if (type[seq[i+1]]!=0) Add(dp[0][i+1][j][m+num[seq[i+1]]],dp[0][i][j][m]); if (type[seq[i+1]]!=1) Add(dp[0][i+1][j][m],dp[0][i][j][m]); &#125; else &#123; if (j+cnt[block[i+1]]&lt;=C0) &#123; if (type[seq[i+1]]!=0) Add(dp[0][i+1][j+cnt[block[i+1]]][m+num[seq[i+1]]],dp[0][i][j][m]); if (type[seq[i+1]]!=1) Add(dp[0][i+1][j+cnt[block[i+1]]][m],dp[0][i][j][m]); &#125; if (type[seq[i+1]]!=2) Add(dp[1][i+1][j][m+num[seq[i+1]]],dp[0][i][j][m]); if (type[seq[i+1]]!=3) Add(dp[1][i+1][j][m],dp[0][i][j][m]); &#125; &#125; if (dp[1][i][j][m]) &#123; if (block[i+1]==block[i]) &#123; if (type[seq[i+1]]!=2) Add(dp[1][i+1][j][m+num[seq[i+1]]],dp[1][i][j][m]); if (type[seq[i+1]]!=3) Add(dp[1][i+1][j][m],dp[1][i][j][m]); &#125; else &#123; if (j+cnt[block[i+1]]&lt;=C0) &#123; if (type[seq[i+1]]!=0) Add(dp[0][i+1][j+cnt[block[i+1]]][m+num[seq[i+1]]],dp[1][i][j][m]); if (type[seq[i+1]]!=1) Add(dp[0][i+1][j+cnt[block[i+1]]][m],dp[1][i][j][m]); &#125; if (type[seq[i+1]]!=2) Add(dp[1][i+1][j][m+num[seq[i+1]]],dp[1][i][j][m]); if (type[seq[i+1]]!=3) Add(dp[1][i+1][j][m],dp[1][i][j][m]); &#125; &#125; &#125;&#125;inline void solve()&#123; Get(n,c); Get(C0,C1,D0,D1); Clear(); int b,s,id; for (register int i=1;i&lt;=n;i++) &#123; Get(b,s);all+=s; v[b].pb(i);cnt[b]+=s; num[i]=s;bel[i]=b; &#125; Get(k); for (register int i=1;i&lt;=k;i++) &#123; Get(id);Get(type[id]); spe[bel[id]]=true; &#125; for (register int i=1;i&lt;=c;i++) if (!spe[i]) city1.pb(i); else city2.pb(i); for (register int i=1;i&lt;=n;i++) if (type[i]==-1) school1.pb(i); doit_dp1(); tot=0; for (register int i=0;i&lt;int(city2.size());i++) &#123; int curcity=city2[i]; for (register int j=0;j&lt;int(v[curcity].size());j++) if (type[v[curcity][j]]!=-1) &#123; seq[++tot]=v[curcity][j]; block[tot]=curcity; &#125; &#125; doit_dp2(); int ans=0,l,r; for (register int op=0;op&lt;=1;op++) for (register int j=0;j&lt;=C0;j++) for (register int m=0;m&lt;=300;m++) &#123; int tmpans=dp[op][tot][j][m]; if (tmpans==0) continue; l=all-C1-j;r=C0-j; tmpans=1ll*tmpans*query1(l,r)%MOD; l=all-D1-m;r=D0-m; tmpans=1ll*tmpans*query2(l,r)%MOD; Add(ans,tmpans); &#125; printf("%d\n",ans);&#125;int main ()&#123; int ca;Get(ca); while (ca--) &#123; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TCO2012 AlgorithmRound2ADIV1C]EvenPaths 题解]]></title>
    <url>%2Fblog%2Ftco2012algorithmround3adiv1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给一张有$n$个点的DAG，编号$0,1,\dots n-1$。 每个点有一个状态，若是”-“表示该点肯定没有障碍物，若是”?”表示该点可能有障碍物。 对于一个确定了每个点是否有障碍物的DAG，定义它是美丽的，当且仅当从$0$号点到$1$号点有偶数条路径。 记状态是”?”的点的个数为$k$，求在$2^k$种DAG中有多少种是美丽的。 $n\leq 50,k\leq 32$ SolutionClick to view the solution这是一道神题，每一步都想不到出题人说$k$的范围是很有提示性的，但我并没有看出来如果是一张已经确定的DAG，那么求从$0$到$1$的路径条数的奇偶性是非常容易的，只需要在DAG上跑一个$dp$即可，甚至我们的$dp$状态只要用$0$和$1$来表示奇偶即可。然而现在看不出什么用现在有$32$个问号，如果一一穷举所有的DAG复杂度是$O(2^{32}\cdot n)$，显然是不行的。$32$的特殊之处在于它本身有点大，但它的一半不大只有$16$可以承受指数级的暴力。所以不妨考虑折半搜索？然而不知该怎样折半且不知折半后怎样合并信息设问号一共有$t$个，称这些点为关键点。我们先跑一个原图的拓扑序，这样我们就可以理所应当的把前$\frac{t}{2}$个关键点划分为第一组，后$\frac{t}{2}$个关键点划分为第二组，特别的，我们把$1$号点也加入第二组，但记住$1$号点并不是关键点。接下来比较关键。我们跑两个$dp$。在枚举一个Mask1表示第一组所有关键点的障碍物情况后，第一个$dp1[i]$表示从$0$出发，不经过任何障碍物点和第二组中的点，到达第二组中第$i$个点路径条数的奇偶性（最后抵达的那一下不算经过）。可以看出这个$dp$的答案和第二组中关键点的障碍物情况无关。因为所有的$dp$状态都是$0$或$1$，所以可以将这最多$17$个状态压成一个二进制数。这样我们会获得”Mask1的个数”那么多个二进制数。在枚举一个Mask2表示第二组所有关键点的障碍物情况后，第二个$dp2[i]$表示从第二组的第$i$个点出发，不经过任何障碍物点和第一组中的点，到达$1$号点的路径条数的奇偶性。同样一个Mask2下的$dp$状态可以压成一个二进制数，我们又获得了”Mask2的个数”那么多个二进制数。这个做法的妙处在于，对于一条路径，记其中最早出现的属于第二组的点为$x$（因为$1$号点也在第二组中所以$x$一定存在）,那么$x$之前的路径一定在$dp1[x]$中记过，$x$之后的路径一定在$dp2[x]$中记过，这样任意一条路径都被我们拆成了可合并的两个部分。我们考虑任意一组Mask1和Mask2对应的$dp1$数组和$dp2$数组，此时路径的总条数的奇偶性等价于$\sum dp1[i]\cdot dp2[i]$的奇偶性，转化成二进制数$b1,b2$后，等价于$b1 \&amp; b2$中$1$的个数的奇偶性。如果我们两两枚举Mask去做与操作的话，复杂度又变成了$O(2^{32})$。考虑到两种二进制数中都有重复的，我们令$cntA[i]$表示$i$这个数在第一组生成的二进制数中出现了几次，$cntB[i]$同理，令$res[i]$表示与结果为$i$的Mask有多少对，我们有$$res[x]=\sum_{i\&amp;j=x}cntA[i]\cdot cntB[j]$$这是一个喜闻乐见的与卷积，可以用FWT优化，从而复杂度降为$O(2^{17}\cdot 17)$。最后对于每种$1$的个数为偶数的Mask累加$res$即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))#define rep(i,l,r) for (register int i=int(l);i&lt;=int(r);i++)#define REP(i,r,l) for (register int i=int(r);i&gt;=int(l);i--)const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template&lt;typename T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:(-res)); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template&lt;typename T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; template&lt;typename T1,typename ...T2&gt; inline void Print(T1 &amp;x,T2 &amp;...y) &#123;Print(x,' ');Print(y...,' ');Writechar('\n');&#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;template&lt;typename T&gt; inline T add(T x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;template&lt;typename T&gt; inline T add(T x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;template&lt;typename T&gt; inline T sub(T x) &#123;if (x&lt;0) x+=MOD;return x;&#125;template&lt;typename T&gt; inline T sub(T x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;template&lt;typename T&gt; inline T mul(T x,T y) &#123;return 1ll*x*y%MOD;&#125;template&lt;typename T&gt; inline T mul(T x,T y,int MO) &#123;return 1ll*x*y%MO;&#125;template&lt;typename T&gt; inline void Add(T &amp;x,T y) &#123;x=add(x+y);&#125;template&lt;typename T&gt; inline void Add(T &amp;x,T y,int MO) &#123;x=add(x+y,MO);&#125;template&lt;typename T&gt; inline void Sub(T &amp;x,T y) &#123;x=sub(x-y);&#125;template&lt;typename T&gt; inline void Sub(T &amp;x,T y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline void Mul(T &amp;x,T y) &#123;x=mul(x,y);&#125;template&lt;typename T&gt; inline void Mul(T &amp;x,T y,int MO) &#123;x=mul(x,y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int ga[148][148],n;vector&lt;int&gt; v[148],vv[148];int d[148];int seq[148],tot,head,tail,q[148];int spe[148],stot;bool isleft[148],isright[148];int id[148],lsz,rsz;int dp[148];LL cntA[600048],cntB[600048],res[600048];namespace polynomial&#123; inline void poly_fwt(LL c[],int len,int fl) &#123; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) for (register int j=0;j&lt;len;j+=clen) for (register int k=j;k&lt;(j+(clen&gt;&gt;1));k++) if (fl==1) c[k]+=c[k+(clen&gt;&gt;1)]; else c[k]-=c[k+(clen&gt;&gt;1)]; &#125; inline void poly_fwtmul(LL A[],LL B[],int N,int M,LL C[]) &#123; int len=1;while (len&lt;=N+M) len&lt;&lt;=1; memset(A+N,0,(len-N)*sizeof(LL)); memset(B+M,0,(len-M)*sizeof(LL)); poly_fwt(A,len,1);poly_fwt(B,len,1); for (register int i=0;i&lt;len;i++) C[i]=A[i]*B[i]; poly_fwt(C,len,-1); &#125;&#125;class EvenPaths&#123; public: inline LL theCount(vector&lt;string&gt; maze,string room) &#123; n=int(maze.size()); rep(i,1,n) d[i]=0,v[i].clear(),vv[i].clear(); rep(i,1,n) rep(j,1,n) if (maze[i-1][j-1]=='Y') v[i].pb(j),vv[j].pb(i),d[j]++; head=1;tail=0;tot=stot=0; rep(i,1,n) if (!d[i]) q[++tail]=i; while (head&lt;=tail) &#123; int cur=q[head++];seq[++tot]=cur; if (room[cur-1]=='?') spe[++stot]=cur; rep(i,0,int(v[cur].size())-1) &#123; int y=v[cur][i]; d[y]--;if (!d[y]) q[++tail]=y; &#125; &#125; int mid=(stot&gt;&gt;1); rep(i,1,n) isleft[i]=isright[i]=false,id[i]=0; rep(i,1,mid) isleft[spe[i]]=true,id[spe[i]]=i; rep(i,mid+1,stot) isright[spe[i]]=true,id[spe[i]]=i-mid; lsz=mid;rsz=stot-mid; rep(Mask,0,(1&lt;&lt;(rsz+1))-1) cntA[Mask]=cntB[Mask]=0; rep(Mask,0,(1&lt;&lt;lsz)-1) &#123; dp[1]=1; rep(i,1,n) &#123; int cur=seq[i];if (cur==1) continue;dp[cur]=0; if (isleft[cur] &amp;&amp; (Mask&amp;(1&lt;&lt;(id[cur]-1)))) continue; rep(j,0,int(vv[cur].size())-1) &#123; int pre=vv[cur][j]; if (!isright[pre]) dp[cur]=(dp[cur]^dp[pre])&amp;1; &#125; &#125; int bit=0; rep(i,mid+1,stot+1) &#123; int cur=(i&lt;=stot?spe[i]:2); bit|=((dp[cur]&amp;1)&lt;&lt;(i-mid-1)); &#125; cntA[bit]++; &#125; rep(Mask,0,(1&lt;&lt;rsz)-1) &#123; dp[2]=1; REP(i,n,1) &#123; int cur=seq[i];if (cur==2) continue;dp[cur]=0; if (isright[cur] &amp;&amp; (Mask&amp;(1&lt;&lt;(id[cur]-1)))) continue; if (isleft[cur]) continue; rep(j,0,int(v[cur].size())-1) &#123; int to=v[cur][j]; dp[cur]=(dp[cur]^dp[to])&amp;1; &#125; &#125; int bit=0; rep(i,mid+1,stot+1) &#123; int cur=(i&lt;=stot?spe[i]:2); bit|=((dp[cur]&amp;1)&lt;&lt;(i-mid-1)); &#125; cntB[bit]++; &#125; polynomial::poly_fwtmul(cntA,cntB,(1&lt;&lt;(rsz+1)),(1&lt;&lt;(rsz+1)),res); LL ans=0; rep(Mask,0,(1&lt;&lt;(rsz+1))-1) if (~__builtin_popcount(Mask)&amp;1) ans+=res[Mask]; return ans; &#125;&#125;;/*--- Debug Part ---*//*int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int nn;string s;vector&lt;string&gt; aa,bb; EvenPaths A; while (cin&gt;&gt;nn) &#123; aa.clear(); rep(i,1,nn) cin&gt;&gt;s,aa.pb(s); cin&gt;&gt;s; cout&lt;&lt;A.theCount(aa,s)&lt;&lt;endl; &#125; io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;*/]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>图论</category>
        <category>Dynamic Programming</category>
        <category>多项式</category>
        <category>折半搜索</category>
        <category>FWT</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>TopCoder</tag>
        <tag>折半搜索</tag>
        <tag>FWT</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM558DIV1C]SurroundingGame 题解]]></title>
    <url>%2Fblog%2Ftcsrm558div1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给一个$n\times m$的棋盘，每个格子上有两个数，分别表示在这个格子上放棋子的代价和占领这个格子的收益。 一个格子被占领，当且仅当该格子有棋子，或与该格子相邻的格子都有棋子。 定义一种棋子放置方案的分数为收益之和减去代价之和，求最大分数。 $n,m\leq 20$ SolutionClick to view the solution看到数据范围大概有两种思路，一个是轮廓线状压dp一个是网络流。仔细想想状压dp发现怎么都是$3^n\cdot n^2$的，那就往网络流方向想吧。借鉴一下UVa的一道叫草塘的题的思路。考虑建立最小割模型，和源点相连的表示选了，和汇点相连的表示没选。这样如果割与S相连的边就表示没选，代价为benefit，如果割与T相连的边就表示选了，代价为cost。感觉上最后用benefit之和减去最小割大致就是答案。这个模型是十分粗糙的，我们还完全没有考虑如何处理如果相邻格子全部有棋子这个格子即使不放棋子也有收益的情况，所以在这里就去设计一些代价为benefit的边是十分草率的。稍加思考我们发现被占领的两种条件可以转化为一句话：如果有两个相邻的格子都没有放棋子，那么这两个格子就都没有被占领。我们希望在这种情况下在图上可以割某条边表示扣除这两个点的benefit,但根据我们之前的建图，没有被选的点都在一边，无法实现这个操作。非常自然的可以想到给棋盘黑白染色，这样相邻的两个格子一定一个是黑格子一个是白格子。对于黑格子我们向S连代价为cost的边，对于白格子我们向T连代价为cost的边，再在相邻的黑格子和白格子之间连边代价为两个点的benefit之和，这样如果相邻的黑格子和白格子都没有选，就会形成一条通路，割掉中间的边表示扣除它们的收益之和。这个模型已经精细了很多，但问题也是明显的：某些格子的收益可能会被重复扣除（那些周围有多个格子没有放棋子的格子）。所以我们希望收益的扣除是基于格子的，而不是基于格子之间的相邻关系，否则无法控制不重不漏。在上述模型的基础上做小小的改进。考虑拆点，将一个格子拆成两个点，1号点向2号点连benefit的边。对于一组相邻的格子，分别在1号点之间和2号点之间连代价为INF的边，表示这条边不可割，只是描述相邻关系。之前提到的代价为cost的边，对于S连到对应格子的1号点，对于T连到对应格子的2号点。这样，我们发现确实可以扣除相邻的两个空格子的benefit之和且不会重复。这个建图还是相当有难度的 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define uint unsigned int#define ull unsigned long long#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;int n,m;int dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,1,0,-1&#125;;namespace flow&#123; const int MAXN=1e5; int head[MAXN+48],cur[MAXN+48],nxt[MAXN+48],to[MAXN+48],f[MAXN+48],tot=1,t; inline void init(int _t) &#123;t=_t;tot=1;memset(head,0,sizeof(head));&#125; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int Head,Tail,q[MAXN+48],depth[MAXN+48]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;Head=Tail=1;q[1]=0; while (Head&lt;=Tail) &#123; int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; return depth[t]!=-1; &#125; inline int dfs(int x,int maxf) &#123; if (x==t) return maxf; int y,minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; &#125; &#125; if (!ans) depth[x]=0; return ans; &#125; inline int dinic() &#123; int res=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; res+=dfs(0,INF); &#125; return res; &#125;&#125;class SurroundingGame&#123; inline int getind(int x,int y,int op) &#123;return (x-1)*m+y+op*n*m;&#125; inline int getval(char ch) &#123; if (isdigit(ch)) return ch-'0'; if (islower(ch)) return ch-'a'+10; return ch-'A'+36; &#125; public: inline int maxScore(vector&lt;string&gt; cost,vector&lt;string&gt; benefits) &#123; n=int(cost.size());m=int(cost[0].size()); flow::init(n*m*2+1);int ans=0; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) &#123; int B=getval(benefits[i-1][j-1]),C=getval(cost[i-1][j-1]); ans+=B;flow::addedge(getind(i,j,0),getind(i,j,1),B); if ((i+j)&amp;1) &#123; flow::addedge(0,getind(i,j,0),C); for (register int dir=0;dir&lt;=3;dir++) &#123; int x=i+dx[dir],y=j+dy[dir]; if (1&lt;=x &amp;&amp; x&lt;=n &amp;&amp; 1&lt;=y &amp;&amp; y&lt;=m) &#123; flow::addedge(getind(i,j,0),getind(x,y,0),INF); flow::addedge(getind(i,j,1),getind(x,y,1),INF); &#125; &#125; &#125; else flow::addedge(getind(i,j,1),flow::t,C); &#125; return ans-flow::dinic(); &#125;&#125;;/*--- Debug Part ---*//*int main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); int nn;vector&lt;string&gt; v1,v2;string s; SurroundingGame A; while (cin&gt;&gt;nn) &#123; v1.clear();v2.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,v1.pb(s); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,v2.pb(s); cout&lt;&lt;A.maxScore(v1,v2)&lt;&lt;endl; &#125; return 0;&#125;*/]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>最小割</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM697DIV1C]ConnectedStates 题解]]></title>
    <url>%2Fblog%2Ftcsrm697div1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有$n$个国家，第$i$个国家有$a_i$个城市。 现在要在$n$个国家之间连$n-1$条边，使得国家构成一棵树，在两个国家连边等价于从两个国家中各任选一个城市连边。 问有多少种不同的连边方案，模$10^9+7$。 $n\leq 2000$ SolutionClick to view solution1(based on EGF)考虑一棵树的Prufer编码，一个节点的度数相当于它在Prufer编码中出现的次数加一。不妨设$n$个节点在Prufer编码中出现的次数分别是$c_1,c_2,\dots ,c_n$，满足这样条件的Prufer序列共有$\frac{(n-2)!}{c_1!c_2!\dots c_n!}$。所以我们最后的答案是$$\sum_{\sum c_i=n-2}\frac{(n-2)!}{\Pi c_i!}\Pi a_i^{c_i+1}\Pi {c_i+1}$$化简，得$$(n-2)!\sum_{\sum c_i=n-2}\prod_{i=1}^n\frac{a_i^{c_i+1}\cdot (c_i+1)}{c_i!}$$前面的$\Sigma$的条件让人容易想到生成函数，如果我们能构造出每个节点的生成函数，然后将它们乘起来即可。令$$\begin{aligned}P_i &amp;= \sum_{j=0}^{\infty}\frac{a_i^{j+1}\cdot (j+1)}{j!}x^j \\&amp;= \sum_{j=0}^{\infty}\frac{a_i^{c_i+1}}{j!}x^j+\sum_{j=0}^{\infty}\frac{a_i^{c_i+1}\cdot j}{j!}x^j \\&amp;= a_i\sum_{j=0}^{\infty}\frac{(a_ix)^j}{j!}+(a_i^2x)\sum_{j=0}^{\infty}\frac{(a_ix)^j}{j!} \\&amp;=(a_i+a_i^2x)\exp(a_ix)\end{aligned}$$将所有的$P_i$乘起来，我们有$$\prod_{i=1}^nP_i=\prod_{i=1}^n(a_i+a_i^2x)\exp(a_ix)=\prod_{i=1}^n(a_i+a_i^2x)\exp(\sum_{i=1}^na_ix)$$只要将上述式子暴力乘起来，最后把$\exp$展开取$x^{n-2}$的系数再乘上$(n-2)!$即可，总时间复杂度$O(n^2)$。如果用三模数的话可以分治NTT做到$O(nlog^2n)$ Click to view solution2(based on Dynamic Programming)如果你不了解指数型生成函数的相关推论，可以去膜来自caoxia的dp做法。我们考虑任意一个Prufer序列对答案的贡献。我们在Prufer序列后面添加一个$1,2,\dots,n$的序列，这样每个数出现的次数就等于这个点的度数，我们把这个序列称为Prufer+序列。设$1,2,\dots,n$在序列中分别出现了$c_1,c_2,\dots,c_n$次，则该序列的贡献为$$\prod_{i=1}^na_i^{c_i}c_i$$给这个式子赋予一个组合含义：对于每一种数$i$，设它在Prufer+序列中出现的位置为$P_{i,1},P_{i,2},\dots,P_{i,c_i}$，我们从中挑一个位置给其染色，这样一个Prufer+序列的染色方案数再乘上每个位置的数对应的$a_i$就等于上式的贡献。考虑$dp$。令$dp[i][j]$表示当前考虑到第$i$种数，这$i$种数中有$j$种是在前$n-2$个位置中挑了一个染色，那么显然剩下的$i-j$种数是在后面的$1$到$n$染色的。我们的思路是：从一个空的Prufer序列开始，如果当前数选择在前面染色，那么就将染了色的这个数字在Prufer序列中挑一个位置放下来，最后我们会得到一个剩余一些空位的Prufer序列，这些空位显然可以放任何一种没有染色的数，再乘上贡献就好。考虑$dp$的转移。我们有$$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]\cdot a[i]\cdot (n-2-j+1)$$前者表示在后面染色，后者表示将一个染好色的数选择一个空位放置，不要忘了乘上这个数对应的$a_i$。统计答案的时候，对于状态$dp[n][j]$，前面还有$n-2-j$个空位，每个空位放任意数，所以应乘上$(\sum a_i)^{n-2-j}$。最后别忘了Prufer+序列的最后$n$个数的$a_i$还没算，所以答案要再乘上$\prod a_i$。 CodeClick to view code1(EGF)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=2000;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=1ll*res*x%MOD; x=1ll*x*x%MOD;y&gt;&gt;=1; &#125; return res;&#125;class ConnectedStates&#123; int n,a[MAXN+48],exp[MAXN+48]; public: inline int getSum(vector&lt;int&gt; sz) &#123; n=int(sz.size()); int tot=0;for (register int i=1;i&lt;=n;i++) a[i]=sz[i-1],Add(tot,a[i]); exp[0]=1;for (register int i=1;i&lt;=n-2;i++) exp[i]=1ll*exp[i-1]*i%MOD; exp[n-2]=quick_pow(exp[n-2],MOD-2); for (register int i=n-3;i&gt;=0;i--) exp[i]=1ll*exp[i+1]*(i+1)%MOD; int pw=1;for (register int i=0;i&lt;=n-2;i++,pw=1ll*pw*tot%MOD) exp[i]=1ll*exp[i]*pw%MOD; for (register int i=1;i&lt;=n;i++) for (register int j=n-2;j&gt;=1;j--) Add(exp[j],1ll*exp[j-1]*a[i]%MOD); int ans=exp[n-2]; for (register int i=1;i&lt;=n;i++) ans=1ll*ans*a[i]%MOD; for (register int i=1;i&lt;=n-2;i++) ans=1ll*ans*i%MOD; return ans; &#125;&#125;;/*--- Debug Part ---*//*int main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); vector&lt;int&gt; vv;int nn,x;ConnectedStates A; while (cin&gt;&gt;nn) &#123; vv.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,vv.pb(x); cout&lt;&lt;A.getSum(vv)&lt;&lt;endl; &#125; return 0;&#125;*/ Click to view code2(Dynamic Programming)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// I'll always miss you like a darling.include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))#define rep(i,l,r) for (register int i=int(l);i&lt;=int(r);i++)#define REP(i,l,r) for (register int i=int(r);i&gt;=int(l);i--)const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template&lt;typename T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:(-res)); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template&lt;typename T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; template&lt;typename T1,typename ...T2&gt; inline void Print(T1 &amp;x,T2 &amp;...y) &#123;Print(x,' ');Print(y...,' ');Writechar('\n');&#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;template&lt;typename T&gt; inline T add(T x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;template&lt;typename T&gt; inline T add(T x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;template&lt;typename T&gt; inline T sub(T x) &#123;if (x&lt;0) x+=MOD;return x;&#125;template&lt;typename T&gt; inline T sub(T x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;template&lt;typename T&gt; inline T mul(T x,T y) &#123;return 1ll*x*y%MOD;&#125;template&lt;typename T&gt; inline T mul(T x,T y,int MO) &#123;return 1ll*x*y%MO;&#125;template&lt;typename T&gt; inline void Add(T &amp;x,T y) &#123;x=add(x+y);&#125;template&lt;typename T&gt; inline void Add(T &amp;x,T y,int MO) &#123;x=add(x+y,MO);&#125;template&lt;typename T&gt; inline void Sub(T &amp;x,T y) &#123;x=sub(x-y);&#125;template&lt;typename T&gt; inline void Sub(T &amp;x,T y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline void Mul(T &amp;x,T y) &#123;x=mul(x,y);&#125;template&lt;typename T&gt; inline void Mul(T &amp;x,T y,int MO) &#123;x=mul(x,y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2000;int a[MAXN+48],pw[MAXN+48];int dp[MAXN+48][MAXN+48];class ConnectedStates&#123; int n; public: inline int getSum(vector&lt;int&gt; deg) &#123; int prod=1,sum=0,ans=0; n=int(deg.size());rep(i,1,n) a[i]=deg[i-1],Mul(prod,a[i]),Add(sum,a[i]); pw[0]=1;rep(i,1,n) pw[i]=mul(pw[i-1],sum); rep(i,0,n) rep(j,0,n) dp[i][j]=0;dp[0][0]=1; rep(i,1,n) rep(j,0,min(n-2,i)) &#123; int k=i-j; if (k) Add(dp[i][j],dp[i-1][j]); if (j) Add(dp[i][j],mul(mul(dp[i-1][j-1],a[i]),n-2-j+1)); if (i==n) Add(ans,mul(dp[i][j],pw[n-2-j])); &#125; Mul(ans,prod);return ans; &#125;&#125;;/*--- Debug Part ---*//*int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int nn;int x;vector&lt;int&gt; vv; ConnectedStates A; while (cin&gt;&gt;nn) &#123; vv.clear(); while (nn--) cin&gt;&gt;x,vv.pb(x); cout&lt;&lt;A.getSum(vv)&lt;&lt;endl; &#125; io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;*/]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数学</category>
        <category>生成函数</category>
        <category>指数型生成函数</category>
        <category>Prufer编码</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>Prufer编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM340DIV1C]VegetableGarden 题解]]></title>
    <url>%2Fblog%2Ftcsrm340div1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一个$n\times m$的地图，每个格子为”.”,”X”或”I”。从左上角出发，沿着格线走一条不自交（但可以重复的走同一条边）的路径回到左上角，要求围成的圈内不能有”X”。现在对于每个$x$，求包含恰好$x$个”I”至少要走多远。 $n,m\leq 50$，”I”和”X”的个数之和不超过$10$。 SolutionClick to view the solution比较神仙的一道题联想计算几何中如何判断一个点是否在多边形内部：我们从点出发沿任意方向做一条射线，如果和多边形相交奇数次则在多边形内，否则在多边形外。这里我们运用类似的手法，判断一个格子是否在走出的环内部，我们只要从这个格子出发做一条向上的射线，看看和路径相交了几次就行。更直白的，判断一个格子是否在环内部我们只要看路径多少次经过了该格子的正上方。对于每个不是”.”的格子，我们只关心经过其正上方的次数的奇偶性，可以用一个01二进制位来表示，这样我们可以把不超过$10$个重要格子压成一个$Mask$。考虑状压dp。令$dp[i][j][Mask]$表示当前走到第$i$行第$j$列，重要格子正上方被经过的状态为$Mask$的情况下的最短路径。我们只要做一遍宽搜就可以跑出所有状态的答案。最后在$dp[1][1][Mask]$统计答案即可。总时间复杂度$O(nm2^{10})$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int q[5000048],head,tail;int dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,1,0,-1&#125;;int a[148][148],under[148][148],dp[58][58][1048];class VegetableGarden&#123; int n,m; public: inline vector&lt;int&gt; getMinDistances(vector&lt;string&gt; Garden) &#123; n=int(Garden.size());m=int(Garden[0].size()); int cntcare=0,cntwant=0,taboo=0; for (register int i=0;i&lt;n;i++) for (register int j=0;j&lt;=m;j++) &#123; a[i+1][j+1]=0; if (Garden[i][j]=='I') ++cntwant,a[i+1][j+1]=++cntcare; if (Garden[i][j]=='X') a[i+1][j+1]=++cntcare,taboo|=(1&lt;&lt;(cntcare-1)); &#125; for (register int j=1;j&lt;=m;j++) &#123; under[n+1][j]=0; for (register int i=n;i&gt;=1;i--) &#123; under[i][j]=under[i+1][j]; if (a[i][j]) under[i][j]|=(1&lt;&lt;(a[i][j]-1)); &#125; &#125; for (register int i=1;i&lt;=n+1;i++) for (register int j=1;j&lt;=m+1;j++) for (register int Mask=0;Mask&lt;=(1&lt;&lt;cntcare)-1;Mask++) dp[i][j][Mask]=INF; dp[1][1][0]=0;head=1;tail=0;q[++tail]=1;q[++tail]=1;q[++tail]=0; while (head&lt;=tail) &#123; int x=q[head++],y=q[head++],Mask=q[head++],nx,ny,nMask; for (register int dir=0;dir&lt;=3;dir++) &#123; nx=x+dx[dir];ny=y+dy[dir];nMask=Mask; if (1&lt;=nx &amp;&amp; nx&lt;=n+1 &amp;&amp; 1&lt;=ny &amp;&amp; ny&lt;=m+1) &#123; if (dy[dir]==1) nMask^=under[x][y]; if (dy[dir]==-1) nMask^=under[nx][ny]; if (dp[x][y][Mask]+1&lt;dp[nx][ny][nMask]) &#123; dp[nx][ny][nMask]=dp[x][y][Mask]+1; q[++tail]=nx;q[++tail]=ny;q[++tail]=nMask; &#125; &#125; &#125; &#125; vector&lt;int&gt; res(cntwant,INF); for (register int Mask=1;Mask&lt;=(1&lt;&lt;cntcare)-1;Mask++) if (!(Mask&amp;taboo)) check_min(res[__builtin_popcount(Mask)-1],dp[1][1][Mask]); return res; &#125;&#125;;/* ---Debug Part--- *//*int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int nn;string ss;vector&lt;string&gt; sss; VegetableGarden A; while (cin&gt;&gt;nn) &#123; sss.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;ss,sss.pb(ss); vector&lt;int&gt; res=A.getMinDistances(sss); for (auto item : res) cout&lt;&lt;item&lt;&lt;' '; cout&lt;&lt;endl; &#125; io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;*/]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef COUNTARI]Arithmetic Progressions 题解]]></title>
    <url>%2Fblog%2FccCOUNTARI%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$n$的数列${A_n}$，求有多少个长度为$3$的等差数列。 $n\leq 100000$，$max{A_i}\leq 30000$ SolutionClick to view the solution看到等差数列容易想到FFT。对于一个等差数列$a_i$,$a_j$,$a_k$，它们应该满足$a_i+a_k=2a_j$，这满足卷积的形式。我们只要枚举中间数，然后构造出左右两边的生成函数，然后FFT即可。然而这样要做$n$遍FFT。设$max{A_i}=V$，总时间复杂度为$O(nVlogV)$，还没有暴力的时间复杂度好。考虑分块。分块后等差数列有以下两种情况：1. 三个数分别属于三个不同的块。对于这种情况，我们枚举一个块，然后构造该块左右两边的生成函数做卷积，然后在块内枚举中间数统计答案。2. 有至少两个数属于同一个块。这种情况我们可以从右往左枚举$a_j$，同时维护中间数以右的统计每种数有多少个的cnt数组。然后在块内枚举$a_i$统计答案。在从左往右做一遍类似的操作。要注意的是如果从左往右和从右往左完全一样的做，则三个数在同一个块内的情况会被统计两次，所以从左往右做的时候cnt数组应以块为单位进行更新。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=1500;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;const int MAXV=3e4;namespace polynomial&#123; struct Complex &#123; double r,i; Complex () &#123;&#125; inline Complex(double _r,double _i) &#123;r=_r,i=_i;&#125; inline Complex operator + (Complex other) &#123;return Complex(r+other.r,i+other.i);&#125; inline Complex operator - (Complex other) &#123;return Complex(r-other.r,i-other.i);&#125; inline Complex operator * (Complex other) &#123;return Complex(r*other.r-i*other.i,r*other.i+i*other.r);&#125; inline Complex operator / (double t) &#123;return Complex(r/t,i/t);&#125; &#125;a[MAXN+48],b[MAXN+48]; inline void poly_fft(Complex c[],int len,int fl) &#123; for (register int i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); int k;for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; Complex wn=Complex(cos(pi*2.0*fl/clen),sin(pi*2.0*fl/clen)); for (register int j=0;j&lt;len;j+=clen) &#123; Complex w=Complex(1,0); for (register int k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; Complex tmp1=c[k],tmp2=c[k+(clen&gt;&gt;1)]*w; c[k]=tmp1+tmp2;c[k+(clen&gt;&gt;1)]=tmp1-tmp2; w=w*wn; &#125; &#125; &#125; if (fl==-1) for (register int i=0;i&lt;len;i++) c[i]=c[i]/len; &#125; inline void poly_mul(LL A[],LL B[],int N,int M,LL C[]) &#123; int len=1;while (len&lt;=N+M) len&lt;&lt;=1; for (register int i=0;i&lt;N;i++) a[i]=Complex(A[i],0);for (register int i=N;i&lt;len;i++) a[i]=Complex(0,0); for (register int i=0;i&lt;M;i++) b[i]=Complex(B[i],0);for (register int i=M;i&lt;len;i++) b[i]=Complex(0,0); poly_fft(a,len,1);poly_fft(b,len,1); for (register int i=0;i&lt;len;i++) a[i]=a[i]*b[i]; poly_fft(a,len,-1); for (register int i=0;i&lt;N+M-1;i++) C[i]=(LL)(a[i].r+0.5); &#125;&#125;int n,V,a[MAXN+48];int N,L[MAXN+48],R[MAXN+48],bel[MAXN+48];LL f[MAXN+48],g[MAXN+48],res[MAXN+48];int cnt[MAXV+48];int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n);for (register int i=1;i&lt;=n;i++) Get(a[i]),check_max(V,a[i]);V++; N=n/magic;if (n%magic) N++; for (register int i=1;i&lt;=N;i++) &#123; L[i]=(i-1)*magic+1;R[i]=(i==N?n:L[i]+magic-1); for (register int j=L[i];j&lt;=R[i];j++) bel[j]=i; &#125; LL ans=0; for (register int i=2;i&lt;=N-1;i++) &#123; memset(f,0,sizeof(f));memset(g,0,sizeof(g));memset(res,0,sizeof(res)); for (register int j=1;j&lt;=R[i-1];j++) f[a[j]]++; for (register int j=L[i+1];j&lt;=n;j++) g[a[j]]++; polynomial::poly_mul(f,g,V,V,res); for (register int j=L[i];j&lt;=R[i];j++) ans+=res[2*a[j]]; &#125; memset(cnt,0,sizeof(cnt)); for (register int i=n;i&gt;=1;i--) &#123; for (register int j=L[bel[i]];j&lt;=i-1;j++) if (2*a[i]-a[j]&gt;=1 &amp;&amp; 2*a[i]-a[j]&lt;V) ans+=cnt[2*a[i]-a[j]]; cnt[a[i]]++; &#125; memset(cnt,0,sizeof(cnt)); for (register int i=1;i&lt;=n;i++) &#123; if (i==L[bel[i]] &amp;&amp; i!=1) for (register int j=L[bel[i]-1];j&lt;=R[bel[i]-1];j++) cnt[a[j]]++; for (register int j=i+1;j&lt;=R[bel[i]];j++) if (2*a[i]-a[j]&gt;=1 &amp;&amp; 2*a[i]-a[j]&lt;V) ans+=cnt[2*a[i]-a[j]]; &#125; printf("%lld\n",ans);#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数学</category>
        <category>生成函数</category>
        <category>多项式</category>
        <category>分块</category>
        <category>FFT</category>
        <category>普通型生成函数</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>分块</tag>
        <tag>CodeChef</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #543C]Remembering Strings 题解]]></title>
    <url>%2Fblog%2Fcf543c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个包含$n$个字符串的可重集合，所有字符串长度相同为$m$。定义一个字符串是独一无二的，当且仅当存在一列和一个字符，使得只有该字符串在这列出现了这个字符。 现在可以修改这个集合，花费$a_{i,j}$的代价可以将第$i$个字符串的第$j$个字符修改成任意其他字符。 问要使得集合内所有字符串都是独一无二的，需花费的最小代价。 $n,m\leq 20$ SolutionClick to view the solution这题一看就是状压dp,但刚开始我的方向错误，我一直在考虑一列一列的转移，这样就无法避免要枚举子集，复杂度过高。我们考虑按行转移，即以字符串为单位进行转移。我们首先考虑如果想在第$j$列使得字符串$i$独一无二有哪些方法。显而易见的是直接修改这个字符，因为英文小写字母有$26$个而字符串只有最多$20$个，所以必定能修改成一个独一无二的字符，代价为$a_{i,j}$。另外一种可能是，考虑该列和$s_{i,j}$相同的其他字符串，我们只要在这些字符串中把除了代价最大的那个的其他字符全改掉，那么最大的那个也自然成为了独一无二的那个，这种修改方法顺便把那些小的那些也变成了独一无二的。令$dp[Mask]$表示将$Mask$的这些字符串变成独一无二的最小代价。转移我们只需考虑当前编号最小的那个不独一无二的字符串，用上述的两种可能性转移即可。总时间复杂度$O(2^nm)$。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LD long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n,m;char s[48][48];int a[48][48];vector&lt;int&gt; v[48][48];int cover[48][48],sum[48][48],maxn[48][48],val[48][48];int dp[1&lt;&lt;20];int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n,m); for (register int i=1;i&lt;=n;i++) scanf("%s",s[i]+1); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) Get(a[i][j]); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) &#123; v[j][s[i][j]-'a'+1].pb(i);cover[j][s[i][j]-'a'+1]|=(1&lt;&lt;(i-1)); sum[j][s[i][j]-'a'+1]+=a[i][j];check_max(maxn[j][s[i][j]-'a'+1],a[i][j]); &#125; for (register int i=1;i&lt;=m;i++) for (register int j=1;j&lt;=26;j++) val[i][j]=sum[i][j]-maxn[i][j]; for (register int Mask=1;Mask&lt;=(1&lt;&lt;n)-1;Mask++) dp[Mask]=INF; for (register int Mask=0;Mask&lt;(1&lt;&lt;n)-1;Mask++) &#123; int pos=1;while (Mask&amp;(1&lt;&lt;(pos-1))) pos++; for (register int i=1;i&lt;=m;i++) &#123; check_min(dp[Mask|(1&lt;&lt;(pos-1))],dp[Mask]+a[pos][i]); check_min(dp[Mask|cover[i][s[pos][i]-'a'+1]],dp[Mask]+val[i][s[pos][i]-'a'+1]); &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1]); io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1142C]U2 题解]]></title>
    <url>%2Fblog%2Fcf1142c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 平面上有$n$个点，现在对于每对横坐标不同的两个点作形如$y=x^2+bx+c$的抛物线使其过这两个点。问有多少个抛物线内部没有点。 $n\leq 100000$ SolutionClick to view the solution很巧妙的思维题计算几何里没有什么处理抛物线的积极手段，所以尝试改写抛物线的式子。移项，可以得到$y-x^2=bx+c$，所以如果我们对每个点做这样的变换:$(x,y)\rightarrow (x,y-x^2)$，那么抛物线就转化为了直线。一个点$(x_0,y_0)$在抛物线$y=x^2+bx+c$内部等价于$y0&gt;x_0^2+bx_0+c$，对于移项后的形式，则是$y_0-x_0^2&gt;bx_0+c$，即如果原来某个点处在某抛物线内，则转化坐标后该点位于直线上方。这样我们要求有多少个抛物线内没有点，就是求转化后的平面内有多少条直线上方没有点，只要求出点集的上凸壳（注意如果有三点共线的情况中间的点不要），看看有多少条线段即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// I'll always miss you like a darling.#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-14;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n;inline bool islarger(double x,double y) &#123;return x-y&gt;eps;&#125;inline bool issmaller(double x,double y) &#123;return x-y&lt;-eps;&#125;inline bool isequal(double x,double y) &#123;return !islarger(x,y) &amp;&amp; !issmaller(x,y);&#125;struct Vector&#123; double x,y; Vector () &#123;&#125; inline Vector (double _x,double _y) &#123;x=_x;y=_y;&#125; inline Vector operator + (Vector other) &#123;return Vector(x+other.x,y+other.y);&#125; inline Vector operator - (Vector other) &#123;return Vector(x-other.x,y-other.y);&#125; inline bool operator &lt; (const Vector &amp;other) const &#123; if (!isequal(x,other.x)) return issmaller(x,other.x); return islarger(y,other.y); &#125; inline void print() &#123;cout&lt;&lt;int(x)&lt;&lt;' '&lt;&lt;int(y)&lt;&lt;endl;&#125;&#125;a[MAXN+48];int atot;inline double query_k(Vector x,Vector y)&#123; if (isequal(x.x,y.x)) return islarger(y.y,x.y)?double(LINF):double(-LINF); return (y.y-x.y)/(y.x-x.x);&#125;Vector conv[MAXN+48];int tot=0;inline void convex_hull()&#123; for (register int i=1;i&lt;=n;i++) &#123; if (atot &amp;&amp; isequal(a[atot].x,a[i].x)) continue; a[++atot]=a[i]; &#125; for (register int i=1;i&lt;=atot;i++) &#123; while (tot&gt;=2 &amp;&amp; !islarger(query_k(conv[tot-1],conv[tot]),query_k(conv[tot],a[i]))) tot--; conv[++tot]=a[i]; &#125;&#125;int main ()&#123;#ifndef ONLINE_JUDGE double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n);for (register int i=1;i&lt;=n;i++) Get(a[i].x,a[i].y),a[i].y-=a[i].x*a[i].x; sort(a+1,a+n+1); convex_hull();printf("%d\n",tot-1); io.flush();#ifndef ONLINE_JUDGE cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>计算几何</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>Codeforces</tag>
        <tag>凸包</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #908H]New Year and Boolean Bridges 题解]]></title>
    <url>%2Fblog%2Fcf908h%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一个$n$个点的有向图。对于每对点$(u,v)$给出信息$A$,$X$或$O$，分别表示$u,v$互相可达,$u,v$有且仅有一个方向可达，$u,v$至少存在一个方向可达。求该有向图至少有几条边。 $n\leq 46$ Solution三种关系中的$O$关系是没什么用的，我们只要保证整张有向图是弱联通的即可。首先来考虑所有的$A$关系，若两者互相可达则它们处在同一个SCC中，又因为要求边数尽可能少，所以应处在一个环中。考虑用并查集来处理所有由$A$构成的连通块。处理完之后，处在一个连通块内的点最终必定在一个环内，不同连通块的点最终可能在一个环内。我们现在得到了一些环和一些单点。下面要考虑的是那些$X$关系。显而易见的，将这些环和点排成一排连成一条链肯定是一个可行解。但如果能在不打破$X$关系的前提下将一些环合并成一个大环会使边的数量更少。注意将单点并入环内并不会得到什么好处。所以我们可以只考虑那些点数大于等于$2$的连通块。记需要考虑的连通块数量为$m$,由于$n\leq 46$，所以$m\leq 23$。这样的数据范围容易考虑状压dp。令$dp[Mask][i]$表示$Mask$所表示的点集，用$i$条边能不能将其连成一个弱联通块，非零表示可以，零表示不可以。有状态转移方程$$dp[Mask][i]=\sum_{u\mid v=Mask}dp[u][i-1]\cdot dp[v][0]$$边界条件为$dp[Mask][0]=1$当且仅当$Mask$表示的所有环内两两没有$X$关系。因为需要枚举子集，所以这个$dp$的复杂度是$O(3^n\cdot n)$，需要优化。注意到$dp$方程是一个或卷积，所以可以用FWT将单次或卷积的复杂度将至$O(2^n\cdot n)$，从而总时间复杂度降至$O(2^n\cdot n^2)$，仍需优化。注意到对于每一个$i$，我们只关心全集所对应的$dp$值是否为非零数，所以我们只要先跑一次uFWT预处理每个位置对全集所在位置的贡献系数（这个用草稿纸画一画就能发现端倪），每次$O(n)$的对最后一个位置进行uFWT即可。这样总复杂度降至$O(2^n\cdot n)$，可以通过。Click to view the solution CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN=(1&lt;&lt;23);int n,ind[48];char ga[48][48];int f[MAXN+48],F[MAXN+48],coef[MAXN+48];namespace DSU&#123; int pre[48],sz[48]; inline void init() &#123;for (register int i=1;i&lt;=n;i++) pre[i]=i,sz[i]=1;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123; x=find_anc(x);y=find_anc(y); if (x!=y) pre[x]=y,sz[y]+=sz[x]; &#125;&#125;inline void poly_fwt(int c[],int len)&#123; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) for (register int j=0;j&lt;len;j+=clen) for (register int k=j;k&lt;j+(clen&gt;&gt;1);k++) c[k+(clen&gt;&gt;1)]+=c[k];&#125;inline void init_coef(int c[],int len)&#123; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) for (register int j=0;j&lt;len;j+=clen) for (register int k=j;k&lt;j+(clen&gt;&gt;1);k++) c[k]*=-1;&#125;int main ()&#123;#ifndef ONLINE_JUDGE freopen ("a.in","r",stdin); freopen ("a.out","w",stdout);#endif scanf("%d",&amp;n); for (register int i=1;i&lt;=n;i++) scanf("%s",ga[i]+1); DSU::init(); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=i-1;j++) if (ga[i][j]=='A') DSU::update(i,j); int ans=0,tot=0; for (register int i=1;i&lt;=n;i++) if (DSU::find_anc(i)==i) &#123; ans+=DSU::sz[i]; if (DSU::sz[i]&gt;=2) ind[i]=++tot; &#125; if (!tot) &#123;printf("%d\n",n-1);return 0;&#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=i-1;j++) if (ga[i][j]=='X') &#123; if (DSU::issame(i,j)) &#123;puts("-1");return 0;&#125; int root1=DSU::find_anc(i),root2=DSU::find_anc(j); if (ind[root1] &amp;&amp; ind[root2]) f[(1&lt;&lt;(ind[root1]-1))|(1&lt;&lt;(ind[root2]-1))]=1; &#125; for (register int Mask=1;Mask&lt;=(1&lt;&lt;tot)-1;Mask++) for (register int i=1;i&lt;=tot;i++) if (Mask&amp;(1&lt;&lt;(i-1))) f[Mask]|=f[Mask^(1&lt;&lt;(i-1))]; for (register int Mask=0;Mask&lt;=(1&lt;&lt;tot)-1;Mask++) f[Mask]^=1; for (register int Mask=0;Mask&lt;=(1&lt;&lt;tot)-1;Mask++) coef[Mask]=1,F[Mask]=1; poly_fwt(f,1&lt;&lt;tot);init_coef(coef,1&lt;&lt;tot); for (register int i=0;;i++) &#123; int tmp=0; for (register int Mask=0;Mask&lt;=(1&lt;&lt;tot)-1;Mask++) F[Mask]*=f[Mask]; for (register int Mask=0;Mask&lt;=(1&lt;&lt;tot)-1;Mask++) tmp+=coef[Mask]*F[Mask]; if (tmp) &#123;printf("%d\n",ans+i);break;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>多项式</category>
        <category>状压dp</category>
        <category>FWT</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Codeforces</tag>
        <tag>状压dp</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #222]雨 题解]]></title>
    <url>%2Fblog%2Fnflsoj222%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 求第一个数大于等于$x$小于等于$y$且所有数和为$n$的不下降序列个数，模$10^9+7$。 $n\leq 300000$ SolutionClick to view the solution第一个数上下界都有限制比较麻烦，我们只要用第一个数大于等于$x$的序列个数减去大于等于$y+1$的序列个数即可。接下来考虑如何计算第一个数仅有下界的情况。考虑分块。如果我们能预处理仅用不超过$\sqrt{n}$的数对每种和能构造多少种序列，和仅用大于$\sqrt{n}$的数对每种和能构造出多少种序列，那么最后只要把这两部分卷积一下就能得到答案（注意卷积只要知道最后一个数的答案，说白了就是枚举不超过$\sqrt{n}$的数的和）。下面考虑这两部分分别怎么算。对于第一部分，可选的数只有$\sqrt{n}$个，令$dp[i][j]$表示考虑到第$i$种数，和为$j$的方案有多少，只要跑一个完全背包即可。对于第二部分，数的种类比较多，无法直接跑普通的完全背包。这里有一个喜闻乐见的$dp$套路：令$dp[i][j]$表示当前有$i$个数，和为$j$的方案数，我们有两种操作：第一种是在序列最前端添加一个$\sqrt{n}+1$，$dp[i][j]$转移到$dp[i+1][j+\sqrt{n}+1]$，第二种是序列内所有数加一，$dp[i][j]$转移到$dp[i][i+j]$，可以证明任意合法的序列与这样的操作是一一对应的。这样总复杂度$O(n\sqrt{n})$。写的时候注意一下块的分界和当前第一个数下界的大小关系。 CodeClick to view the code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int#define ull unsigned long long#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pii pair&lt;double,double&gt;#define pLL pair&lt;LL,LL&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LINF=2e16;const int magic=548;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T1,typename ...T2&gt; inline void Get(T1 &amp;x,T2 &amp;...y) &#123;Get(x);Get(y...);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=3e5;int n,X,Y;int dp1[MAXN+48],dp2[2][MAXN+48],sum[MAXN+48];inline int calc(int x)&#123; memset(dp1,0,sizeof(dp1));dp1[0]=1; for (register int i=x;i&lt;=magic;i++) for (register int j=1;j&lt;=n;j++) &#123; if (i==j) Add(dp1[j],1); if (j-i&gt;0) Add(dp1[j],dp1[j-i]); &#125; memset(sum,0,sizeof(sum));memset(dp2,0,sizeof(dp2)); dp2[0][0]=1;sum[0]=1;int cur=1,pre=0,minn=max(magic+1,x); for (register int i=1;i&lt;=n/minn;i++) &#123; memset(dp2[cur],0,sizeof(dp2[cur])); for (register int j=1;j&lt;=n;j++) &#123; if (j-i&gt;=0) Add(dp2[cur][j],dp2[cur][j-i]); if (j-minn&gt;=0) Add(dp2[cur][j],dp2[pre][j-minn]); Add(sum[j],dp2[cur][j]); &#125; cur^=1;pre^=1; &#125; int res=0; for (register int i=0;i&lt;=n;i++) Add(res,1ll*dp1[i]*sum[n-i]%MOD); return res;&#125;int main ()&#123;#ifndef ONLINE_JUDGE freopen ("a.in","r",stdin); freopen ("a.out","w",stdout);#endif Get(X,Y,n); printf("%d\n",sub(calc(X)-calc(Y+1))); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>分块</category>
        <category>背包</category>
        <category>完全背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NFLSoj</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU5528]Count a*b 题解]]></title>
    <url>%2Fblog%2Fhdu5528%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 定义$f(n)=\sum_{i=1}^{n}\sum_{j=1}^{n}[n\nmid i\cdot j]$ 定义$g(n)=\sum_{d\mid n}f(d)$ 有$T$组询问，每次给定一个$n$，求$g(n)$ $T\leq 20000,n\leq 10^9$ SolutionClick to view the solution推式子题（开始推式子）$$\begin{aligned}f(n) &amp;= \sum_{i=1}^n\sum_{j=1}^n[n\nmid i\cdot j] \\&amp;=n^2-\sum_{i=1}^n\sum_{j=1}^n[n\mid i\cdot j] \\&amp;= n^2-\sum_{i=1}^n\sum_{j=1}^n[\frac{n}{gcd(n,i)}\mid \frac{i}{gcd(n,i)}\cdot j]\end{aligned}$$因为$gcd(\frac{n}{gcd(n,i)},\frac{i}{gcd(n,i)})=1$，所以上式等价于$$\begin{aligned}f(n) &amp;= n^2-\sum_{i=1}^n\sum_{j=1}^n[\frac{n}{gcd(n,i)}\mid j] \\&amp;= n^2-\sum_{i=1}^n\frac{n}{\frac{n}{gcd(n,i)}} \\&amp;= n^2-\sum_{i=1}^ngcd(n,i)\end{aligned}$$看到$gcd$，喜闻乐见的套路是枚举$gcd$，我们有$$\begin{aligned}f(n) &amp;= n^2-\sum_{d\mid n}d\sum_{i=1}^{\frac{n}{d}}[gcd(i,\frac{n}{d})=1] \\&amp;= n^2-\sum_{d\mid n}d\phi(\frac{n}{d})\end{aligned}$$接下来考虑$g(n)$$$\begin{aligned}g(n) &amp;= \sum_{x\mid n}f(x) \\&amp;= \sum_{x\mid n}(x^2-\sum_{d\mid x}d\phi(\frac{x}{d})) \\&amp;= \sum_{x\mid n}x^2-\sum_{x\mid n}\sum_{d\mid x}d\phi(\frac{x}{d})\end{aligned}$$考虑先枚举$d$,再枚举$x$是$d$的几倍，我们有$$\begin{aligned}g(n) &amp;= \sum_{x\mid n}x^2-\sum_{d\mid x}d\sum_{i\mid \frac{n}{x}}\phi(i) \\&amp;= \sum_{x\mid n}x^2-\sum_{d\mid x}d\cdot \frac{n}{d} \\&amp;= \sigma_2(n)-n\cdot \sigma_0(n)\end{aligned}$$其中$\sigma_i(n)$表示$n$的所有约数的$i$次方的和，它们都是积性函数，可以在分解质因数的过程中直接求解。从而总时间复杂度$O(T\sqrt{n})$，可以通过。 CodeClick to view the code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define x first#define y secondusing namespace std;template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;typedef unsigned long long ull;typedef pair&lt;int,int&gt; Pair;const int MAXN=4e4;int prime[MAXN+48],tot;bool isprime[MAXN+48];inline void sieve()&#123; memset(isprime,true,sizeof(isprime));tot=0; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]==0) break; &#125; &#125;&#125;int n;vector&lt;Pair&gt; v;inline void Decompose(int n)&#123; v.clear(); for (register int i=1;i&lt;=tot;i++) if (n%prime[i]==0) &#123; int cnt=0; while (n%prime[i]==0) cnt++,n/=prime[i]; v.pb(mp(prime[i],cnt)); &#125; if (n!=1) v.pb(mp(n,1));&#125;int main ()&#123; sieve(); int t;Get(t); while (t--) &#123; Get(n);Decompose(n);ull sum1=1,sum2=1; for (register int i=0;i&lt;int(v.size());i++) &#123; ull pw=1,tmp=1; for (register int j=1;j&lt;=v[i].y;j++) pw=pw*v[i].x*v[i].x,tmp+=pw; sum1*=(v[i].y+1);sum2*=tmp; &#125; cout&lt;&lt;sum2-sum1*n&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #391][六校联合训练 #12]修(elephant) 题解]]></title>
    <url>%2Fblog%2Fnflsoj391%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一张有$n$个点的有向图, 第$i$个节点向$[L_i,R_i]$中的每一个点连一条有向边。 有$q$次游戏，每次在图上放置$m_i$个棋子，并放置一个零食堆。每次操作可以将一个棋子沿出边移动一次，或者拿走任意数量的零食。 作为后手，你需要安排每次游戏的零食堆零食个数，以保证自己必胜。 $n,q,\sum m_i\leq 200000$ SolutionClick to view the solution对于一个询问而言，每个棋子相当于一个独立的游戏，零食堆也相当于一个独立的游戏。根据Nim游戏的性质，要使得后手必胜，即先手必败，则这些游戏的异或和要是$0$。则我们要算出这些棋子所在位置的$SG$函数的值。显然$1$号点是必败态,$SG(1)=0$，根据这张DAG的性质，我们的问题转化为了一个求区间$mex$的问题。求区间$mex$可以考虑用主席树维护。对于主席树的第$i$棵线段树的第$j$个叶子，我们存储的是在$1$到$i$这些点中$SG$值为$j$的编号最大节点的编号。这样对于一个查询$[L,R]$，我们在$R$所在的线段树内进行二分，如果左边区间的$min$大于等于$L$说明左边区间内的$SG$值都存在，往右走，否则往左走。总时间复杂度$O(nlogn+\sum m_i)$ CodeClick to view the code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))const int INF=2e9;const LL LIBNF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;const int MAXN=2e5;int n,q,L[MAXN+48],R[MAXN+48];int mex[MAXN+48];int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*20],rson[MAXN*20],minn[MAXN*20],tot; inline void pushup(int cur) &#123;minn[cur]=min(minn[lson[cur]],minn[rson[cur]]);&#125; inline void build(int &amp;cur,int l,int r) &#123; if (l==r) return; if (!cur) cur=++tot; int mid=(l+r)&gt;&gt;1; build(lson[cur],l,mid);build(rson[cur],mid+1,r); &#125; inline void insert(int cur,int last,int pos,int nv,int l,int r) &#123; lson[cur]=lson[last];rson[cur]=rson[last]; if (l==r) &#123;minn[cur]=nv;return;&#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) lson[cur]=++tot,insert(lson[cur],lson[last],pos,nv,l,mid); else rson[cur]=++tot,insert(rson[cur],rson[last],pos,nv,mid+1,r); pushup(cur); &#125; inline int query(int cur,int pos,int l,int r) &#123; if (l==r) return l; int mid=(l+r)&gt;&gt;1; if (minn[lson[cur]]&gt;=pos) return query(rson[cur],pos,mid+1,r); else return query(lson[cur],pos,l,mid); &#125;&#125;int main ()&#123; Get(n);for (register int i=2;i&lt;=n;i++) Get(L[i]),Get(R[i]); SegmentTree::build(root[0],0,n); root[1]=++SegmentTree::tot;SegmentTree::insert(root[1],root[0],0,1,0,n);mex[1]=0; for (register int i=2;i&lt;=n;i++) &#123; mex[i]=SegmentTree::query(root[R[i]],L[i],0,n); root[i]=++SegmentTree::tot;SegmentTree::insert(root[i],root[i-1],mex[i],i,0,n); &#125; Get(q);int num,x; while (q--) &#123; Get(num);int xsum=0; while (num--) Get(x),xsum^=mex[x]; printf("%d\n",xsum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>线段树二分</category>
        <category>博弈论</category>
        <category>SG函数</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>线段树二分</tag>
        <tag>SG函数</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #536D]Tavas and Kansas 题解]]></title>
    <url>%2Fblog%2Fcf536d%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一张$n$个点$m$条边的带权无向图，每个点有一个权值$p_i$。两个人分别从两个起点出发轮流操作，每次可以给自己的一个距离变量$dis$加上一个值，然后将图里到自己出发点最短路小于等于$dis$的点占为己有。一个点只能被一个人占据。当所有点都被某个人占据的时候游戏结束，权值和大的人胜。问在最优策略下游戏的结果。 $n\leq 2000$ SolutionClick to view the solution首先肯定从两个出发点各跑一遍最短路，得到每个点到两个出发点的距离。接下来的这步操作非常神奇：将距离离散化之后，以到第一个出发点的距离为横坐标，到第二个出发点的距离为纵坐标，把图里的$n$个点映射到一个笛卡尔坐标系中。这样相当于第一个人拿着一条与$y$轴平行的扫描线右移，占据所有在扫描线左边的点，第二个人拿着一条与$x$轴平行的扫描线上移，占据所有在扫描线下方的点。接下来可以设计$dp$状态了。注意博弈论问题要倒着设计状态，因为两个人目标不一样，正着设计无法转移。令$dp1[i][j]$表示第一个人的扫描线到了$i$，第二个人的扫描线到了$j$，现在轮到第一个人操作时，在剩下的点中第一个人占据的权值比第二个人最多多多少。dp2[i][j]表示第一个人的扫描线到了$i$，第二个人的扫描线到了$j$，现在轮到第二个人操作时，在剩下的点中第一个人占据的权值比第二个人最少多多少。只要预处理某条扫描线右方/上方第一个有点的位置以及该位置权值和，转移方程就非常简单。最后考察$dp1[0][0]$的值即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int#define ull unsigned long long#define pb push_back#define pf push_front#define mp make_pair#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:(-res));&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;const int MAXN=2000;const int MAXM=1e5;int n,e,s,t;int p[MAXN+48];vector&lt;Pair&gt; v[MAXN+48];LL da[MAXN+48],db[MAXN+48],val[MAXN+48];int tot,N,M;LL dp[MAXN+48][MAXN+48][2];priority_queue&lt;pLL&gt; q;inline void dijkstra(int st,LL dist[],int &amp;lim)&#123; for (register int i=1;i&lt;=n;i++) dist[i]=LINF; dist[st]=0;q.push(mp(0,st)); while (!q.empty()) &#123; LL dd=-q.top().x;int cur=q.top().y;q.pop(); if (dist[cur]&lt;dd) continue; for (auto item : v[cur]) &#123; int to=item.x; if (dist[cur]+item.y&lt;dist[to]) &#123; dist[to]=dist[cur]+item.y; q.push(mp(-dist[to],to)); &#125; &#125; &#125; for (register int i=1;i&lt;=n;i++) val[i]=dist[i];tot=n; sort(val+1,val+tot+1);tot=unique(val+1,val+tot+1)-(val+1); for (register int i=1;i&lt;=n;i++) dist[i]=lower_bound(val+1,val+tot+1,dist[i])-val; lim=tot;&#125;struct Pt&#123; int x,y,val,ind; Pt () &#123;&#125; inline Pt (int _x,int _y,int _v,int _i) &#123;x=_x;y=_y;val=_v;ind=_i;&#125;&#125;a[MAXN+48],tmp[MAXN+48];int to;inline bool cmp_x(Pt x,Pt y) &#123;return x.x&lt;y.x;&#125;inline bool cmp_y(Pt x,Pt y) &#123;return x.y&lt;y.y;&#125;pair&lt;int,LL&gt; player[2][MAXN+48][MAXN+48];inline void update(int &amp;pos,LL &amp;sum,int npos,int val)&#123; if (pos==npos) &#123;sum+=val;return;&#125; pos=npos;sum=val;&#125;inline void init()&#123; for (register int i=1;i&lt;=n;i++) a[i]=Pt(da[i],db[i],p[i],i); int pos,k;LL sum; for (register int i=M;i&gt;=0;i--) &#123; to=0; for (register int j=1;j&lt;=n;j++) if (a[j].y&gt;i) tmp[++to]=a[j]; sort(tmp+1,tmp+to+1,cmp_x);pos=INF;sum=0;k=to; for (register int j=N;j&gt;=0;j--) &#123; while (k &amp;&amp; tmp[k].x&gt;j) update(pos,sum,tmp[k].x,tmp[k].val),k--; player[0][j][i]=mp(pos,sum); &#125; &#125; for (register int i=N;i&gt;=0;i--) &#123; to=0; for (register int j=1;j&lt;=n;j++) if (a[j].x&gt;i) tmp[++to]=a[j]; sort(tmp+1,tmp+to+1,cmp_y);pos=INF;sum=0;k=to; for (register int j=M;j&gt;=0;j--) &#123; while (k &amp;&amp; tmp[k].y&gt;j) update(pos,sum,tmp[k].y,tmp[k].val),k--; player[1][i][j]=mp(pos,sum); &#125; &#125;&#125;int main ()&#123;#ifdef LOCAL freopen ("a.in","r",stdin);#endif Get(n);Get(e);Get(s);Get(t);int x,y,c; for (register int i=1;i&lt;=n;i++) Get(p[i]); for (register int i=1;i&lt;=e;i++) &#123; Get(x);Get(y);Get(c); v[x].pb(mp(y,c));v[y].pb(mp(x,c)); &#125; dijkstra(s,da,N);dijkstra(t,db,M);init(); for (register int i=N;i&gt;=0;i--) for (register int j=M;j&gt;=0;j--) &#123; if (player[0][i][j].x&gt;=INF) &#123;dp[i][j][0]=dp[i][j][1]=0;continue;&#125; dp[i][j][0]=max(dp[player[0][i][j].x][j][0]+player[0][i][j].y,dp[player[0][i][j].x][j][1]+player[0][i][j].y); dp[i][j][1]=min(dp[i][player[1][i][j].x][0]-player[1][i][j].y,dp[i][player[1][i][j].x][1]-player[1][i][j].y); &#125; LL res=dp[0][0][0]; if (res&gt;0) puts("Break a heart"); else if (res==0) puts("Flowers"); else puts("Cry"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>Dynamic Programming</category>
        <category>博弈论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>博弈论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #839D]Winter is here 题解]]></title>
    <url>%2Fblog%2Fcf839d%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$n$的序列${a_n}$。对于任意一个子序列$a_{i_1},a_{i_2},\ldots ,a_{i_k}$，如果其所有数的$gcd$大于$1$，则其价值为$k\cdot gcd(a_{i_1},a_{i_2},\ldots a_{i_k})$，否则为$0$。求该数列的所有子序列的价值之和模$10^9+7$。 $n\leq 200000,max{a_i}\leq 10^6$ SolutionClick to view the solution根据$gcd$的套路，我们先枚举$gcd=g$，然后求所有$gcd$是$g$的倍数的子序列的长度之和，然后莫比乌斯反演一下就好了。令$cnt[i]$表示$i$这个数在数列中出现了多少次。我们枚举$g$，然后求出$c=\sum_{g\mid d}cnt[d]$。这个部分的复杂度根据调和级数是$O(10^6log(10^6))$的。接下来我们要计算长度之和，即计算下式:$$\sum_{i=1}^c\binom{c}{i}\cdot i$$我刚开始是这样计算这个式子的：我们令$f(i)=\sum_{i=0}^c\binom{c}{i}x^i$，根据二项式定理，$f(i)=(1+x)^c$。対$f(i)$求导，我们有$f’(i)=\sum_{i=0}^c\binom{c}{i}\cdot i\cdot x^{i-1}$，另一方面，$((1+x)^c)’=c\cdot (1+x)^{c-1}$,令$x=1$，得原式答案为$c\cdot 2^{c-1}$。后来发现自己蠢了，可以通过组合意义来求解上式。原式的意义可以理解为有$c$个人，先选出任意个人进国家队，再选一个人做队长。这个问题等价于先选一个国家队队长，剩下的$c-1$个人随便进不进队都可以形成一种国家队，所以原式等于$c\cdot 2^{c-1}$。总之我们有长度之和是$c\cdot 2^{c-1}$，最后用莫比乌斯反演求出正好等于$g$的长度之和即可。代码中没有使用莫比乌斯反演，使用了简单的容斥。我们从$g=10^6$到$1$逆序枚举，每次减掉所有的倍数即可。因为是逆序的，所以所有的倍数已经是“正好”的答案了，所以正确性可以保证。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) ((x) &amp; (-x))// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; T res;bool f;char ch; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:-res);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return (!y)?x:gcd(y,x%y);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return (x&gt;0)?x:(-x);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e6;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=1ll*res*x%MOD; x=1ll*x*x%MOD;y&gt;&gt;=1; &#125; return res;&#125;int n,a[MAXN+48],cnt[MAXN+48];int fac[MAXN+48],ifac[MAXN+48];inline void init_inv()&#123; fac[0]=1;for (register int i=1;i&lt;=n;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[n]=quick_pow(fac[n],MOD-2); for (register int i=n-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || x&lt;y) return 0; return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;&#125;int pw[MAXN+48],p[MAXN+48],F[MAXN+48];int main ()&#123;#ifdef LOCAL double T=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n);for (register int i=1;i&lt;=n;i++) Get(a[i]),cnt[a[i]]++; init_inv();pw[0]=1;for (register int i=1;i&lt;=n;i++) pw[i]=add(pw[i-1]+pw[i-1]); for (register int i=1;i&lt;=n;i++) p[i]=1ll*i*pw[i-1]%MOD; for (register int i=1;i&lt;=MAXN;i++) &#123; int sz=0; for (register int j=i;j&lt;=MAXN;j+=i) sz+=cnt[j]; F[i]=p[sz]; &#125; int ans=1ll*F[MAXN]*MAXN%MOD; for (register int i=MAXN-1;i&gt;=2;i--) &#123; for (register int j=i*2;j&lt;=MAXN;j+=i) Sub(F[i],F[j]); Add(ans,1ll*F[i]*i%MOD); &#125; printf("%d\n",ans);#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-T)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #338D]GCD Table 题解]]></title>
    <url>%2Fblog%2Fcf338d%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一张$n*m$的方格纸，第$i$行第$j$列写的数字是$gcd(i,j)$。 给定一个长度为$k$的数列${a_k}$，问该数列是否在方格纸上的某一行连续地出现过。 $n,m\leq 10^{12},k\leq 10000$。 SolutionClick to view the solution首先我们可以发现，行号是所有$a_i$的倍数，所以行号是$lcm(a_1,a_2,\ldots ,a_k}$的倍数。事实上，我们直接令行号等于$lcm(a_1,a_2,\ldots ,a_k)$就可以了。如果这个数大于$n$可以直接判无解。接下来我们考虑这个数列从哪一列开始。设从第$x$列开始，我们有以下方程:$$\begin{cases}x\equiv 0(mod \ a_1) \\x+1\equiv 0(mod \ a_2) \\x+2\equiv 0(mod \ a_3) \\\ldots \\x+k-1\equiv 0(mod \ a_k) \\\end{cases}$$移项之后，我们可以用扩展中国剩余定理来求$x$的最小正整数解。这个解是在模$lcm(a_1,a_2,\ldots a_k)$，即模行号意义下的。考虑到在该行下超过$lcm(a_1,a_2,\ldots a_k)$列之后的部分和之前的本质上是一样的，但有可能后面的部分与行号求出的$gcd$会是$a_i$的倍数。所以$x$的最小正整数解是最有可能是答案的解。我们只要拿这个解check一下就行了。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void Get(T &amp;x)&#123; T res;bool f;char ch; while (!isdigit(ch=getchar()) &amp;&amp; ch=='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:-res);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e4;const LL LIM=1e12;LL n,m;int k;LL a[MAXN+48];LL A[MAXN+48],M[MAXN+48];inline LL quick_mul(LL x,LL y,LL MO)&#123; LL res=0;bool f=true;if (y&lt;0) f=false,y=-y; while (y) &#123; if (y&amp;1) res=(res+x)%MO; x=(x+x)%MO;y&gt;&gt;=1; &#125; if (!f) res=-res; while (res&lt;0) res+=MO; return res;&#125;inline void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123;x=1;y=0;return;&#125; exgcd(b,a%b,x,y); LL tmp=x;x=y;y=tmp-a/b*y;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif Get(n);Get(m);Get(k);for (register int i=1;i&lt;=k;i++) Get(a[i]); LL LCM=a[1]; for (register int i=2;i&lt;=k;i++) &#123; LL g=gcd(LCM, a[i]); if (LCM/g&gt;LIM/a[i]) &#123;puts("NO");return 0;&#125; LCM=LCM/g*a[i]; &#125; if (LCM&gt;n) &#123;puts("NO");return 0;&#125; for (register int i=1;i&lt;=k;i++) &#123; A[i]=1-i; LL tmp=(-A[i])/a[i];A[i]+=tmp*a[i]; if (A[i]&lt;0) A[i]+=a[i]; M[i]=a[i]; &#125; LL aa=A[1],mm=M[1]; for (register int i=2;i&lt;=k;i++) &#123; LL c=A[i]-aa,g=gcd(mm,M[i]); if (c%g) &#123;puts("NO");return 0;&#125; LL x,y;exgcd(mm,M[i],x,y); x=quick_mul(x,c/g,mm*M[i]/g); LL cur=aa+quick_mul(mm,x,mm*M[i]/g),delta=M[i]/g; if (cur&lt;0) &#123; LL tmp=(-cur)/(delta*mm); cur+=(delta*mm)*tmp;x=(x+quick_mul(delta,tmp,mm*M[i]/g))%(mm*M[i]/g); if (cur&lt;0) cur+=delta*mm,x=(x+delta)%(mm*M[i]/g); &#125; if (cur&gt;0) &#123; LL tmp=cur/(delta*mm); cur-=(delta*mm)*tmp;x=x-quick_mul(delta,tmp,mm*M[i]/g); while (x&lt;0) x+=mm*M[i]/g; &#125; mm=mm*M[i]/g;aa=cur%mm; &#125; if (!aa) aa=LCM; if (aa+k-1&gt;m) &#123;puts("NO");return 0;&#125; else &#123; for (register LL i=aa;i&lt;=aa+k-1;i++) if (gcd(LCM,i)!=a[i-aa+1]) &#123;puts("NO");return 0;&#125; puts("YES");return 0; &#125;#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>中国剩余定理</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef TAPAIR]Counting The Important Pairs 题解]]></title>
    <url>%2Fblog%2FccTAPAIR%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个$n$个点$m$条边的图，问有多少对边，使得删除这对边之后原图不连通。 $n\leq 10^5,m\leq 3\cdot 10^5$ SolutionClick to view the solution这题刚开始看到我的想法是分治的同时动态维护图中桥的数量但好像不太会后来想了一个很巧妙的做法。我们求出原图的dfs树。显然如果我们删除的两条边中如果有一条是桥，那么另一条没有任何要求，我们先把这种情况特判掉，之后我们都不考虑删除桥的情况。考虑我们删除的两条边有哪些可能。- 两条边都是返祖边，因为原图dfs树的存在，这种删法不可能使原图不连通。- 一条边是返祖边，一条边是树边。那么考虑拿掉这条返祖边后，我们要删的树边一定是桥。考虑如下操作：对于每条返祖边，我们给它赋予一个随机数作为权值。对于树边，它的权值是所有覆盖到它的返祖边的权值的异或和。这样，所有的桥的权值都是$0$，对于拿掉某条返祖边就是桥的那些树边，它们的权值一定和那条返祖边的权值是一样的，即这条树边仅被一条返祖边覆盖。因为是随机权值，所以出错概率很小。- 两条边都是树边。割掉两条树边（不是桥的树边）使得原图不连通，则这两条树边在dfs树上要属于同一个“区域”，即它们被相同的返祖边覆盖。我们把所有的树边的权值丢到一个map里，然后对于某种权值的边如果有$x$条，则对答案贡献$\binom{x}{2}$实测这样是会挂掉的，因为边太多导致出错概率增加。稍稍改进一下上述算法，给每条返祖边$10$个随机权值压成一个vector即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-x))// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int MOD=1e9+7;const int magic=348;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get (T &amp;x)&#123; T res;bool f;char ch; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:-res);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return (!y)?x:gcd(y,x%y);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return (x&gt;0)?x:-x;&#125;template&lt;typename T&gt; inline T add(T x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;template&lt;typename T&gt; inline T sub(T x) &#123;if (x&lt;0) x+=MOD;return x;&#125;template&lt;typename T&gt; inline void Add(T x,T y) &#123;x=add(x+y);&#125;template&lt;typename T&gt; inline void Sub(T x,T y) &#123;x=sub(x-y);&#125;const int MAXN=3e5;int n,m;Pair edge[MAXN+48];vector&lt;int&gt; v[MAXN+48];inline int getanother(int ind,int x) &#123;if (edge[ind].x==x) return edge[ind].y; else return edge[ind].x;&#125;map&lt;vector&lt;LL&gt;,int&gt; Mp;LL mark[MAXN+48][15],xsum[MAXN+48][15];bool intree[MAXN+48];int depth[MAXN+48];vector&lt;LL&gt; fv[MAXN+48];map&lt;vector&lt;LL&gt;,int&gt; Mp2;inline LL gen_rand()&#123; return ((1ll*rand())&lt;&lt;20)+((1ll*rand())&lt;&lt;10)+rand();&#125;inline void dfs(int cur,int father)&#123; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=getanother(v[cur][i],cur); if (!depth[y]) depth[y]=depth[cur]+1,intree[v[cur][i]]=true,dfs(y,cur); else if (y!=father &amp;&amp; depth[y]&lt;depth[cur]) &#123; vector&lt;LL&gt; tmp;tmp.clear(); for (register int k=0;k&lt;=9;k++) &#123; LL val=gen_rand();tmp.pb(val); mark[cur][k]^=val;mark[y][k]^=val; &#125; Mp[tmp]=1; &#125; &#125;&#125;inline void Dfs(int cur,int father)&#123; memcpy(xsum[cur],mark[cur],sizeof(mark[cur])); for (register int i=0;i&lt;int(v[cur].size());i++) if (intree[v[cur][i]]) &#123; int y=getanother(v[cur][i],cur); if (y!=father) &#123; Dfs(y,cur); for (register int k=0;k&lt;=9;k++) xsum[cur][k]^=xsum[y][k]; &#125; &#125;&#125;int main ()&#123;#ifdef LOCAL double T=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif srand(time(NULL)); Get(n);Get(m);int x,y; for (register int i=1;i&lt;=m;i++) &#123; Get(x);Get(y);edge[i]=mp(x,y); v[x].pb(i);v[y].pb(i); &#125; depth[1]=1;dfs(1,-1);Dfs(1,-1);int cnt=0;LL ans=0; for (register int i=2;i&lt;=n;i++) &#123; fv[i].clear();bool f=true; for (register int j=0;j&lt;=9;j++) &#123;fv[i].pb(xsum[i][j]);if (xsum[i][j]) f=false;&#125; if (f) cnt++; if (Mp.find(fv[i])!=Mp.end()) ans++; Mp2[fv[i]]++; &#125; ans+=1ll*cnt*(m-cnt); for (map&lt;vector&lt;LL&gt;,int&gt;::iterator iter=Mp2.begin();iter!=Mp2.end();iter++) ans+=1ll*(iter-&gt;y)*(iter-&gt;y-1)/2; printf("%lld\n",ans);#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-T)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>图论</category>
        <category>dfs树</category>
        <category>随机</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>随机</tag>
        <tag>dfs树</tag>
        <tag>CodeChef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记]中国剩余定理]]></title>
    <url>%2Fblog%2FCRT%2F</url>
    <content type="text"><![CDATA[普通中国剩余定理若已知如下同余方程组$$\begin{cases}x\equiv a_1(mod \ m_1) \\x\equiv a_2(mod \ m_2) \\\ldots \\x\equiv a_n(mod \ m_n) \\\end{cases}$$其中$m_1,m_2,\ldots ,m_n$两两互质，则$x$的通解可以这样计算： 令$M=\Pi_{i=1}^nm_i$，$M_i=\frac{M}{m_i}$，$M_i^{-1}$为$M_i$在模$m_i$意义下的逆元，则$$x=\sum_{i=1}^na_iM_iM_i^{-1} (mod \ M)$$ 证明：对于第$p$个方程式，因为除了$M_p$，其他的$M_i$都是$m_p$的倍数，所以其他的项在模$m_p$意义下都为$0$。考虑$a_pM_pM_p^{-1}$这一项，在模$m_p$意义下$M_pM_p^{-1}\equiv 1(mod \ m_p)$，所以$x$满足第$p$个方程式的限制。 扩展中国剩余定理若已知如下同余方程组$$\begin{cases}x\equiv a_1(mod \ m_1) \\x\equiv a_2(mod \ m_2) \\\ldots \\x\equiv a_n(mod \ m_n) \\\end{cases}$$但不保证$m_1,m_2,\ldots,m_n$两两互质，我们可以用两两合并的方法求出$x$的通解。 设当前已经合并完了前$i-1$个同余方程，正准备去合并第$i$个同余方程，我们现在有方程组$$\begin{cases}x\equiv A(mod \ M) \\x\equiv a_i(mod \ m_i) \\\end{cases}$$则可以得到如下等式$$A+Mx=a_i+m_iy$$移项，得$$Mx+m_i(-y)=a_i-A$$如果$gcd(M,m_i) \nmid a_i-A$就可以直接判断原方程组无解。否则我们可以通过扩展欧几里得算法求出一个特解$x_0$，然后调整这个解使得$A+Mx$是满足限制的最小非负整数即可。 需要注意的是，这个调整的过程中做乘法会爆long long，所以对于$x$的调整要在模$lcm(M,m_i)$的意义下进行。具体的，我们写一个快速加来代替乘法即可。 最后我们解出来的答案是在模$lcm(m_1,m_2,\ldots m_n)$意义下的。通过加减模数的最小公倍数来获得通解。]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>中国剩余定理</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Tsinsen A1310]矩形计算(钟沛林) 题解]]></title>
    <url>%2Fblog%2Ftsinsen1310%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 对于一个矩阵，我们这样定义它的权值：一个数如果在该矩阵中出现了$p$次，则权值加上$p^2$。 现在给你一个$n\times m$的矩阵。有$q$次询问，每次问以$(x1,y1)$到$(x2,y2)$为对角线的子矩阵的权值。 $n,q\leq 200,q \leq 200000$。 对于某$30\%$的数据，满足原矩阵中不同的数不超过$200$个。 SolutionClick to view the solution我们先考虑不同数字不超过$200$个的那个部分分。容易想到把询问离线下来，枚举每一种数字，判断它给所有询问带来的贡献。枚举到某种数字的时候，我们把该数字所在位置都填$1$，其他位置填$0$，然后维护二维前缀和就可以$O(1)$数一个区域内的$1$的个数，从而给每个询问计算贡献。时间复杂度$O(200\cdot (q+n^2))$。当数字种类很多的时候这个方法就太慢了。不妨考虑类似根号暴力的做法。我们设定一个阈值$p$。如果一个数的出现次数大于$p$我们就使用这种方法，否则使用其他方法。因为出现次数大于$p$的数最多有$\frac{n^2}{p}$种，所以这一部分的复杂度为$O(\frac{n^2}{p}(n^2+q))$接下来考虑如果有一种数出现次数不超过$p$怎么做。这里我们有一种很神奇的想法。我们要维护出现次数的平方，这个等价于所有的出现位置两两匹配（包括自己和自己匹配）的方案数。在$p$较小的时候，我们暴力枚举所有可能的点对，加入某种数据结构，最后对于每个询问计算一下它包含了多少个点对即可。接下来思考如何维护这些点对。一个查询包含了一个点对相当于这个查询所对应的矩形区域包含了点对所对应的矩形区域。设查询为$(a,b),(c,d)$，我们要找的是满足$a\leq x_1,b\leq y_1,c\geq x_2,d\geq y_2$的点对$(x_1,y_1),(x_2,y_2)$的个数。可以想到用四维树状数组来维护这些点对，但这样空间会达到$n^4$，不能接受。考虑把所有点对和查询放在一起，先按照第一个坐标排序，这样我们只需要三维树状数组即可。点对的数量最多为$\frac{n^2}{p}\cdot p^2=n^2p$。这部分的时间复杂度为$O((n^2p+q)log^3n)$，忽略掉$q$,复杂度为$O(n^2plog^3n)$。我们希望两部分复杂度平均，有方程$\frac{n^2}{p}(n^2+q)=n^2plog^3n$，解得$p=\sqrt{\frac{n^2+q}{log^3n}}$，约在$17$,$18$左右。此时总复杂度为$O(n^3log^{1.5}n+q(n\log^{1.5}n+log^3n))$。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)//#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=18;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=200;const int MAXQ=1e5;int n,m,q;int a[MAXN+48][MAXN+48];int val[MAXN*MAXN+48],tot;int cnt[MAXN*MAXN+48],sum[MAXN+1][MAXN+1];inline int query(int X1,int Y1,int X2,int Y2) &#123;return sum[X2][Y2]-sum[X2][Y1-1]-sum[X1-1][Y2]+sum[X1-1][Y1-1];&#125;int X1[MAXQ+48],Y1[MAXQ+48],X2[MAXQ+48],Y2[MAXQ+48];int ans[MAXQ+48];int head[MAXN*MAXN+48],tx[MAXN*MAXN+48],ty[MAXN*MAXN+48],nxt[MAXN*MAXN+48],t;inline void add(int pos,int x,int y) &#123;++t;tx[t]=x;ty[t]=y;nxt[t]=head[pos];head[pos]=t;&#125;namespace BIT&#123; int c[MAXN+48][MAXN+48][MAXN+48]; inline void modify(int x,int y,int z) &#123; int yy=y,zz=z; while (x) &#123; y=yy; while (y&lt;=n) &#123; z=zz; while (z&lt;=m) &#123; c[x][y][z]++; z+=LOWBIT(z); &#125; y+=LOWBIT(y); &#125; x^=LOWBIT(x); &#125; &#125; inline int query(int x,int y,int z) &#123; int res=0,yy=y,zz=z; while (x&lt;=m) &#123; y=yy; while (y) &#123; z=zz; while (z) &#123; res+=c[x][y][z]; z^=LOWBIT(z); &#125; y^=LOWBIT(y); &#125; x+=LOWBIT(x); &#125; return res; &#125;&#125;struct element&#123; int X1,Y1,X2,Y2,ind; element () &#123;&#125; inline element(int _X1,int _Y1,int _X2,int _Y2,int _i) &#123; ind=_i; X1=min(_X1,_X2);X2=max(_X1,_X2); Y1=min(_Y1,_Y2);Y2=max(_Y1,_Y2); &#125; inline void print() &#123; cerr&lt;&lt;X1&lt;&lt;' '&lt;&lt;Y1&lt;&lt;' '&lt;&lt;X2&lt;&lt;' '&lt;&lt;Y2&lt;&lt;endl; &#125; inline bool operator &lt; (const element &amp;other) const &#123; if (X1!=other.X1) return X1&gt;other.X1; return ind&lt;other.ind; &#125;&#125;ele[3000048];int etot;int cx[MAXN*MAXN+48],cy[MAXN*MAXN+48],ctot;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m);tot=0; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]),val[++tot]=a[i][j]; sort(val+1,val+tot+1);tot=unique(val+1,val+tot+1)-(val+1); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) a[i][j]=lower_bound(val+1,val+tot+1,a[i][j])-val,cnt[a[i][j]]++,add(a[i][j],i,j); scanf("%d",&amp;q); for (register int i=1;i&lt;=q;i++) &#123; int x,y,xx,yy; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;xx,&amp;yy); X1[i]=min(x,xx);X2[i]=max(x,xx); Y1[i]=min(y,yy);Y2[i]=max(y,yy); &#125; for (register int k=1;k&lt;=tot;k++) if (cnt[k]&gt;=magic) &#123; memset(sum,0,sizeof(sum)); for (register int i=head[k];i;i=nxt[i]) sum[tx[i]][ty[i]]=1; for (register int i=1;i&lt;=n;i++) for (register int j=2;j&lt;=m;j++) sum[i][j]+=sum[i][j-1]; for (register int i=2;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) sum[i][j]+=sum[i-1][j]; for (register int i=1;i&lt;=q;i++) &#123; int tmp=query(X1[i],Y1[i],X2[i],Y2[i]); ans[i]+=tmp*tmp; &#125; &#125; else &#123; ctot=0; for (register int i=head[k];i;i=nxt[i]) ++ctot,cx[ctot]=tx[i],cy[ctot]=ty[i]; for (register int i=1;i&lt;=ctot;i++) for (register int j=1;j&lt;=ctot;j++) ele[++etot]=element(cx[i],cy[i],cx[j],cy[j],0); &#125; for (register int i=1;i&lt;=q;i++) ele[++etot]=element(X1[i],Y1[i],X2[i],Y2[i],i); sort(ele+1,ele+etot+1); for (register int i=1;i&lt;=etot;i++) &#123; if (!ele[i].ind) BIT::modify(ele[i].Y1,ele[i].X2,ele[i].Y2); else ans[ele[i].ind]+=BIT::query(ele[i].Y1,ele[i].X2,ele[i].Y2); &#125; for (register int i=1;i&lt;=q;i++) printf("%d\n",ans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
        <category>数据结构</category>
        <category>BIT</category>
      </categories>
      <tags>
        <tag>根号暴力</tag>
        <tag>BIT</tag>
        <tag>Tsinsen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Tsinsen A1318]Almost(艾雨青) 题解]]></title>
    <url>%2Fblog%2Ftsinsen1318%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 定义一个序列$A_n$的几乎平均数为$\frac{\sum_{i=1}^nA_i}{n-1}$。 现在给定一个序列$A_n$，有$q$次查询，每次查询一个区间$[l,r]$，问$[l,r]$这个区间内几乎平均数最大的子区间的几乎平均数是多少。 $n\leq 10^5,q\leq 3\times 10^4$。 SolutionClick to view the solution考虑对原序列求前缀和，则区间$[l,r]$的几乎平均数可以写成$\frac{sum[r]-sum[l-1]}{r-l}$。可以看到这很像一个求两点之间斜率的形式。那么问题可以转化为在$[l,r]$内取两个点，按照上述公式计算斜率后斜率最大。于是我们有一个朴素的想法：对于一次询问$[l,r]$，我们从右向左依次将点加入，枚举到某一个点的时候，我们以它为左端点，在右侧找一个点使其与之匹配斜率最大。这样做复杂度是$O(n^2q)$的，需要优化。我们考虑之前枚举左端点后，事实上不用枚举右边的点。我们可以发现，能使得斜率最大的点一定在右边的点所形成的上凸壳中。相当于我们要在上凸壳上找一个点使其与左端点连线的斜率最大。我们发现这个斜率是一个单峰函数，考察相邻两项的差值，我们只要在上凸壳上二分，找到第一个差小于$0$的位置即可。然后将当前点加入单调栈，用单调栈维护凸壳即可。这样复杂度降到$O(qnlogn)$，仍然需要优化。考虑分块。我们预处理$f[i][j]$表示考虑从第$i$个块开头到第$j$个点的这段区间（或者从第$j$个点到第$i$个块末尾）内斜率最大的点对。以前者为例，$f[i][j]$显然可以从$f[i][j-1]$转移来。然后考虑第$j$个点作为右端点的贡献，像上述一样维护左边点的凸壳，在凸壳上二分即可。注意如果查询点在右边维护的是下凸壳。这个预处理的复杂度是$O(n\sqrt nlogn)$。接下来考虑查询$[l,r]$。令$belong[i]$表示第$i$个点所属的块的编号。分以下情况讨论：- $belong[l]=belong[r]$，此时直接暴力构建这不超过$\sqrt n$个点的凸壳即可。- $belong[l]\neq belong[r]$，我们考虑答案可能的几种情况： - 左端点在$belong[l]+1$之后，这时的最值在$f[belong[l]+1][r]$中处理过了。 - 右端点在$belong[r]-1$之前，这时的最值在$f[belong[r]-1][l]$中处理过了。 - 左端点在$belong[l]$这个块内且右端点在$belong[r]$这个块内。此时可能作为左端点和右端点的点都不超过$\sqrt n$个，我们暴力构建右端点所在块的凸壳，拉着所有左端点所在块的点二分即可。查询时间复杂度$O(q\sqrt nlogn)$，从而算法总时间复杂度为$O((n+q)\sqrt nlogn)$。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=967;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,q,a[MAXN+48];LL sum[MAXN+48];int N;struct Seg&#123; int dx;LL dy; Seg () &#123;&#125; inline Seg(int _x,LL _y) &#123;dx=_x;dy=_y;&#125; inline bool operator &lt; (const Seg &amp;other) const &#123;return dy*other.dx&lt;other.dy*dx;&#125; inline void print() &#123; LL up=dy,down=dx; if (up==0) &#123;puts("0/1");return;&#125; LL g=gcd(myabs(up),myabs(down)); up/=g;down/=g; if (down&lt;0) up=-up,down=-down; printf("%lld/%lld\n",up,down); &#125;&#125;;inline Seg gen(pLL pt1,pLL pt2) &#123;return Seg(pt1.x-pt2.x,pt1.y-pt2.y);&#125;Seg f[110][MAXN+1];pLL sta[MAXN+48];int stot;int bel[MAXN+48];inline pLL query(pLL cur)&#123; int l=1,r=stot; while (l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if (mid&lt;stot &amp;&amp; gen(cur,sta[mid])&lt;gen(cur,sta[mid+1])) l=mid+1; else r=mid-1; &#125; return sta[l];&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q);int l,r; for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),sum[i]=sum[i-1]+a[i]; N=n/magic;if (n%magic) N++; for (register int i=1,id=1;i&lt;=n;i++) &#123; bel[i]=id; if (i%magic==0) id++; &#125; for (register int i=1;i&lt;=N;i++) &#123; int st=(i-1)*magic+1; if (st!=n) &#123; stot=2;sta[1]=mp(st,sum[st-1]);sta[2]=mp(st+1,sum[st]); f[i][st+1]=gen(mp(st,sum[st-1]),mp(st+1,sum[st+1])); for (register int j=st+2;j&lt;=n;j++) &#123; f[i][j]=f[i][j-1]; pLL chosen=query(mp(j,sum[j])); if (f[i][j]&lt;gen(chosen,mp(j,sum[j]))) f[i][j]=gen(chosen,mp(j,sum[j])); sta[++stot]=mp(j,sum[j-1]); while (stot&gt;=3 &amp;&amp; gen(sta[stot-1],sta[stot])&lt;gen(sta[stot-2],sta[stot-1])) sta[stot-1]=sta[stot],stot--; &#125; &#125; int ed=((i==N)?n:i*magic); if (ed!=1) &#123; stot=2;sta[1]=mp(ed,sum[ed]);sta[2]=mp(ed-1,sum[ed-1]); f[i][ed-1]=gen(mp(ed-1,sum[ed-2]),mp(ed,sum[ed])); for (register int j=ed-2;j&gt;=1;j--) &#123; f[i][j]=f[i][j+1]; pLL chosen=query(mp(j,sum[j-1])); if (f[i][j]&lt;gen(mp(j,sum[j-1]),chosen)) f[i][j]=gen(mp(j,sum[j-1]),chosen); sta[++stot]=mp(j,sum[j]); while (stot&gt;=3 &amp;&amp; gen(sta[stot],sta[stot-1])&lt;gen(sta[stot-1],sta[stot-2])) sta[stot-1]=sta[stot],stot--; &#125; &#125; &#125; while (q--) &#123; scanf("%d%d",&amp;l,&amp;r); if (bel[l]+1&gt;=bel[r]) &#123; stot=2;sta[1]=mp(r,sum[r]);sta[2]=mp(r-1,sum[r-1]); Seg ans=gen(mp(r-1,sum[r-2]),mp(r,sum[r])); for (register int i=r-2;i&gt;=l;i--) &#123; pLL chosen=query(mp(i,sum[i-1])); if (ans&lt;gen(mp(i,sum[i-1]),chosen)) ans=gen(mp(i,sum[i-1]),chosen); sta[++stot]=mp(i,sum[i]); while (stot&gt;=3 &amp;&amp; gen(sta[stot],sta[stot-1])&lt;gen(sta[stot-1],sta[stot-2])) sta[stot-1]=sta[stot],stot--; &#125; ans.print();continue; &#125; Seg ans=f[bel[l]+1][r]; if (ans&lt;f[bel[r]-1][l]) ans=f[bel[r]-1][l]; int st=(bel[r]-1)*magic+1; stot=1;sta[1]=mp(r,sum[r]); for (register int i=r-1;i&gt;=st;i--) &#123; sta[++stot]=mp(i,sum[i]); while (stot&gt;=3 &amp;&amp; gen(sta[stot],sta[stot-1])&lt;gen(sta[stot-1],sta[stot-2])) sta[stot-1]=sta[stot],stot--; &#125; int ed=magic*bel[l]; for (register int i=l;i&lt;=ed;i++) &#123; pLL chosen=query(mp(i,sum[i-1])); if (ans&lt;gen(mp(i,sum[i-1]),chosen)) ans=gen(mp(i,sum[i-1]),chosen); &#125; ans.print(); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>思维</category>
        <category>二分</category>
        <category>分块</category>
        <category>计算几何</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>分块</tag>
        <tag>Tsinsen</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM570DIV1C]CurvyonRails 题解]]></title>
    <url>%2Fblog%2Ftcsrm570div1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有一幅$n\times m$的地图。有一些格子是废弃的，这些格子上不能建铁轨。其他的格子都要建铁轨。铁轨有两种：第一种是直的，即连接上下或左右两个格子；第二种是弯的，即连接上下左右中相邻的两个格子。要求铺完铁轨后所有的铁轨形成若干个环，即不能有地方是断的。有些能建铁轨的格子上有地鼠，如果地鼠所在的格子建的是一条直的铁轨它就会不高兴。求最少让几只地鼠不高兴。如果没有满足题意的建铁轨方式输出$-1$。 $n,m\leq 25$ SolutionClick to view the solution这道题和清华集训的无限之环有点像要在铁轨满足要求的基础上最小化不高兴的地鼠数量，考虑费用流。我们将地图黑白染色之后，让黑格子出发，白格子接收，这样只要判断一下最大流即可知道是否可行。关键是如何最小化不高兴的地鼠数量。这题设计费用的方式还是非常神的。我们这里考虑一个从源点出发的黑格子，白格子的做法以此类推。首先从汇点向黑格子连流量为$2$费用为$0$的边。然后从这个黑格子向两个点连边，这两个点分别管理上下的两个接口和左右的两个接口。怎么连边呢？接下来是最精彩的一步：黑格子向两个点各连两条边，一条流量为$1$费用为$0$，一条流量为$1$费用为$1$。（当然这是针对有地鼠的情况，没有地鼠的话费用都是0）这样的目的是：如果这个格子最终建弯的铁轨，那么它会向两个点各流$1$的流量，那么跑最小费用流一定能流两条费用为$0$的边，从而对应没有怒气值。否则如果建直的铁轨，则两单位流量会同时到第一个点或者第二个点，那么就必然要走一条费用是$1$的边，从而对应产生怒气值。接下来就比较简单了，我们假设每两个格子之间有一个虚点，刚才建出的两个点往对应的虚点上连流量为$1$，费用为$0$的点即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;namespace flow&#123; const int flow_maxn=1e5; int head[flow_maxn+48],cur[flow_maxn+48],to[flow_maxn+48],nxt[flow_maxn+48],f[flow_maxn+48],cost[flow_maxn+48],tot,t,mincost,maxflow; bool visited[flow_maxn+48];int D[flow_maxn+48]; inline void init() &#123;tot=1;memset(head,0,sizeof(head));memset(D,0,sizeof(D));mincost=maxflow;&#125; inline void addedge(int s,int t,int cap,int cc) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap;cost[tot]=cc; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;cost[tot]=-cc; &#125; inline int aug(int x,int maxf) &#123; if (x==t) &#123;mincost+=(-D[0])*maxf;maxflow+=maxf;return maxf;&#125; visited[x]=true; int y,minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; !visited[y] &amp;&amp; D[x]+cost[i]-D[y]==0) &#123; minf=min(maxf-ans,f[i]); now=aug(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; &#125; if (ans&gt;=maxf) return ans; &#125; return ans; &#125; inline bool relabel() &#123; int d=INF; for (register int cur=0;cur&lt;=t;cur++) if (visited[cur]) for (register int i=head[cur];i;i=nxt[i]) &#123; int y=to[i]; if (!visited[y] &amp;&amp; f[i]) check_min(d,D[cur]+cost[i]-D[y]); &#125; if (d&gt;=INF) return false; for (register int cur=0;cur&lt;=t;cur++) if (visited[cur]) D[cur]-=d; return true; &#125; inline Pair zkw() &#123; mincost=0;maxflow=0; do &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; do for (register int i=0;i&lt;=t;i++) visited[i]=false; while (aug(0,INF)); &#125; while (relabel()); return mp(maxflow,mincost); &#125;&#125;class CurvyonRails&#123; int n,m; inline int getind(int x,int y) &#123;return (x-1)*m+y;&#125; inline int getrow(int x,int y) &#123;return n*m*3+(x-1)*m+y;&#125; inline int getcol(int x,int y) &#123;return n*m*4+(x-1)*m+y;&#125; public: inline int getmin(vector&lt;string&gt; field) &#123; n=int(field.size());m=int(field[0].size()); flow::init();flow::t=n*m*5+1;int cnt1=0,cnt2=0; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) if (field[i-1][j-1]!='w') if ((i+j)&amp;1) &#123; cnt1++; flow::addedge(0,getind(i,j),2,0); int tc=(field[i-1][j-1]=='C'?1:0); flow::addedge(getind(i,j),n*m+getind(i,j),1,0); flow::addedge(getind(i,j),n*m+getind(i,j),1,tc); flow::addedge(getind(i,j),n*m*2+getind(i,j),1,0); flow::addedge(getind(i,j),n*m*2+getind(i,j),1,tc); if (j!=1) flow::addedge(n*m+getind(i,j),getrow(i,j-1),1,0); if (j!=m) flow::addedge(n*m+getind(i,j),getrow(i,j),1,0); if (i!=1) flow::addedge(n*m*2+getind(i,j),getcol(i-1,j),1,0); if (i!=n) flow::addedge(n*m*2+getind(i,j),getcol(i,j),1,0); &#125; else &#123; cnt2++; flow::addedge(getind(i,j),flow::t,2,0); int tc=(field[i-1][j-1]=='C'?1:0); flow::addedge(n*m+getind(i,j),getind(i,j),1,0); flow::addedge(n*m+getind(i,j),getind(i,j),1,tc); flow::addedge(n*m*2+getind(i,j),getind(i,j),1,0); flow::addedge(n*m*2+getind(i,j),getind(i,j),1,tc); if (j!=1) flow::addedge(getrow(i,j-1),n*m+getind(i,j),1,0); if (j!=m) flow::addedge(getrow(i,j),n*m+getind(i,j),1,0); if (i!=1) flow::addedge(getcol(i-1,j),n*m*2+getind(i,j),1,0); if (i!=n) flow::addedge(getcol(i,j),n*m*2+getind(i,j),1,0); &#125; if (cnt1!=cnt2) return -1; Pair res=flow::zkw(); if (res.x!=cnt1*2) return -1; return res.y; &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; CurvyonRails A;vector&lt;string&gt; ss;string s;int n; while (cin&gt;&gt;n) &#123; ss.clear(); for (register int i=1;i&lt;=n;i++) cin&gt;&gt;s,ss.pb(s); cout&lt;&lt;A.getmin(ss)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>费用流</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 005F]Many Easy Problems 题解]]></title>
    <url>%2Fblog%2Fagc005f%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一棵$n$个点的无根树。对于树上的一个点集$S$，定义$f(S)$表示点数最小的能覆盖$S$中所有点的子树的大小。对于每个$k=1,2,3,…n$，求$\sum_{\mid S\mid=k}f(S)$。 $n\leq 200000$ SolutionClick to view the solution这题我刚开始的想法是计算对于每棵子树，有多少种点集是以它覆盖最优的。但仔细想想无法快速转移。这题的一个很棒的思路是：对于某个$k$，我们考虑树上每个点对答案的贡献。那么以这个点为根把树提起来，我们要保证选的点不能全部来自某一棵子树。即节点$u$的贡献是$$\binom{n}{k}-\sum_{v\in son_u}\binom{size(v)}{k}$$我们考虑把所有节点的贡献加起来，$\binom{n}{k}$出现了$n$次。因为每个点都作为一次根，所以原树中每条边两边的子树都被减过一次。我们先对原树做一遍搜索，令$cnt[i]$表示大小为$i$的子树个数。则我们有$$ans_k=n\cdot \binom{n}{k}-\sum_{i=1}^{n-1}cnt[i]\binom{i}{k}$$将组合数写成阶乘的形式，把$\frac{1}{k!}$提到外面，$$ans_k=n\cdot \binom{n}{k}-\frac{1}{k!}\sum_{i=1}^{n-1}cnt[i]\frac{i!}{(i-k)!}$$发现后面是一个差固定的东西相乘，根据套路，我们翻转一个就可以得到卷积。令$A[i]=cnt[i]i!$，$B[i]=\frac{1}{(n-i)!}$，则原式可以改写成$$ans_k=n\cdot \binom{n}{k}-\frac{1}{k!}\sum_{i=1}^{n-1}A[i]B[n+k-i]$$这就是显然的卷积了。考察一下模数，发现是一个费马素数，原根$g=5$，直接NTT即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=924844033;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e6;namespace polynomial&#123; const int NTT_MAX=1e6; const int G=5; int wn_pos[NTT_MAX+48],wn_neg[NTT_MAX+48];bool isfirst=true; inline void poly_init() &#123; for (register int clen=2;clen&lt;=524288;clen&lt;&lt;=1) wn_pos[clen]=quick_pow(G,(MOD-1)/clen),wn_neg[clen]=quick_pow(G,(MOD-1)-(MOD-1)/clen); &#125; inline void poly_ntt(int c[],int len,int fl) &#123; if (isfirst) poly_init(),isfirst=false; int k; for (register int i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; int wn=(fl==1?wn_pos[clen]:wn_neg[clen]); for (register int j=0;j&lt;len;j+=clen) &#123; int w=1; for (register int k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; int tmp1=c[k],tmp2=1ll*c[k+(clen&gt;&gt;1)]*w%MOD; c[k]=add(tmp1+tmp2);c[k+(clen&gt;&gt;1)]=sub(tmp1-tmp2); w=1ll*w*wn%MOD; &#125; &#125; &#125; if (fl==-1) &#123; int ilen=quick_pow(len,MOD-2); for (register int i=0;i&lt;len;i++) c[i]=1ll*c[i]*ilen%MOD; &#125; &#125; inline void poly_mul(int A[],int B[],int N,int M) &#123; int len=1;while (len&lt;=N+M) len&lt;&lt;=1; poly_ntt(A,len,1);poly_ntt(B,len,1); for (register int i=0;i&lt;len;i++) A[i]=1ll*A[i]*B[i]%MOD; poly_ntt(A,len,-1); &#125;&#125;int n;vector&lt;int&gt; v[MAXN+48];int cnt[MAXN+48];inline int dfs(int cur,int father)&#123; int sz=1; for (auto y : v[cur]) if (y!=father) sz+=dfs(y,cur); if (cur!=1) cnt[sz]++,cnt[n-sz]++; return sz;&#125;int fac[MAXN+48],ifac[MAXN+48];inline void init_inv()&#123; fac[0]=1;for (register int i=1;i&lt;=n;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[n]=quick_pow(fac[n],MOD-2); for (register int i=n-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;y || x&lt;0) return 0; return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;&#125;int a[MAXN+48],b[MAXN+48];int ans[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n);int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; scanf("%d%d",&amp;x,&amp;y); v[x].pb(y);v[y].pb(x); &#125; dfs(1,-1); init_inv(); for (register int i=1;i&lt;=n-1;i++) a[i]=1ll*cnt[i]*fac[i]%MOD; for (register int i=0;i&lt;=n;i++) b[i]=ifac[n-i]; polynomial::poly_mul(a,b,n,n+1); for (register int i=1;i&lt;=n;i++) ans[i]=sub(1ll*n*C(n,i)%MOD-1ll*ifac[i]*a[i+n]%MOD); for (register int i=1;i&lt;=n;i++) printf("%d\n",ans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>多项式</category>
        <category>NTT</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef FINDSEQ]Find a Subsequence 题解]]></title>
    <url>%2Fblog%2FccFINDSEQ%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$n$的数列$A_n$和由$12345$组成的排列$s$。要求从数列中选出五个数，使得其互不相同且第$i$个数在这五个数中是第$s_i$小的，即这五个数的相对大小关系和那个$s$排列是一样的。 $n\leq 1000$，$-10^9\leq A_i\leq 10^9$ SolutionClick to view the solution我一开始的思路是枚举第二大和第四大的数是多少，这样剩下的三个数的范围就确定了。但是有一个问题：我们要实现这样一个询问：&gt; 在区间$[l,r]$内，第一个在$[L,R]$之内的数是多少？这个问题好像没法单log做？（如果有会的哥哥可以联系我）一个比较显然的双log做法是二分+主席树，但这题撑不住双log。我们又有一个办法：注意到第一大和第五大这两个数是只有一个边界的，这两个数的查询非常方便，只要用ST表维护最小值/最大值即可。这样我们最后再处理第三大的，问题就变成了这样：&gt; 在区间$[l,r]$内，是否存在一个数$x\in [L,R]$？这个用主席树就可以做到单log了，总时间复杂度$O(Tn^2logn)$这个做法未免太烦了，其实在刚开始的时候我掉入了思维陷阱。我们尝试另一种思考方法：我们枚举$s$排列中的第二个数和第四个数的位置，这样虽然我们没有确定每个数的值域范围，但好处是原序列被分成了三个区间，每个区间内我们只要取一个数。接下来我们从小到大考虑最小的数，第二小的数…以此类推。显然的是，为了使后面的数的可选范围尽可能大，我们每一步都应该选尽可能小的数，但又要保证比上一个数大，于是我们要解决这样一个问题：&gt; 在区间$[l,r]$内，比$x$大的最小的数是多少？只要我们有这个区间的线段树，就可以在线段树上二分以单log的解决这个问题。为了进一步减小常数，代码中使用的是树状数组二分。树状数组中维护的是一个前缀和，我们相当于要找一个最小的$x’$使得$sum(x’)&gt;sum(x)$。树状数组的本质是砍掉所有右儿子的线段树，而前缀和可以由若干个左儿子区间拼起来得到。具体细节可以参考代码。我们实时维护三个区间的树状数组，在右端点滑动的时候，相当于第二个BIT加数字，第三个BIT减数字。这样总时间复杂度也是$O(Tn^2logn)$，但常数和代码难度都小很多。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1000;int n,a[MAXN+48];char seq[48];int topos[48];vector&lt;int&gt; pos[MAXN+48];int L[10];int val[MAXN+48],tot;int ans[10];struct BIT&#123; int c[MAXN+48]; inline void init() &#123;memset(c,0,sizeof(c));&#125; inline void modify(int x,int delta) &#123;while (x&lt;=tot) c[x]+=delta,x+=LOWBIT(x);&#125; inline int query(int x) &#123;int res=0;while (x) res+=c[x],x^=LOWBIT(x);return res;&#125; inline int getpos(int x) &#123; int cmp=query(x),res=0,tmp; for (register int i=10;i&gt;=0;i--) &#123; tmp=res+(1&lt;&lt;i); if (tmp&lt;=tot &amp;&amp; c[tmp]&lt;=cmp) res+=(1&lt;&lt;i),cmp-=c[tmp]; &#125; if (res==tot) return -1; else return res+1; &#125;&#125;tree[3];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;scanf("%d",&amp;ca); while (ca--) &#123; scanf("%d%s",&amp;n,seq+1);for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),val[i]=a[i]; for (register int i=1;i&lt;=5;i++) topos[seq[i]-'0']=i; tot=n;sort(val+1,val+tot+1);tot=unique(val+1,val+tot+1)-(val+1); for (register int i=1;i&lt;=n;i++) a[i]=lower_bound(val+1,val+tot+1,a[i])-val; for (register int i=1;i&lt;=tot;i++) pos[i].clear(); for (register int i=1;i&lt;=n;i++) pos[a[i]].pb(i); tree[0].init();tree[0].modify(a[1],1);bool f=false; for (register int i=2;i&lt;=n-3;i++) &#123; tree[1].init();tree[2].init(); tree[1].modify(a[i+1],1);for (register int j=i+3;j&lt;=n;j++) tree[2].modify(a[j],1); for (register int j=i+2;j&lt;=n-1;j++) &#123; L[0]=1;L[1]=i+1;L[2]=j+1; memset(ans,-1,sizeof(ans));ans[0]=0; ans[seq[2]-'0']=i;ans[seq[4]-'0']=j;bool ff=true; for (register int k=1;k&lt;=5;k++) &#123; if (ans[k]!=-1) &#123; if (k&lt;5 &amp;&amp; ans[k+1]!=-1 &amp;&amp; a[ans[k]]&gt;=a[ans[k+1]]) &#123;ff=false;break;&#125; continue; &#125; int p=tree[topos[k]/2].getpos(a[ans[k-1]]); if (p==-1 || (k&lt;5 &amp;&amp; ans[k+1]!=-1 &amp;&amp; p&gt;=a[ans[k+1]])) &#123;ff=false;break;&#125; int pp=lower_bound(pos[p].begin(),pos[p].end(),L[topos[k]/2])-pos[p].begin(); ans[k]=pos[p][pp]; &#125; if (ff) &#123;f=true;break;&#125; tree[1].modify(a[j],1);tree[2].modify(a[j+1],-1); &#125; if (f) break; tree[0].modify(a[i],1); &#125; if (!f) puts("-1"); else &#123; sort(ans+1,ans+6); for (register int i=1;i&lt;=5;i++) printf("%d ",ans[i]-1); puts(""); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>思维</category>
        <category>数据结构</category>
        <category>BIT</category>
        <category>树状数组二分</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>CodeChef</tag>
        <tag>树状数组二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef MGCHGYM]Misha and Gym 题解]]></title>
    <url>%2Fblog%2FccMGCHGYM%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$n$的数列，保证数列中所有出现过的不同的数不超过$k$个。有$q$次操作，操作有三种： $[1,i,x]$，将第$i$个位置的数改成$x$。 $[2,l,r]$，翻转$l$到$r$的区间。 $[3,l,r,x]$，问能否从$l$到$r$这个区间内的所有数中选出一些，使得其和为$x$。能的话输出Yes，否则输出No $n,q\leq 100000$，$k\leq 10$ 记查询操作的数量为$p$，有$p\leq 1000$。所有出现的数字均不超过$10^5$。 SolutionClick to view the solution既然所有的不同的数不会超过$10$个，那么我们就暴力用平衡树维护这个序列。用非旋Treap或者splay维护翻转都是常规操作。每次查询我们就用平衡树求出这个区间每种数有多少个，然后去做多重背包。但是这样复杂度很凉，考虑优化。复杂度过高的原因之一是物品的数量可以达到$O(nk)$级别，值域也是$O(n)$级别。对于多重背包，有一种经典有趣的方法将其转化为物品为log级别的01背包。我们考虑某种价值为$w$的物品，有$c$个。我们把$c$拆成$2$的次幂相加的形式，即$c=1+2+4+8+…+2^t+x$，其中$x$是一个零头。然后我们可以将这$c$个价值为$w$的物品改为价值为$w$，$2w$，$4w$，$8w$，…，$2^tw$，$xw$这些。根据二进制拆分的性质，我们可以得到这log个物品可以组出原来所有能组出的价值。这样我们把问题转化成了物品数量为$klogn$的01背包。但算算复杂度还是有些大。注意到我们的dp只需要维护某种和能否组出，相当于一个0/1变量。考虑压位。转移的时候用左移操作来取代之前的加。这样可以除以64的常数，大概就能过了。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,q;int a[MAXN+48],toind[MAXN+48],toval[48],ind;int cnt[48];int w[1048],wtot;bitset&lt;MAXN+48&gt; dp[448];namespace Treap&#123; struct node &#123; int left,right,val,priority; int cnt[11],sz,flip; &#125;tree[MAXN*4];int tot,Root; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].left].flip^=1; tree[tree[cur].right].flip^=1; swap(tree[cur].left,tree[cur].right); tree[cur].flip=0; &#125; &#125; inline void pushup(int cur) &#123; memset(tree[cur].cnt,0,sizeof(tree[cur].cnt)); if (tree[cur].left) for (register int i=1;i&lt;=ind;i++) tree[cur].cnt[i]+=tree[tree[cur].left].cnt[i]; if (tree[cur].right) for (register int i=1;i&lt;=ind;i++) tree[cur].cnt[i]+=tree[tree[cur].right].cnt[i]; tree[cur].cnt[tree[cur].val]++; tree[cur].sz=1; if (tree[cur].left) tree[cur].sz+=tree[tree[cur].left].sz; if (tree[cur].right) tree[cur].sz+=tree[tree[cur].right].sz; &#125; inline int Create (int left,int right,int val,int priority) &#123; ++tot; tree[tot].left=left;tree[tot].right=right;tree[tot].val=val;tree[tot].priority=priority; pushup(tot);return tot; &#125; inline Pair split(int cur,int k) &#123; if (!cur) return mp(0,0); pushdown(cur); int leftsz=tree[tree[cur].left].sz+1; if (k&gt;=leftsz) &#123; Pair splitted=split(tree[cur].right,k-leftsz); tree[cur].right=splitted.x;pushup(cur); return mp(cur,splitted.y); &#125; else &#123; Pair splitted=split(tree[cur].left,k); tree[cur].left=splitted.y;pushup(cur); return mp(splitted.x,cur); &#125; &#125; inline int merge(int root1,int root2) &#123; if (!root1 || !root2) return root1^root2; pushdown(root1);pushdown(root2); if (tree[root1].priority&lt;tree[root2].priority) &#123; tree[root1].right=merge(tree[root1].right,root2); pushup(root1);return root1; &#125; else &#123; tree[root2].left=merge(root1,tree[root2].left); pushup(root2);return root2; &#125; &#125; inline void modify(int pos,int nv) &#123; nv=toind[nv]; Pair splitted=split(Root,pos-1),splitted2=split(splitted.y,1); Root=merge(splitted.x,merge(Create(0,0,nv,rand()),splitted2.y)); &#125; inline void reverse(int l,int r) &#123; Pair splitted=split(Root,l-1),splitted2=split(splitted.y,r-l+1); tree[splitted2.x].flip^=1; Root=merge(splitted.x,merge(splitted2.x,splitted2.y)); &#125; inline void getcnt(int l,int r) &#123; Pair splitted=split(Root,l-1),splitted2=split(splitted.y,r-l+1); for (register int i=1;i&lt;=ind;i++) cnt[i]=tree[splitted2.x].cnt[i]; Root=merge(splitted.x,merge(splitted2.x,splitted2.y)); &#125; inline void construct() &#123; Root=0;tot=0; for (register int i=1;i&lt;=n;i++) Root=merge(Root,Create(0,0,toind[a[i]],rand())); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q); for (register int i=1;i&lt;=n;i++) &#123; scanf("%d",a+i); if (!toind[a[i]]) toind[a[i]]=++ind,toval[ind]=a[i]; &#125; Treap::construct();int op,l,r,x; while (q--) &#123; scanf("%d",&amp;op); if (op==1) &#123; scanf("%d%d",&amp;l,&amp;x); if (!toind[x]) toind[x]=++ind,toval[ind]=x; Treap::modify(l,x); &#125; if (op==2) &#123; scanf("%d%d",&amp;l,&amp;r); Treap::reverse(l,r); &#125; if (op==3) &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); Treap::getcnt(l,r);wtot=0; for (register int i=1;i&lt;=ind;i++) &#123; int tmp=cnt[i],pw=1; while (tmp&gt;pw) &#123; if (1ll*pw*toval[i]&lt;=x) w[++wtot]=1ll*pw*toval[i]; tmp-=pw;pw&lt;&lt;=1; &#125; if (tmp &amp;&amp; 1ll*tmp*toval[i]&lt;=x) w[++wtot]=1ll*tmp*toval[i]; &#125; dp[0][0]=1; for (register int i=1;i&lt;=wtot;i++) dp[i]=dp[i-1]|(dp[i-1]&lt;&lt;w[i]); if (dp[wtot][x]==1) puts("Yes"); else puts("No"); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>背包</category>
        <category>平衡树</category>
        <category>二进制拆分</category>
        <category>压位</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>CodeChef</tag>
        <tag>平衡树</tag>
        <tag>二进制拆分</tag>
        <tag>压位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef JUMP]Jump Mission 题解]]></title>
    <url>%2Fblog%2FccJUMP%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 有$n$座山峰，第$i$座山峰高度为$H_i$，有两个属性值$P_i,A_i$。一个人初始在$1$号山峰，要到$n$号山峰。一个人能从$i$号山峰跳到$j$号山峰当且仅当$i&lt;j$且$P_i&lt;P_j$，要花费$(H_i-H_j)^2$的代价。每到一座山峰$i$(包括$1$号山峰)，这个人都要额外花费$A_i$的代价。问这个人最少需要多少花费。 $n\leq 300000,H_i\leq 600000$，$P_i$是一个$1$到$n$的排列。 SolutionClick to view the solution这个看上去很像dp+斜率优化，先写出转移方程式:$$dp[i]=min_{j=1}^{i-1}dp[j]+(H_i-H_j)^2+A_i$$将括号打开，我们有$$dp[i]=min_{j=1}^{i-1}dp[j]+A_j+H_i^2+H_j^2-2H_iH_j$$接着我们发现了一个问题：如果化成了斜率优化的式子，右边的$H_i$没有单调性。然后就自闭了尝试从别的角度考虑。我们观察这个转移方程式，发现右边可以写成一个一次函数的形式。除了只和$i$有关的项，剩下的是$-2H_jx+dp[j]+H_j^2$。$H_i$相当于自变量。这样我们只要维护$1$到$j-1$的这些直线，然后决策$i$的时候求这些直线在$H_i$处的最小值即可。插入直线和查询某点处的最小值，我们可以用李超树实现。现在还有$P_i&lt;P_j$才能转移的条件。这个和NFLSoj 比赛的套路是一样的。考虑cdq分治。令$solve(l,r)$表示处理$dp[l]$到$dp[r]$。我们先$solve(l,mid)$，然后考虑左边对右边的贡献。把左边和右边都按照$P_i$排序，然后类似归并排序那样，如果左边的$P_i$小，就把对应的直线加到李超树里，否则拿着右边的$H_i$在李超树里查询。注意当$l=r$时，$solve(l,r)$要给$dp$值加上$A_l+H_l^2$。虽然李超树添加直线的复杂度是$O(log^2n)$的，但是这题里面加的都是全局的直线，所以添加的复杂度其实是$O(logn)$，加上cdq分治的$O(logn)$，总时间复杂度是$O(nlog^2n)$。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e18;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=6e5;int n;LL p[MAXN+48],a[MAXN+48],h[MAXN+48];LL dp[MAXN+48];inline LL Query(LL k,LL b,LL pos)&#123; if (k&gt;0) return LINF; return k*pos+b;&#125;namespace LiChaoTree&#123; int lson[MAXN*20+48],rson[MAXN*20+48];LL k[MAXN*20+48],b[MAXN*20+48];int Root,tot; inline int Create() &#123; ++tot;lson[tot]=rson[tot]=0; k[tot]=1;b[tot]=0;return tot; &#125; inline void build() &#123;tot=Root=0;&#125; inline void modify(int &amp;cur,LL curk,LL curb,int l,int r) &#123; if (!cur) cur=Create(); if (k[cur]&gt;0) &#123;k[cur]=curk;b[cur]=curb;return;&#125; if (l==r) &#123; if (Query(curk,curb,l)&lt;=Query(k[cur],b[cur],l)) k[cur]=curk,b[cur]=curb; return; &#125; int mid=(l+r)&gt;&gt;1; if (curk&lt;=k[cur]) &#123; if (Query(curk,curb,mid)&lt;=Query(k[cur],b[cur],mid)) &#123; modify(lson[cur],k[cur],b[cur],l,mid); k[cur]=curk;b[cur]=curb; &#125; else modify(rson[cur],curk,curb,mid+1,r); &#125; else &#123; if (Query(curk,curb,mid)&lt;=Query(k[cur],b[cur],mid)) &#123; modify(rson[cur],k[cur],b[cur],mid+1,r); k[cur]=curk;b[cur]=curb; &#125; else modify(lson[cur],curk,curb,l,mid); &#125; &#125; inline LL query(int cur,int pos,int l,int r) &#123; if (!cur) return LINF; LL res=Query(k[cur],b[cur],pos); if (l==r) return res; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) check_min(res,query(lson[cur],pos,l,mid)); else check_min(res,query(rson[cur],pos,mid+1,r)); return res; &#125;&#125;int seq[MAXN+48];inline bool cmp(int x,int y) &#123;return p[x]&lt;p[y];&#125;inline void solve(int l,int r)&#123; if (l==r) &#123;if (l!=1) dp[l]+=h[l]*h[l]+a[l];return;&#125; int mid=(l+r)&gt;&gt;1;solve(l,mid);LiChaoTree::build(); for (register int i=l;i&lt;=r;i++) seq[i]=i; sort(seq+l,seq+mid+1,cmp);sort(seq+mid+1,seq+r+1,cmp); int k1,k2; for (k1=l,k2=mid+1;k1&lt;=mid &amp;&amp; k2&lt;=r;) &#123; int x=seq[k1],y=seq[k2]; if (p[x]&lt;p[y]) LiChaoTree::modify(LiChaoTree::Root,h[x]*(-2),h[x]*h[x]+dp[x],1,MAXN),k1++; else check_min(dp[y],LiChaoTree::query(LiChaoTree::Root,h[y],1,MAXN)),k2++; &#125; while (k2&lt;=r) &#123; int y=seq[k2++]; check_min(dp[y],LiChaoTree::query(LiChaoTree::Root,h[y],1,MAXN)); &#125; solve(mid+1,r);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n); for (register int i=1;i&lt;=n;i++) scanf("%lld",p+i); for (register int i=1;i&lt;=n;i++) scanf("%lld",a+i); for (register int i=1;i&lt;=n;i++) scanf("%lld",h+i); for (register int i=2;i&lt;=n;i++) dp[i]=LINF;dp[1]=a[1]; solve(1,n); printf("%lld\n",dp[n]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>cdq分治</category>
        <category>线段树</category>
        <category>李超树</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>cdq分治</tag>
        <tag>线段树</tag>
        <tag>CodeChef</tag>
        <tag>李超树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #643C]Levels and Regions 题解]]></title>
    <url>%2Fblog%2Fcf643c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$n$的数列，你要把它分成$k$段，每段要求不为空。每一段的代价这样计算：对于每个数$t_i$，取到它的概率是$\frac{t_i}{\sum_{j=1}^it_i}$。如果没有取到就继续取直到取到为止。先取第一个数，取到以后才可以去取第二个数，以此类推。一段的代价是取出所有数的期望时间之和。求怎样划分可以使得总代价最小，输出最小总代价。 $n\leq 200000,k\leq 50$ SolutionClick to view the solution这题dp加斜率优化的思路还是挺明显的，关键是怎么推式子。令$calc(l,r)$表示从$l$到$r$这一段的价值。显然$t_i$取到所需的期望时间是$\frac{\sum_{j=l}^i}{t_i}$，对这个东西求和需要通分，感觉并不好求。我们考虑提取$t_l,t_{l+1}…t_r$的系数。我们发现$t_l$的系数是$\sum_{j=l}^r\frac{1}{t_j}$，$t_{l+1}$的系数是$\sum_{j=l+1}^r\frac{1}{t_j}$，以此类推。我们定义$p(i)=\sum_{j=1}^it_i$，$q(i)=\sum_{j=1}^i\frac{1}{t_j}$，则我们可以得到$$ans=\sum_{i=l}^rt_i(q(r)-q(i-1))=\sum_{i=l}^rt_iq(r)-\sum_{i=l}^rt_iq(i-1)=(p(r)-p(l-1))q(r)-\sum_{i=l}^rt_iq(i-1)$$我们再定义$r(i)=\sum_{j=1}^it_iq(i-1)$，则我们有$$ans=(p(r)-p(l-1))q(r)+(r[r]-r[l-1])$$这其中$p,q,r$都是可以线性预处理的。于是我们将$calc(l,r)$写成了一个只和$l$和$r$有关的可以$O(1)$计算的多项式，之后就是斜率优化的套路了。注意做除法的时候如果是负数不等号要变方向写一下最后的式子$$\frac{(dp[j]+r[j])-(dp[k]+r[k])}{p[j]-p[k]}&gt;q[i]$$这个用单调队列维护一下就可以了，总时间复杂度$O(nk)$。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-12;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;inline bool islarger(double x,double y) &#123;return x-y&gt;eps;&#125;inline bool issmaller(double x,double y) &#123;return x-y&lt;-eps;&#125;inline bool isequal(double x,double y) &#123;return (!islarger(x,y)) &amp;&amp; (!issmaller(x,y));&#125;int n,k;int t[MAXN+48];double dp[51][MAXN+48];double p[MAXN+48],q[MAXN+48],r[MAXN+48];inline void init()&#123; for (register int i=1;i&lt;=n;i++) p[i]=p[i-1]+t[i]; for (register int i=1;i&lt;=n;i++) q[i]=q[i-1]+double(1.0)/t[i]; for (register int i=1;i&lt;=n;i++) r[i]=r[i-1]+double(1.0)*double(t[i])*q[i-1];&#125;inline double calc_k(double x1,double y1,double x2,double y2)&#123; if (isequal(x1,x2)) return 1e16; return (y1-y2)/(x1-x2);&#125;inline double calc(int left,int right)&#123; return p[right]*q[right]-p[left-1]*q[right]-r[right]+r[left-1];&#125;struct node&#123; double x,y;int ind; node () &#123;&#125; inline node(double _x,double _y,int _i) &#123;x=_x;y=_y;ind=_i;&#125;&#125;Q[MAXN+48];int head,tail;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;k); for (register int i=1;i&lt;=n;i++) scanf("%d",t+i); init(); for (register int i=1;i&lt;=n;i++) dp[1][i]=calc(1,i); for (register int layer=2;layer&lt;=k;layer++) &#123; head=tail=1;Q[1]=node(p[layer-1],dp[layer-1][layer-1]+r[layer-1],layer-1); for (register int i=layer;i&lt;=n;i++) &#123; while (head&lt;tail &amp;&amp; issmaller(calc_k(Q[head].x,Q[head].y,Q[head+1].x,Q[head+1].y),q[i])) head++; int chosen=Q[head].ind; dp[layer][i]=dp[layer-1][chosen]+calc(chosen+1,i); Q[++tail]=node(p[i],dp[layer-1][i]+r[i],i); while (head+1&lt;tail &amp;&amp; issmaller(calc_k(Q[tail-1].x,Q[tail-1].y,Q[tail].x,Q[tail].y),calc_k(Q[tail-2].x,Q[tail-2].y,Q[tail-1].x,Q[tail-1].y))) Q[tail-1]=Q[tail],tail--; &#125; &#125; printf("%.10lf\n",dp[k][n]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #33][UR #2]树上GCD 题解]]></title>
    <url>%2Fblog%2Fuoj33%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一棵$n$个点的数，定义$d(u,v)$表示树上点$u$到点$v$的距离。定义$f(u,v)=\operatorname{gcd}(d(u,lca_{u,v}),d(v,lca_{u,v}))$。对于所有的$i\in { 1,2… n-1}$，求出有多少对$u,v(u&lt;v)$满足$f(u,v)=i$。 $n\leq 200000$ SolutionClick to view the solution直接维护gcd非常麻烦，根据套路，我们应该令$g(n)=\sum_{n\mid d}ans(d)$，最后莫比乌斯反演一下就好了。现在我们要对于每个$i$求出有多少对点的$f$值是$i$的倍数。考虑长链剖分。我们在合并的时候对于每个$i$枚举倍数。但我们发现一个问题：如果短链的长度总是$1$，比如一条长链加上很多很多的短链，复杂度会退化到$O(n^2)$考虑分块。定义$B=\sqrt n$，对于那些大于$B$的倍数暴力，对于小于$B$的维护$f[i][j]$表示深度模$i$余$j$的点有多少个即可。总时间复杂度$O(n\sqrt n)$。对于如何保留长儿子的信息，可以参考代码。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=48;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n;vector&lt;int&gt; v[MAXN+48];int son[MAXN+48],depth[MAXN+48],cntdepth[MAXN+48],level[MAXN+48];LL curson[MAXN+48];int pos[MAXN+48],ind;LL val[MAXN+48];LL f[magic+48][magic+48];LL ans[MAXN+48],fans[MAXN+48];inline void dfs1(int cur)&#123; level[cur]=depth[cur];son[cur]=0;cntdepth[depth[cur]]++; for (auto y : v[cur]) &#123; depth[y]=depth[cur]+1;dfs1(y); if (level[y]&gt;level[cur]) level[cur]=level[y],son[cur]=y; &#125;&#125;inline void dfs2(int cur)&#123; pos[cur]=++ind; if (son[cur]) dfs2(son[cur]); for (auto y : v[cur]) if (y!=son[cur]) dfs2(y);&#125;inline void solve(int cur,bool isheavy)&#123; for (auto y : v[cur]) if (y!=son[cur]) solve(y,false); if (son[cur]) solve(son[cur],true); for (auto y : v[cur]) &#123; if (y==son[cur]) continue; int maxdepth=level[y]-depth[y]; for (register int d=0;d&lt;=maxdepth;d++) &#123; curson[d]=val[pos[y]+d]; for (register int dd=d*2+1;dd&lt;=maxdepth;dd+=d+1) val[pos[y]+d]+=val[pos[y]+dd]; if (d+1&lt;=magic) ans[d+1]+=1ll*val[pos[y]+d]*f[d+1][(depth[y]+d)%(d+1)]; else for (register int dd=d+1;dd&lt;=level[cur]-depth[cur];dd+=d+1) ans[d+1]+=1ll*val[pos[y]+d]*val[pos[cur]+dd]; &#125; for (register int d=0;d&lt;=maxdepth;d++) val[pos[cur]+d+1]+=curson[d]; for (register int d=0;d&lt;=maxdepth;d++) for (register int i=1;i&lt;=magic;i++) f[i][(depth[y]+d)%i]+=curson[d]; &#125; val[pos[cur]]++; if (isheavy) &#123; for (register int i=1;i&lt;=magic;i++) f[i][depth[cur]%i]++; &#125; else &#123; for (register int d=1;d&lt;=level[cur]-depth[cur];d++) for (register int i=1;i&lt;=magic;i++) f[i][(depth[cur]+d)%i]=0; &#125;&#125;int mu[MAXN+48];bool isprime[MAXN+48];int prime[MAXN+48],tot;inline void init_mu()&#123; mu[1]=1;memset(isprime,true,sizeof(isprime)); for (register int i=2;i&lt;=n;i++) &#123; if (isprime[i]) prime[++tot]=i,mu[i]=-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=n;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int x;scanf("%d",&amp;n); for (register int i=2;i&lt;=n;i++) scanf("%d",&amp;x),v[x].pb(i); depth[1]=0;dfs1(1);dfs2(1); for (register int i=n;i&gt;=0;i--) cntdepth[i]+=cntdepth[i+1]; solve(1,false); init_mu(); for (register int i=1;i&lt;=n-1;i++) for (register int d=i;d&lt;=n-1;d+=i) fans[i]+=ans[d]*mu[d/i]; for (register int i=1;i&lt;=n-1;i++) printf("%lld\n",fans[i]+cntdepth[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数学</category>
        <category>莫比乌斯反演</category>
        <category>分块</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
        <tag>树链剖分</tag>
        <tag>UOJ</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #388][UNR #3]配对树 题解]]></title>
    <url>%2Fblog%2Fuoj388%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个长度为$m$的每个元素在$[1,n]$的数列和一棵$n$的点的树。对于序列的每一个偶数长度的区间，在树上将这些点两两匹配，定义代价为每对点的距离之和。求所有区间的最小代价之和模$998244353$。 $n,m\leq 100000$ SolutionClick to view the solution这个题如果思维方向不正确就永远做不出来。考虑树上的每条边会在多少个区间内被走。有一个重要的结论：一个区间的点的匹配中，一条边最多被走一次，且仅当其子树内有奇数个点被选中时才会被走。即点会在子树内尽可能的先匹配。简单的证明这个结论：如果在某子树内选择两个点和外面匹配，那么这两条路径必然有相交的部分。考虑换个方法匹配，子树内的两个点匹配，子树外的两个点匹配，这样路径中间的重合部分就可以省下来了，方案更优。枚举每一条边，考虑将子树内的点在区间上标记为$1$，我们要求的问题是有多少个偶数长度区间的异或和为$1$。我们可以这样计算。我们数奇数位置上，前缀异或和为$0$的个数和前缀异或和为$1$的个数，这些位置两两匹配都是合法的偶数长度区间，相乘即可。偶数位置上也是一样。最后两个加起来即可。这个方法十分方便，我们只要用线段树来维护区间，$cnt[0/1][0/1]$表示奇数/偶数位置,在该区间内前缀异或和是$0/1$的方案数。合并的时候关注左边区间的$1$的个数，如果是奇数就反转一下右边区间的$cnt[0][0/1]$和$cnt[1][0/1]$即可。我们还需要动态维护子树内的点在数列上的位置，这个线段树合并即可。总时间复杂度$O(nlogn)$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];int a[MAXN+48];vector&lt;int&gt; pos[MAXN+48];inline int Count(int l,int r,int type) //0: even; 1: odd;&#123; int res=(r-l+1)/2; if ((l&amp;1)==(r&amp;1) &amp;&amp; (l&amp;1)==type) res++; return res;&#125;int root[MAXN+48];namespace SegmentTree&#123; int xsum[MAXN*40+48],cnt[MAXN*40+48][2][2],lson[MAXN*40+48],rson[MAXN*40+48],tot; inline int Create(int l,int r) &#123; ++tot;lson[tot]=rson[tot]=0; xsum[tot]=0; cnt[tot][0][1]=cnt[tot][1][1]=0; cnt[tot][0][0]=Count(l,r,0);cnt[tot][1][0]=Count(l,r,1); return tot; &#125; inline void pushup(int cur) &#123; if (!lson[cur] &amp;&amp; !rson[cur]) return; int Cnt[2][2];memcpy(Cnt,cnt[rson[cur]],sizeof(cnt[rson[cur]])); if (xsum[lson[cur]]) swap(Cnt[0][0],Cnt[0][1]),swap(Cnt[1][0],Cnt[1][1]); for (register int i=0;i&lt;=1;i++) for (register int j=0;j&lt;=1;j++) cnt[cur][i][j]=cnt[lson[cur]][i][j]+Cnt[i][j]; xsum[cur]=xsum[lson[cur]]^xsum[rson[cur]]; &#125; inline void insert(int &amp;cur,int pos,int l,int r) &#123; if (!cur) cur=Create(l,r); if (l==r) &#123; xsum[cur]=1; memset(cnt[cur],0,sizeof(cnt[cur])); cnt[cur][l&amp;1][1]=1; return; &#125; int mid=(l+r)&gt;&gt;1; if (!lson[cur]) lson[cur]=Create(l,mid); if (!rson[cur]) rson[cur]=Create(mid+1,r); if (pos&lt;=mid) insert(lson[cur],pos,l,mid); else insert(rson[cur],pos,mid+1,r); pushup(cur); &#125; inline int merge(int root1,int root2,int l,int r) &#123; if (!root1 || !root2) return root1^root2; if (l==r) &#123; if (!xsum[root1] &amp;&amp; !xsum[root2]) return root1; xsum[root1]=1; memset(cnt[root1],0,sizeof(cnt[root1])); cnt[root1][l&amp;1][1]=1; return root1; &#125; int mid=(l+r)&gt;&gt;1; lson[root1]=merge(lson[root1],lson[root2],l,mid); rson[root1]=merge(rson[root1],rson[root2],mid+1,r); pushup(root1);return root1; &#125; inline int query(int cur) &#123;if (!cur) return 0;return add(1ll*cnt[cur][0][0]*cnt[cur][0][1]%MOD+1ll*cnt[cur][1][0]*cnt[cur][1][1]%MOD);&#125;&#125;int ans=0;inline void dfs(int cur,int father,int faedge)&#123; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i].x; if (y!=father) dfs(y,cur,v[cur][i].y),root[cur]=SegmentTree::merge(root[cur],root[y],0,m); &#125; if (father!=-1) Add(ans,1ll*faedge*SegmentTree::query(root[cur])%MOD);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m);int x,y,c; for (register int i=1;i&lt;=n-1;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); v[x].pb(mp(y,c));v[y].pb(mp(x,c)); &#125; for (register int i=1;i&lt;=m;i++) scanf("%d",a+i),pos[a[i]].pb(i); for (register int i=1;i&lt;=n;i++) for (auto p : pos[i]) SegmentTree::insert(root[i],p,0,m); dfs(1,-1,-1);printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>思维</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #37][清华集训2014]主旋律 题解]]></title>
    <url>%2Fblog%2Fuoj37%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个$n$个顶点$m$条边的有向图，求它有多少个生成子图是强连通的。 $n\leq 15,m\leq n(n-1)$ SolutionClick to view the solution这是一道非常神的状压dp题。正难则反，我们考虑用所有的生成子图减去不强联通的生成子图就能得到答案。现在考虑数不强连通的生成子图个数。一个不强联通的生成子图在把SCC缩点后一定会得到一个DAG。考虑一个暴力的做法：我们枚举SCC的代表元素集合$S$，令$f[S]$表示缩点后SCC是$S$的情况下有多少种方案可以连出一个DAG。转移的话考虑到DAG中一定有一系列入度为$0$的点，我们枚举这个入度为$0$的集合，然后从这个入度为$0$的集合向补集任意连边，可以得到转移方程式$$f[S]=\sum_{T\subset S,T\neq \emptyset}2^{cross[T][S-T]}f[S-T]$$其中$cross[x][y]$表0示所有起始点在$x$中，结束点在$y$中的边的条数，形式化的，$$cross[x][y]=\sum_{&lt;u,v&gt;\in E}[u\in x][v\in y]$$仔细想想发现这个转移方程式是错的，因为我们是任意连边，没有保证$S-T$中所有的点入度都不为$0$。更具体的，对于某一个图，它的入度为$0$的点集的所有子集都会被我枚举到。那么不妨用容斥来解决这个问题。于是我们有正确的转移方程式$$f[S]=\sum_{T\subset S,T\neq \emptyset}(-1)^{\mid T\mid-1}2^{cross[T][S-T]}f[S-T]$$由于要枚举SCC，这个算法复杂度奇高。但是我们发现事实上我们只关心SCC个数的奇偶性从而确定容斥系数，而不关心SCC具体是谁。我们考虑令$g_k[T]$表示将点集$T$划分成$k$个SCC的方案数，重定义$f[S]$表示点集$S$能形成多少个不强联通生成子图。考虑枚举入度为$0$的集合$T$，把它划分成若干个SCC来转移，可以得到转移式$$f[S]=\sum_{T\subset S,T\neq \emptyset}\sum_{k=1}^{\mid T\mid}(-1)^{k-1}g_k[T]2^{cross[T][S-T]}2^{cross[S-T][S-T]}$$这里$2^{cross[S-T][S-T]}$的意义是除了这些入度为$0$的SCC，剩下的点可以随意胡闹，反正接在入度为$0$的点下面就行了。将奇偶分开，可以写成$$f[S]=\sum_{T\subset S,T\neq \emptyset}(\sum_{k=1}^{\frac{\mid T\mid+1}{2}}g_{2k-1}[T]-\sum_{k=1}^{\frac{\mid T\mid}{2}}g_{2k}[T])2^{cross[T][S-T]}2^{cross[S-T][S-T]}$$令$$p[S]=\sum_{k=1}^{\frac{\mid S\mid+1}{2}}g_{2k-1}[S]-\sum_{k=1}^{\frac{\mid S\mid}{2}}g_{2k}[S]$$令$dp[S]$表示$S$这个点集的强连通生成子图的个数，也就是答案，我们发现$p[S]$可以由$dp[S]$转移来。考虑$S$中的某一个点$u$，我们枚举一个包含$u$的点的子集作为第一个SCC，则有转移方程式$$p[S]=dp[S]-\sum_{T\subset S,u\in T}dp[T]p[S-T]$$这个负号的意义是因为多了一个集合，所以奇偶交换，原来加的减，原来减的加。至此我们已经获得了所有的转移$$dp[S]=2^{cross[S][S]}-f[S]$$$$f[S]=\sum_{T\subset S,T\neq \emptyset}p[T]2^{cross[T][S-T]}2^{cross[S-T][S-T]}$$$$p[S]=dp[S]-\sum_{T\subset S,T\neq S,u\in T}dp[T]p[S-T]$$至于$cross[x][y]$的处理，我们可以从$cross[x|y][0]$开始，每次把一个点从左边拉到右边来维护。总时间复杂度$O(3^n)$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) ((x) &amp; (-(x)))// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;int in[48],out[48],cross[MAXN+48];int dp[MAXN+48],all[MAXN+48],p[MAXN+48];int pw[MAXN+48],pos[MAXN+48],popcount[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m);int x,y; for (register int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); in[y]|=(1&lt;&lt;(x-1));out[x]|=(1&lt;&lt;(y-1)); &#125; pw[0]=1;for (register int i=1;i&lt;=n*(n-1);i++) pw[i]=add(pw[i-1]+pw[i-1]); for (register int i=1;i&lt;=n;i++) pos[1&lt;&lt;(i-1)]=i; for (register int Mask=1;Mask&lt;=(1&lt;&lt;n)-1;Mask++) popcount[Mask]=popcount[Mask&gt;&gt;1]+(Mask&amp;1); dp[0]=all[0]=1; for (register int S=1;S&lt;=(1&lt;&lt;n)-1;S++) &#123; if (popcount[S]==1) &#123;dp[S]=p[S]=all[S]=1;continue;&#125; int tmp=0; for (register int i=1;i&lt;=n;i++) if (S&amp;(1&lt;&lt;(i-1))) tmp+=popcount[S&amp;out[i]]; all[S]=dp[S]=pw[tmp]; int u=LOWBIT(S); for (register int sub=(S-u);;sub=(sub-1)&amp;(S-u)) &#123; int T=(sub|u); if (T!=S) Sub(p[S],1ll*dp[T]*p[S-T]%MOD); if (!sub) break; &#125; for (register int T=S;T;T=(T-1)&amp;S) &#123; if (T==S) cross[T]=0; else &#123; int u=pos[LOWBIT(S-T)]; cross[T]=cross[T+(1&lt;&lt;(u-1))]+popcount[in[u]&amp;T]-popcount[out[u]&amp;(S-T-(1&lt;&lt;(u-1)))]; &#125; Sub(dp[S],1ll*p[T]*pw[cross[T]]%MOD*all[S-T]%MOD); &#125; Add(p[S],dp[S]); &#125; printf("%d\n",dp[(1&lt;&lt;n)-1]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>容斥原理</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1086E]Beautiful Matrix 题解]]></title>
    <url>%2Fblog%2Fcf1086e%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 定义一个$n*n$的矩阵是美丽的，当且仅当它的每一行都是一个$1$到$n$的排列，且整个矩阵中任意两个相邻的元素都不相同。 输入$n$和一个$n*n$的美丽的矩阵，问它在所有美丽的矩阵中的字典序排名(0 base)。此处字典序排名指的是先比较第一行，再比较第二行……以此类推。 $n,m\leq 2000$ SolutionClick to view the solution先考虑一个非常简单的问题：$n*n$的美丽矩阵一共有多少个？显然第一行有$n!$种安排方法，之后的每一行都和上一行形成一个错排问题。设$n$个元素的错排问题方案数为$d_n$，则总个数为$n!\cdot d_n^{n-1}$考虑原问题。原问题等价于数有多少个美丽的矩阵字典序比给定矩阵小。考虑枚举第一个比给定矩阵小的元素的位置。之前的元素肯定都是一样的。现在我们关心的是当前的这个元素的取法以及当前行后一半的安排方法。后面的行又可以用错排问题解决了。先考虑当前元素在第一行的情况。这种比较简单，因为没有上一行的限制。对于当前元素$(1,j)$，我们只要数一下$(1,1)$到$(1,j-1)$有多少个数比$(1,j)$小，就能算出当前格子的方案数，后面的直接阶乘即可。这个可以用BIT维护。再考虑后面的行。这时我们就要考虑上一行对这一行后半部分的影响。设当前位置为$(x,y)$，我们发现我们关心的是这样一个问题：$(x-1,y+1)$到$(x-1,n)$的元素中有多少个没有在$(x,1)$到$(x,y)$中出现过？因为这些元素会对后半部分形成约束。所以后半部分其实是一个扩展错排问题，即$n$个元素中有$m$个有限制，其中$m\leq n$。上述的问题并不难，我们考虑数有多少个数在两行都出现过，维护一个$cnt$数组，每次$(x,y)$移动的时候在$cnt$数组上加加减减，维护那些$cnt=2$的个数即可。比较难的是当前位置$(x,y)$的数怎么确定。我们发现有些选法会使得后面的限制数-1，有些选法不会，主要取决于选的数是否在上一行的后半部分出现过。稍微仔细的用BIT进行计算，这个问题也不难。即在$O(1)$计算扩展错排问题答案的前提下我们可以将这个问题做到$O(n^2logn)$。最后我们考虑扩展错排问题如何计算。令$dp[i][j]$表示$i$个物品，有$j$个有限制的放置方案数。我们不妨设有限制的是$1$到$j$这前$j$个物品。分两种情况讨论：1. $i&gt;j$，此时考虑最后一个物品的位置，注意最后一个物品是肯定没有限制的。它有$(i-j)$种方法选择一个位置且不是任何一个其他元素的禁忌位置，这样就没有减少约束的个数。它也有$j$种方法占掉某个元素的禁忌位置，这样约束就少了一个。状态转移方程为$dp[i][j]=(i-j)\cdot dp[i-1][j]+j\cdot dp[i-1][j-1]$2. $i=j$，这种情况退化为普通的错排问题。仍然考虑最后一个位置。它有一个约束所以只有$i-1$种选法，无论怎样都会占据一个别的元素的禁忌位置，所以约束少了2。状态转移方程为$dp[i][j]=(i-1)\cdot dp[i-1][j-2]$ CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2000;int n,a[MAXN+48][MAXN+48];int fac[MAXN+48];int d[MAXN+48][MAXN+48],pw[MAXN+48];inline void init()&#123; d[0][0]=1;d[1][0]=1; for (register int i=2;i&lt;=n;i++) for (register int j=0;j&lt;=i;j++) if (i!=j) d[i][j]=add(1ll*(i-j)*d[i-1][j]%MOD+1ll*j*d[i-1][j-1]%MOD); else d[i][j]=1ll*(i-1)*d[i-1][j-2]%MOD; fac[0]=1;for (register int i=1;i&lt;=n;i++) fac[i]=1ll*fac[i-1]*i%MOD; pw[0]=1;for (register int i=1;i&lt;=n;i++) pw[i]=1ll*pw[i-1]*d[n][n]%MOD;&#125;int cnt[MAXN+48];struct BIT&#123; int c[MAXN+48]; inline void init() &#123;memset(c,0,sizeof(c));&#125; inline void modify(int x,int delta) &#123;while (x&lt;=n) c[x]+=delta,x+=LOWBIT(x);&#125; inline int query(int x) &#123;int res=0;while (x) res+=c[x],x^=LOWBIT(x);return res;&#125; inline int calc(int l,int r) &#123;return query(r)-query(l-1);&#125;&#125;s1,s2;struct SuperBIT&#123; int c[MAXN+48],cc[MAXN+48]; inline void init() &#123;memset(c,0,sizeof(c));memset(cc,0,sizeof(cc));&#125; inline void modify(int x,int delta) &#123; cc[x]+=delta; if ((delta==1 &amp;&amp; cc[x]==1) || (delta==-1 &amp;&amp; cc[x]==0)) while (x&lt;=n) c[x]+=delta,x+=LOWBIT(x); &#125; inline int query(int x) &#123;int res=0;while (x) res+=c[x],x^=LOWBIT(x);return res;&#125; inline int calc(int l,int r) &#123;return query(r)-query(l-1);&#125;&#125;s3;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); init();s1.init();int ans=0; for (register int i=1;i&lt;=n;i++) &#123; int avai=a[1][i]-1-s1.query(a[1][i]-1); Add(ans,1ll*avai*fac[n-i]%MOD*pw[n-1]%MOD); s1.modify(a[1][i],1); &#125; for (register int i=2;i&lt;=n;i++) &#123; s1.init();s2.init();s3.init();memset(cnt,0,sizeof(cnt));int Cnt=0; for (register int j=2;j&lt;=n;j++) s2.modify(a[i-1][j],1),s3.modify(a[i-1][j],1),cnt[a[i-1][j]]++; for (register int j=1;j&lt;=n;j++) &#123; int avai=a[i][j]-1-s1.query(a[i][j]-1)-(a[i-1][j]&lt;a[i][j] &amp;&amp; !s1.calc(a[i-1][j],a[i-1][j])); int m=(n-j)-Cnt; int type1=a[i][j]-1-s3.query(a[i][j]-1)-(a[i-1][j]&lt;a[i][j] &amp;&amp; !s3.calc(a[i-1][j],a[i-1][j])); int type2=avai-type1; Add(ans,1ll*type1*d[n-j][m]%MOD*pw[n-i]%MOD); if (m) Add(ans,1ll*type2*d[n-j][m-1]%MOD*pw[n-i]%MOD); if (j!=n) &#123; cnt[a[i][j]]++;if (cnt[a[i][j]]==2) Cnt++; cnt[a[i-1][j+1]]--;if (cnt[a[i-1][j+1]]==1) Cnt--; s1.modify(a[i][j],1);s3.modify(a[i][j],1); s2.modify(a[i-1][j+1],-1);s3.modify(a[i-1][j+1],-1); &#125; &#125; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>BIT</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #75][UR #6]智商锁 题解]]></title>
    <url>%2Fblog%2Fuoj75%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary $t$组询问,每次询问一个数$k$，要求构造一个点数不超过$100$的图，使得其生成树个数模$998244353$等于$k$。 $t\leq 10$，$0\leq k\leq 998244352$。 SolutionClick to view the solution考虑如果有两个无向图$G_1$和$G_2$，其生成树个数分别为$C_1$和$C_2$，则我们可以把两个图的$1$号点捏在一起，其他点保持不变来获得一个新的图。在这个图中$1$号点是割点，所以其生成树个数等于$C_1C_2$。考虑随机生成一些点数在$20$左右的图，用矩阵树定理计算其生成树个数。假设我们获得了两个图的集合$S_1$和$S_2$，每个集合都有$10^6$个随机图，那么我们从$S_1$和$S_2$中各挑一个图捏起来，可以获得$10^{12}$个不同的图（$10^{12}$个图对）。理论上有很大概率可以覆盖到所有可能出现的余数。现在要解决的问题是如何快速判断是否存在这样的一个图对。考虑折半搜索，在$S_1$中枚举一个图，假设它的生成树个数是$c$，则我们需要的第二个图的生成树个数是$k\cdot c^{-1}$，提前对第二个图建一个哈希表即可。如果暴力的生成$S_1$和$S_2$，复杂度会达到$O(20^3\cdot 10^6)$，仍然不能接受。考虑和刚才相似的套路。我们先随机四个大小为$1000$的小集合$s_1,s_2,s_3,s_4$，然后$s_1$和$s_2$中的图两两合并得到$S_1$，$s_3$和$s_4$中的图两两合并得到$S_2$即可。总时间复杂度$O(10^6\cdot log(998244353)+1000\cdot 20^3+t\cdot 1000000)$，其中的$log$来自求逆元的快速幂。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;if (!x) return 0;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int N=12;int a[48][48];struct Graph&#123; vector&lt;Pair&gt; edge; int n,det; inline void clear() &#123;edge.clear();n=det=0;&#125; inline void print() &#123; printf("%d %d\n",n,int(edge.size())); for (auto item : edge) printf("%d %d\n",item.x,item.y); &#125; inline Graph operator * (Graph other) &#123; Graph res;res.clear(); res.n=n+other.n-1;res.det=1ll*det*other.det%MOD; for (auto item : edge) res.edge.pb(item); for (register int i=0;i&lt;int(other.edge.size());i++) &#123; Pair ins=other.edge[i];ins.x+=n-1;ins.y+=n-1; res.edge.pb(ins); &#125; return res; &#125;&#125;;inline int Gauss()&#123; int fl=1,ans=1; for (register int i=1;i&lt;=N-1;i++) &#123; int pt=i; while (pt&lt;=N-1 &amp;&amp; !a[pt][i]) pt++; if (pt&gt;N-1) return 0; if (pt!=i) &#123; for (register int j=i;j&lt;=N-1;j++) swap(a[i][j],a[pt][j]); fl=-fl; &#125; ans=1ll*ans*a[i][i]%MOD;int inv=quick_pow(a[i][i],MOD-2); for (register int j=i+1;j&lt;=N-1;j++) if (a[j][i]) &#123; int tmp=a[j][i]; for (register int k=i;k&lt;=N-1;k++) a[j][k]=sub(a[j][k]-1ll*a[i][k]*inv%MOD*tmp%MOD); &#125; &#125; if (fl==-1) ans=sub(-ans); return ans;&#125;inline Graph gen_graph()&#123; Graph res; memset(a,0,sizeof(a)); for (register int i=1;i&lt;=N-1;i++) for (register int j=i+1;j&lt;=N;j++) if (rand()&amp;1) Add(a[i][i],1),Add(a[j][j],1),Sub(a[i][j],1),Sub(a[j][i],1),res.edge.pb(mp(i,j)); res.n=N;res.det=Gauss();return res;&#125;vector&lt;Graph&gt; s[5];vector&lt;Pair&gt; S[3];vector&lt;int&gt; inv;unordered_map&lt;int,int&gt; Mp;inline void gen_set()&#123; for (register int i=1;i&lt;=4;i++) &#123; s[i].clear(); for (register int j=1;j&lt;=600;j++) &#123; Graph ins=gen_graph(); if (ins.det) s[i].pb(ins); &#125; &#125; S[1].clear();S[2].clear();inv.clear(); for (register int i=0;i&lt;int(s[1].size());i++) for (register int j=0;j&lt;int(s[2].size());j++) &#123; int ndet=1ll*s[1][i].det*s[2][j].det%MOD; S[1].pb(mp(i,j));inv.pb(quick_pow(ndet,MOD-2)); &#125; for (register int i=0;i&lt;int(s[3].size());i++) for (register int j=0;j&lt;int(s[4].size());j++) &#123; int ndet=1ll*s[3][i].det*s[4][j].det%MOD; S[2].pb(mp(i,j)); Mp[ndet]=int(S[2].size())-1; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif srand(time(NULL)); gen_set();int ca,k; scanf("%d",&amp;ca); while (ca--) &#123; scanf("%d",&amp;k);bool f=false; if (k==0) &#123;puts("2 0");continue;&#125; for (register int i=0;i&lt;int(S[1].size());i++) &#123; int need=1ll*k*inv[i]%MOD; if (Mp.find(need)!=Mp.end()) &#123; int ind=Mp[need]; int id1=S[1][i].x,id2=S[1][i].y,id3=S[2][ind].x,id4=S[2][ind].y; Graph g=s[1][id1];g=g*s[2][id2];g=g*s[3][id3];g=g*s[4][id4]; g.print();f=true;break; &#125; &#125; if (!f) puts("QwQ"); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>图论</category>
        <category>思维</category>
        <category>数学</category>
        <category>数据结构</category>
        <category>高斯消元</category>
        <category>随机</category>
        <category>矩阵树定理</category>
        <category>折半搜索</category>
        <category>哈希表</category>
        <category>线性代数</category>
        <category>行列式</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>图论</tag>
        <tag>随机</tag>
        <tag>UOJ</tag>
        <tag>矩阵树定理</tag>
        <tag>高斯消元</tag>
        <tag>行列式</tag>
        <tag>折半搜索</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记]矩阵树定理]]></title>
    <url>%2Fblog%2Fmatrix-tree-theorem%2F</url>
    <content type="text"><![CDATA[一些基本的定义： $deg_i$表示无向图$G$点$i$的度数。$d_{i,j}$表示$G$的度数矩阵，$d_{i,j}=deg_i$当且仅当$i=j$。 $A_{i,j}$表示$G$的邻接矩阵，$A_{i,j}=1$当且仅当点$i$和点$j$之间有边。 $K_{i,j}$表示$G$的基尔霍夫矩阵，$K_{i,j}=d_{i,j}-A_{i,j}$ 矩阵树定理: 无向图$G$的生成树个数等于其基尔霍夫矩阵的任意一个$n-1$阶主子式的行列式。 用高斯消元可以做到$O(n^3)$的时间复杂度]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>矩阵树定理</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 030D]Inversion Sum 题解]]></title>
    <url>%2Fblog%2Fagc030d%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个数列$A_n$,有$q$次操作，第$i$次操作可以选择交换或不交换$A_{X_i}$和$A_{Y_i}$。问所有的$2^q$种操作方法得到的序列的逆序对个数之和是多少。 $n,q\leq 3000$ SolutionClick to view the solution如果直接对操作进行dp感觉不可行。考虑每一对位置$i$和$j$会在多少种操作结果中成为逆序对。令$dp[t][i][j]$表示$t$次操作后，$A_i&gt;A_j$的操作方案数。转移的话考虑这次操作$(x,y)$，我们分三种情况讨论：1. $i$和$j$都不等于$x$或$y$，此时这次操作与$i$和$j$无关，$dp[t][i][j]=dp[t-1][i][j]\times 2$2. $i$和$j$分别为$x$和$y$，即$i=x,j=y$或$i=y,j=x$，则$dp[t][i][j]=dp[t-1][i][j]+dp[t-1][j][i]$3. $i$和$j$中有一个是$x$或$y$，以$i=x$为例，则$dp[t][i][j]=dp[t-1][i][j]+dp[t-1][y][j]$这样我们得到了一个$O(n^3)$的dp。还需要优化。我们发现第一类转移有$O(n^2)$种，而第二和第三种转移只有$O(n)$种。考虑修改一下dp的定义。令$dp[t][i][j]$表示$t$次操作之后，$a_i&gt;a_j$的概率。这个定义和刚才的区别在于转移的时候都要除以$2$。这样我们有$O(n^2)$中情况是不需要转移的，每次转移的代价降低到$O(n)$，从而总时间复杂度降低到$O(n^2)$。最后只要对于所有的$i&lt;j$累加$dp[q][i][j]\times 2^q$即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3000;int n,q,a[MAXN+48];int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q);int l,r,inv2=quick_pow(2,MOD-2); for (register int i=1;i&lt;=n;i++) scanf("%d",a+i); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) dp[i][j]=(a[i]&gt;a[j]); for (register int ope=1;ope&lt;=q;ope++) &#123; scanf("%d%d",&amp;l,&amp;r); dp[l][r]=dp[r][l]=1ll*add(dp[l][r]+dp[r][l])*inv2%MOD; for (register int i=1;i&lt;=n;i++) &#123; if (i==l || i==r) continue; dp[i][l]=dp[i][r]=1ll*add(dp[i][l]+dp[i][r])*inv2%MOD; dp[l][i]=dp[r][i]=1ll*add(dp[l][i]+dp[r][i])*inv2%MOD; &#125; &#125; int ans=0; for (register int i=1;i&lt;=n-1;i++) for (register int j=i+1;j&lt;=n;j++) Add(ans,dp[i][j]); ans=1ll*ans*quick_pow(2,q)%MOD; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM577DIV1C]BoardPainting 题解]]></title>
    <url>%2Fblog%2Ftcsrm577div1c%2F</url>
    <content type="text"><![CDATA[Original Description Click to open Summary 给定一个$n\times m$的棋盘，有的格子是黑的有的格子是白的。要求每次选择一个横着的区间或者一个竖着的区间去覆盖，最终要求每个黑格子恰好被覆盖一次且白格子不能被覆盖。求最少选择多少个区间。 $n,m\leq 50$ SolutionClick to view the solution我们认为，每两个相邻的黑格子中间都有一条边。刚开始每个黑格子自成一个联通块。这样我们每多选一条边，相当于少了一个联通块，从而答案减一，所以我们的目标是选择尽可能多的边。接下来考虑这题的限制，即选择的区域是不能“拐弯”的。这相当于限制了某个黑点四周的四条边中，横边和竖边不能同时选。我们把横边和竖边看成一个二分图，横边对应的点都在左边，竖边对应的点都在右边。我们在那些不能同时选的边对应的点之间连边，这样就转化成了二分图的最大独立集问题，网络流解决即可。 CodeClick to view the code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;namespace flow&#123; int head[100048],cur[100048],to[100048],nxt[100048],f[100048],tot,t; inline void init(int _t) &#123;t=_t;memset(head,0,sizeof(head));tot=1;&#125; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int Head,Tail,q[100048],depth[100048]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;Head=Tail=1;q[1]=0; while (Head&lt;=Tail) &#123; int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; if (depth[t]==-1) return false; else return true; &#125; inline int dfs(int x,int maxf) &#123; if ((!maxf) || (x==t)) return maxf; int y,minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; &#125; if (ans&gt;=maxf) return ans; &#125; if (!ans) depth[x]=0; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;int n,m;char s[148][148];vector&lt;int&gt; v[148][148];int ind;class BoardPainting&#123; inline int getind(int x,int y) &#123;return (x-1)*m+y;&#125; public: inline int minimalSteps(vector&lt;string&gt; target) &#123; n=int(target.size());m=int(target[0].size());int cnt=0; for (register int i=0;i&lt;=n+1;i++) for (register int j=0;j&lt;=m+1;j++) s[i][j]='.'; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) s[i][j]=target[i-1][j-1],cnt+=(s[i][j]=='#'); flow::init(n*m*2+1); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) if (s[i][j]=='#') &#123; if (s[i][j-1]=='#' &amp;&amp; s[i-1][j]=='#') flow::addedge(getind(i,j-1),n*m+getind(i-1,j),INF); if (s[i-1][j]=='#' &amp;&amp; s[i][j+1]=='#') flow::addedge(getind(i,j),n*m+getind(i-1,j),INF); if (s[i][j+1]=='#' &amp;&amp; s[i+1][j]=='#') flow::addedge(getind(i,j),n*m+getind(i,j),INF); if (s[i+1][j]=='#' &amp;&amp; s[i][j-1]=='#') flow::addedge(getind(i,j-1),n*m+getind(i,j),INF); &#125; int cc=0; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m-1;j++) if (s[i][j]=='#' &amp;&amp; s[i][j+1]=='#') flow::addedge(0,getind(i,j),1),cc++; for (register int i=1;i&lt;=n-1;i++) for (register int j=1;j&lt;=m;j++) if (s[i][j]=='#' &amp;&amp; s[i+1][j]=='#') flow::addedge(n*m+getind(i,j),flow::t,1),cc++; cc-=flow::dinic(); cnt-=cc;return cnt; &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;string&gt; ss;string s;int nn; BoardPainting A; while (cin&gt;&gt;nn) &#123; ss.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,ss.pb(s); cout&lt;&lt;A.minimalSteps(ss)&lt;&lt;endl; &#125; io.flush(); cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl; return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>最大流</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #422][集训队作业2018]小Z的礼物 题解]]></title>
    <url>%2Fblog%2Fuoj422%2F</url>
    <content type="text"><![CDATA[Description小Z有一个神奇的自动售货机，里面有 $n\times m$ 种物品，分别放在 $n$ 行 $m$ 列个格子中。每当小Z向自动售货机中投入一枚硬币，他就能获得一对相邻格子中的物品（已经获得的物品可能再次获得），获得每一对相邻格子中的物品的概率是相等的。在这 $n\times m$ 种物品中，有一些物品是小Z喜欢的（小Z喜欢的用 *[星号] 表示，其他的用 .[英文句号] 表示），他想把这些物品包装成一份礼物。小Z想知道，期望投入多少枚硬币后，就可以获得这些他喜欢的物品。 Input Format第一行两个整数 $n$ 和 $m$。 接下来 $n$ 行，每行一个长度为 $m$ 的字符串，字符串中仅包含 * 和 . 两种字符。 Output Format一个整数，表示在模 $998244353$ 意义下的答案。 Sample Input 11 3 *** Sample Output 13 Sample Input 23 3 ..* *.* .*. Sample Output 2404051295 Constraints 对于所有数据，保证 $1\leq n\leq 6$,$2\leq m\leq 100$。 Solution先考虑一个很暴力的做法：考虑Min-Max容斥，这样转化为求某个集合第一个星号被覆盖的期望时间。设星号总个数为$x$，我们$2^x$枚举星号的子集，然后统计有多少个小矩形能覆盖到某一个星号，假设有$c$个，那么第一个星号被覆盖的期望时间就是$\frac{n(m-1)+(n-1)m}{c}$，其中分子是所有小矩形的个数之和。 注意到$n$非常小，于是可以考虑轮廓线dp。令$dp[i][j][Mask][num][0/1]$表示当前考虑到第$i$列第$j$行，“上一行”，即第$i$列的$1$到$j-1$行和第$i-1$列的$j$到$n$行这些格子被选中的状态为Mask, 当前能覆盖到星号的矩形一共有num个，选择的星号个数是奇数/偶数的方案数，转移比较简单，只要枚举下一个选不选（如果是棋子的话）然后更新一下奇数偶数和矩形个数就可以转移了。 总时间复杂度$O(2^nn^2m^2)$ 据说有$O(2^nnm)$的做法然而并不会 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) (x &amp; (-x))// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n,m;char a[10][300];int Mp[300];int dp[2][7][65][3048][2];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m); for (register int i=1;i&lt;=n;i++) scanf("%s",a[i]+1); int ans=0,all=n*(m-1)+(n-1)*m,cur=0,nxt=1; dp[cur][1][0][0][0]=1; for (register int i=1;i&lt;=m;i++) &#123; for (register int j=1;j&lt;=n;j++) for (register int Mask=0;Mask&lt;=(1&lt;&lt;n)-1;Mask++) for (register int num=0;num&lt;=i*n*2;num++) for (register int op=0;op&lt;=1;op++) if (dp[cur][j][Mask][num][op]) &#123; // not choose int toMask=Mask;if (toMask&amp;(1&lt;&lt;(j-1))) toMask^=(1&lt;&lt;(j-1)); if (j!=n) Add(dp[cur][j+1][toMask][num][op],dp[cur][j][Mask][num][op]); else Add(dp[nxt][1][toMask][num][op],dp[cur][j][Mask][num][op]); // choose if (a[j][i]=='*') &#123; int toMask=Mask|(1&lt;&lt;(j-1)),tonum=num+4; if (i==1 || Mask&amp;(1&lt;&lt;(j-1))) tonum--; if (j==1 || Mask&amp;(1&lt;&lt;(j-2))) tonum--; if (i==m) tonum--; if (j==n) tonum--; if (j!=n) Add(dp[cur][j+1][toMask][tonum][(op+1)&amp;1],dp[cur][j][Mask][num][op]); else Add(dp[nxt][1][toMask][tonum][(op+1)&amp;1],dp[cur][j][Mask][num][op]); &#125; dp[cur][j][Mask][num][op]=0; &#125; cur^=1;nxt^=1; &#125; for (register int Mask=0;Mask&lt;=(1&lt;&lt;n)-1;Mask++) for (register int num=1;num&lt;=all;num++) &#123; if (dp[cur][1][Mask][num][0]) Sub(ans,1ll*all*quick_pow(num,MOD-2)%MOD*dp[cur][1][Mask][num][0]%MOD); if (dp[cur][1][Mask][num][1]) Add(ans,1ll*all*quick_pow(num,MOD-2)%MOD*dp[cur][1][Mask][num][1]%MOD); &#125; printf("%d\n",ans);#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>Min-Max容斥</category>
        <category>状压dp</category>
        <category>轮廓线dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Min-Max容斥</tag>
        <tag>UOJ</tag>
        <tag>集训队作业</tag>
        <tag>状压dp</tag>
        <tag>轮廓线dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #666E]Forensic Examination 题解]]></title>
    <url>%2Fblog%2Fcf666e%2F</url>
    <content type="text"><![CDATA[DescriptionThe country of Reberland is the archenemy of Berland. Recently the authorities of Berland arrested a Reberlandian spy who tried to bring the leaflets intended for agitational propaganda to Berland illegally. The most leaflets contain substrings of the Absolutely Inadmissible Swearword and maybe even the whole word. Berland legal system uses the difficult algorithm in order to determine the guilt of the spy. The main part of this algorithm is the following procedure. All the m leaflets that are brought by the spy are numbered from $1$ to $m$. After that it’s needed to get the answer to $q$ queries of the following kind: “In which leaflet in the segment of numbers $[l,r]$ the substring of the Absolutely Inadmissible Swearword $[pl,pr]$ occurs more often?”. The expert wants you to automate that procedure because this time texts of leaflets are too long. Help him! InputThe first line contains the string $s$ ($1 \leq \mid s\mid \leq 5\cdot 10^5$) — the Absolutely Inadmissible Swearword. The string $s$ consists of only lowercase English letters. The second line contains the only integer $m$ ($1 \leq m \leq 5\cdot 10^4$) — the number of texts of leaflets for expertise. Each of the next $m$ lines contains the only string $t_i$ — the text of the $i$-th leaflet. The sum of lengths of all leaflet texts doesn’t exceed $5\cdot 10^4$. The text of the leaflets consists of only lowercase English letters. The next line contains integer $q$ ($1 \leq q \leq 5\cdot 10^5$) — the number of queries for expertise. Finally, each of the last $q$ lines contains four integers $l$, $r$, $pl$, $pr$ ($1 \leq l \leq r \leq m$, $1 \leq pl \leq pr \leq \mid s\mid$), where $\mid s\mid$ is the length of the Absolutely Inadmissible Swearword. OutputPrint $q$ lines. The $i$-th of them should contain two integers — the number of the text with the most occurences and the number of occurences of the substring $[pl,pr]$ of the string $s$. If there are several text numbers print the smallest one. Examplesinput suffixtree 3 suffixtreesareawesome cartesiantreeisworsethansegmenttree nyeeheeheee 2 1 2 1 10 1 3 9 10 output 1 1 3 4 Solution没有怎么做过这种玩SAM的题目，感觉做的有些吃力（菜 这题的思路方向要对。我刚开始想的是用后缀数组做，这样最后会变成一个区间求众数的问题，貌似只能莫队?然而如果用SAM做就可以变成子树求众数的问题，可以用线段树来维护，具体如下： 我们考虑对所有的$T$建出广义SAM,这样对于$S$的一个子串，如果我已经知道了它对应SAM的哪个节点，那么我们只要将该节点对应的right集合找出来，然后在规定的区间内找最大数即可。 怎么获得每个节点的right集合呢？可以在SAM的parent树上的每一个点维护一棵权值线段树，就是对所有的$i$统计来自$t_i$的结束位置有多少个，搜索的过程中线段树合并，这样不仅求出了right集合，而且可以方便的求区间最值。 接下来只要考虑怎么快速对所有的$[pl,pr]$的询问找出在SAM上对应的点。考虑离线。我们抓着$S$在SAM上跑，就像匹配那样，如果当前字符的出边存在就沿着出边走，否则不停地跳father直到有出边为止。这样的方法能保证我们停留在SAM上匹配$S$后缀最长的节点，设这个节点为$cur$。走到$S$的第$i$位的时候我们处理所有$pr=i$的询问。我们发现我们只要在parent树上$root$到$cur$的链上找到那个对应长度正确的节点$x$，就是使得$pr-pl+1$落在$min_x$到$max_x$之间的那个节点即可。因为这条链上的点长度具有单调性，所以可以倍增（二分）来寻找这个点。 总时间复杂度$O(\mid S\mid log\mid S\mid)$，此处为了书写方便，认为所有变量同阶。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=5e5;int n,q;int Root[MAXN*2];char s[MAXN+48],t[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*20],rson[MAXN*20],maxn[MAXN*20],maxind[MAXN*20],tot; inline void init() &#123;tot=0;&#125; inline int Create() &#123;++tot;maxn[tot]=0;return tot;&#125; inline void pushup(int cur) &#123; if (!lson[cur]) &#123;maxn[cur]=maxn[rson[cur]];maxind[cur]=maxind[rson[cur]];return;&#125; if (!rson[cur]) &#123;maxn[cur]=maxn[lson[cur]];maxind[cur]=maxind[lson[cur]];return;&#125; if (maxn[rson[cur]]&gt;maxn[lson[cur]]) maxn[cur]=maxn[rson[cur]],maxind[cur]=maxind[rson[cur]]; else maxn[cur]=maxn[lson[cur]],maxind[cur]=maxind[lson[cur]]; &#125; inline void insert(int &amp;cur,int pos,int l,int r) &#123; if (!cur) cur=Create(); if (l==r) &#123;maxn[cur]=1;maxind[cur]=l;return;&#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(lson[cur],pos,l,mid); else insert(rson[cur],pos,mid+1,r); pushup(cur); &#125; inline int merge(int root1,int root2,int l,int r) &#123; if (!root1 || !root2) return root1^root2; if (l==r) &#123;maxn[root1]+=maxn[root2];return root1;&#125; int mid=(l+r)&gt;&gt;1; lson[root1]=merge(lson[root1],lson[root2],l,mid); rson[root1]=merge(rson[root1],rson[root2],mid+1,r); pushup(root1);return root1; &#125; inline Pair query(int cur,int left,int right,int l,int r) &#123; if (!cur) return mp(-1,-1); if (left&lt;=l &amp;&amp; r&lt;=right) return mp(maxn[cur],maxind[cur]); int mid=(l+r)&gt;&gt;1;Pair res=mp(-1,-1); if (left&lt;=mid) &#123; Pair tmp=query(lson[cur],left,right,l,mid); if (tmp.x&gt;res.x || (tmp.x==res.x &amp;&amp; tmp.y&lt;res.y)) res=tmp; &#125; if (mid+1&lt;=right) &#123; Pair tmp=query(rson[cur],left,right,mid+1,r); if (tmp.x&gt;res.x || (tmp.x==res.x &amp;&amp; tmp.y&lt;res.y)) res=tmp; &#125; return res; &#125;&#125;struct Query&#123; int l,r,pl,pr,ind; inline void input() &#123;scanf("%d%d%d%d",&amp;l,&amp;r,&amp;pl,&amp;pr);&#125;&#125;a[MAXN+48];vector&lt;Query&gt; seq[MAXN+48];Pair ans[MAXN+48];namespace SAM&#123; int par[MAXN*2],nxt[MAXN*2][27],maxn[MAXN*2],root,last,tot; vector&lt;int&gt; v[MAXN*2];int anc[MAXN*2][21]; vector&lt;Query&gt; Q[MAXN*2]; inline void init() &#123;root=tot=last=1;&#125; inline void extend(char ch,int ind) &#123; int p=last,np=++tot,w=ch-'a'+1;maxn[np]=maxn[p]+1; SegmentTree::insert(Root[np],ind,1,n); while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w];if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=++tot;maxn[nq]=maxn[p]+1;memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[q]=nq;par[np]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline void insert(char s[],int ind) &#123; last=root;int len=strlen(s+1); for (register int i=1;i&lt;=len;i++) extend(s[i],ind); &#125; inline void build() &#123;for (register int i=2;i&lt;=tot;i++) v[par[i]].pb(i);&#125; inline void dfs(int cur,int father) &#123; for (auto y : v[cur]) &#123; anc[y][0]=cur; for (register int i=1;i&lt;=20;i++) anc[y][i]=anc[anc[y][i-1]][i-1]; dfs(y,cur); &#125; &#125; inline int jump(int u,int len) &#123; for (register int i=20;i&gt;=0;i--) &#123; int tmp=anc[u][i]; if (maxn[tmp]&gt;=len) u=tmp; &#125; return u; &#125; inline void go() &#123; int len=strlen(s+1),cur=root,cnt=0; for (register int i=1;i&lt;=len;i++) &#123; int w=s[i]-'a'+1; while (cur &amp;&amp; !nxt[cur][w]) cur=par[cur],cnt=maxn[cur]; if (!cur) cur=root,cnt=0; else cur=nxt[cur][w],cnt++; for (auto item : seq[i]) &#123; int L=item.pr-item.pl+1; if (L&gt;cnt) &#123;ans[item.ind]=mp(0,item.l);continue;&#125; int pt=jump(cur,L);Q[pt].pb(item); &#125; &#125; &#125; inline void solve(int cur,int father) &#123; for (auto y : v[cur]) &#123; solve(y,cur); Root[cur]=SegmentTree::merge(Root[cur],Root[y],1,n); &#125; for (auto item : Q[cur]) &#123; Pair res=SegmentTree::query(Root[cur],item.l,item.r,1,n); if (res.x==-1) ans[item.ind]=mp(0,item.l); else ans[item.ind]=res; &#125; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%s",s+1);SAM::init();SegmentTree::init(); scanf("%d",&amp;n);for (register int i=1;i&lt;=n;i++) scanf("%s",t+1),SAM::insert(t,i); scanf("%d",&amp;q);for (register int i=1;i&lt;=q;i++) a[i].input(),a[i].ind=i,seq[a[i].pr].pb(a[i]); SAM::build();SAM::dfs(SAM::root,-1);SAM::go();SAM::solve(SAM::root,-1); for (register int i=1;i&lt;=q;i++) printf("%d %d\n",ans[i].y,ans[i].x); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>倍增</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>倍增</tag>
        <tag>线段树合并</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #207]共价大爷游长沙 题解]]></title>
    <url>%2Fblog%2Fuoj207%2F</url>
    <content type="text"><![CDATA[Description火车司机出秦川，跳蚤国王下江南，共价大爷游长沙。每个周末，勤劳的共价大爷都会开车游历长沙市。 长沙市的交通线路可以抽象成为一个 $n$ 个点 $n−1$ 条边的无向图，点编号为 $1$ 到 $n$，任意两点间均存在恰好一条路径，显然两个点之间最多也只会有一条边相连。有一个包含一些点对 $(x,y)$ 的可重集合$S$，共价大爷的旅行路线是这样确定的：每次他会选择 $S$ 中的某一对点 $(x,y)$，并从 $x$ 出发沿着唯一路径到达 $y$。 小L是共价大爷的脑残粉，为了见到共价大爷的尊容，小L决定守在这张图的某条边上等待共价大爷的到来。为了保证一定能见到他，显然小L必须选择共价大爷一定会经过的边——也就是所有共价大爷可能选择的路径都经过的边。 现在小L想知道，如果他守在某一条边，是否一定能见到共价大爷。 然而长沙市总是不断的施工，也就是说，可能某个时刻某条边会断开，同时这个时刻一定也有某条新边会出现，且任意时刻图都满足任意两点间均存在恰好一条路径的条件。注意断开的边有可能和加入的新边连接着相同的两个端点。共价大爷的兴趣也会不断变化，所以S也会不断加入新点对或者删除原有的点对。当然，小L也有可能在任何时候向你提出守在某一条边是否一定能见到共价大爷的问题。你能回答小L的所有问题吗？ Input Format输入的第一行包含一个整数 $id$，表示测试数据编号，如第一组数据的$id=1$，样例数据的 $id$ 可以忽略。hack数据中的 $id$必须为 $0$ 到 $10$ 之间的整数。hack数据中$id$的值和数据类型没有任何关系。 输入的第二行包含两个整数 $n$,$m$，分别表示图中的点数，以及接下来会发生的事件数，事件的定义下文中会有描述。初始时 $S$ 为空。 接下来 $n−1$ 行，每行两个正整数 $x$,$y$，表示点 $x$ 和点 $y$ 之间有一条无向边。 接下来 $m$ 行，每行描述一个事件，每行的第一个数 $type$ 表示事件的类型。 若$type=1$，那么接下来有四个正整数$x$,$y$,$u$,$v$，表示先删除连接点$x$和点$y$的无向边，保证存在这样的无向边，然后加入一条连接点$u$和点$v$的无向边，保证操作后的图仍然满足题中所述条件。 若$type=2$，那么接下来有两个正整数 $x$,$y$，表示在 $S$ 中加入点对 $(x,y)$。 若$type=3$，那么接下来有一个正整数 $x$，表示删除第 $x$ 个加入 $S$ 中的点对，即在第 $x$ 个 $type=2$ 的事件中加入 $S$ 中的点对，保证这个点对存在且仍然在 $S$ 中。 若 $type=4$，那么接下来有两个正整数 $x$,$y$，表示小L询问守在连接点 $x$ 和点 $y$ 的边上是否一定能见到共价大爷，保证存在这样的无向边且此时 $S$ 不为空。输出格式 对于每个小L的询问，输出“YES”或者“NO”（均不含引号）表示小L一定能或者不一定能见到共价大爷。 Sample Input0 5 7 1 2 1 3 2 4 1 5 2 1 5 1 1 5 2 5 4 2 5 2 1 4 4 2 5 3 1 4 2 4 Sample OutputYES NO YES Explanation最开始将点对 $(1,5)$ 加入到 $S$ 中，此时点 $1$ 和点 $5$ 之间的路径是 $1\rightarrow 5$。 接着将连接点 $1$ 和点 $5$ 的边断开，加入连接点 $2$ 和点 $5$ 的边，我们发现图仍然满足题中所述条件，且点 $1$ 和点 $5$ 之间的路径是 $1\rightarrow 2\rightarrow 5$，经过点了 $2$ 和点 $5$ 之间的边，因此第一个询问答案是 YES。 接着将点对 $(1,4)$ 加入到 $S$ 中，点 $1$ 和点 $4$ 之间的路径是 $1\rightarrow 2\rightarrow 4$，没有经过点 $2$ 和点 $5$ 之间的边，因此第二个询问答案是 NO。 接着，我们删除了第一个加入到 $S$ 中的点对，也就是点对 $(1,5)$，此时 $S$ 中唯一的点对就是 $(1,4)$，经过了点 $2$ 和点 $4$ 之间的边，因此最后一个询问答案是 YES。 Solution既然要切边和加边，自然想到用LCT来维护。 但是我们显然不能将信息保存在每一条边上，因为随着树的结构的修改，两个节点之间的路径会不断变化，这个是不好维护的。 考虑某一条路径经过某条边的充要条件，就是这条路径的两个端点分别位于这条边两边的子树内。 于是可以想到一个基于随机的算法：我们给每条路径随机一个权值，把这个权值打在两个端点上，这样我们在查询一条边的时候只要查这条边的端点的子树的异或和是否等于当前存在的所有路径的权值异或和即可。（因为如果某条路径的两个端点在同一边，它的权值就会抵消） 于是只要在LCT上维护子树异或和即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3e5;int n,m;vector&lt;pair&lt;Pair,int&gt; &gt; S;int xorsum=0;namespace LCT&#123; struct node &#123; int ch[2],flip; int father,sum,val,vsum; inline void clear() &#123; ch[0]=ch[1]=flip=0; father=0;sum=val=vsum=0; &#125; &#125;tree[MAXN+48]; inline void init() &#123; for (register int i=1;i&lt;=n;i++) tree[i].clear(); &#125; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].ch[0]].flip^=1; tree[tree[cur].ch[1]].flip^=1; swap(tree[cur].ch[0],tree[cur].ch[1]); tree[cur].flip=0; &#125; &#125; inline void pushup(int cur) &#123; tree[cur].sum=tree[tree[cur].ch[0]].sum^tree[tree[cur].ch[1]].sum^tree[cur].vsum^tree[cur].val; &#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; pushdown(y);pushdown(x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; int k=(tree[y].ch[1]==x); tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; pushdown(x); while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].vsum^=tree[tree[cur].ch[1]].sum; tree[cur].vsum^=tree[pre].sum; tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void makeroot(int x) &#123; access(x);splay(x);tree[x].flip^=1; &#125; inline void link(int x,int y) &#123; makeroot(x);makeroot(y); tree[x].father=y;tree[y].vsum^=tree[x].sum;pushup(y); &#125; inline void cut(int x,int y) &#123; makeroot(x);access(y);splay(y); tree[x].father=0;tree[y].ch[0]=0;pushup(y); &#125; inline void modify(int x,int y) &#123; makeroot(x);tree[x].val^=y; pushup(x); &#125; inline int query(int x) &#123; access(x);splay(x); return tree[x].vsum^tree[x].val^tree[tree[x].ch[1]].sum; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif srand(time(NULL)); scanf("%d",&amp;n);scanf("%d%d",&amp;n,&amp;m);int type,x,y,u,v; LCT::init(); for (register int i=1;i&lt;=n-1;i++) &#123; scanf("%d%d",&amp;x,&amp;y); LCT::link(x,y); &#125; while (m--) &#123; scanf("%d",&amp;type); if (type==1) &#123; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;u,&amp;v); LCT::cut(x,y);LCT::link(u,v); &#125; else if (type==2) &#123; scanf("%d%d",&amp;x,&amp;y); int tmp=rand();xorsum^=tmp;S.pb(mp(mp(x,y),tmp)); LCT::modify(x,tmp);LCT::modify(y,tmp); &#125; else if (type==3) &#123; scanf("%d",&amp;u); x=S[u-1].x.x;y=S[u-1].x.y;int tmp=S[u-1].y; xorsum^=tmp;LCT::modify(x,tmp);LCT::modify(y,tmp); &#125; else &#123; scanf("%d%d",&amp;x,&amp;y); LCT::makeroot(x);LCT::makeroot(y); int tmp=LCT::query(x); if (tmp==xorsum) puts("YES"); else puts("NO"); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>LCT</category>
        <category>随机</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>LCT</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #347][Jiangsu Training Contest #8]计数题 题解]]></title>
    <url>%2Fblog%2Fnflsoj347%2F</url>
    <content type="text"><![CDATA[Description给大家做一道计数题。 现在有 $n$（$n\leq 50$） 种面值的货币，第 $i$ 种面值是 $s_i$（$s_i\leq 500$）。保证任意两种面值都不同，即当 $i\neq j$ 时 $s_i\neq s_j$。 如果每种面值的货币你都有足够多张，问有多少种方案拼出总面值 $C$（$C\leq 10^{100}$）。两种方案不同当且仅当某一种面值的货币的数量不同。输出答案模 $10^9+7$ 的结果。 Input Format第一行两个正整数 $n$,$C$，分别表示货币面值的种数和你需要拼的面值。 第二行 $n$ 个正整数 $s_i$。 Output Format输出一行答案，模 $10^9+7$。 Sample Input 12 10 3 7 Sample Output 11 Sample Input 23 10 3 4 7 Sample Output 22 Constraints对于 $10\%$ 的数据，$n\leq 5，C\leq 100$； 对于另 $10\%$ 的数据，$C\leq 10^5$； 对于另 $10\%$ 的数据，$C\leq 10^9$； 对于另 $20\%$ 的数据，$C\leq 10^{18}$； 对于另 $10\%$ 的数据，$n=2$； 对于另 $10\%$ 的数据，$n=3$； 对于 $100\%$ 的数据，$1\leq n\leq 50$，$1\leq s_i\leq 500$，$C\leq 10^{100}$。 Solution对于前$20$分，就是一个比较简单的完全背包，做到$O(nC)$的复杂度是不困难的。 满分的做法比较神奇。 原题相当于求方程$\sum_{i=1}^ns_ix_i=C$的解的个数。 我们把$C$转成二进制数，把所有的$x_i$也看做二进制数，从高位到低位逐位确定二进制位。 令$dp[i][j][k]$表示当前从高位到低位考虑到表示$2^i$的那一位，当前考虑到第$j$个数，$\frac{C-\sum_{i=1}^ns_ix_i}{2^i}=k$的方案数。$k$那一维定义得比较拗口，通俗来讲就是刚开始所有的$x_i$都是$0$，$C$也是$0$，然后从高位到低位一位位添加$C$的二进制位，然后更新已经添加的这些位中，现在还剩余的$C$是$2^i$的多少倍（显然是整数倍）。 根据$\sum_{i=0}^{n}2^i&lt;2^{n+1}$可知，如果$2\times \sum_{i=1}^ns_i&lt;k$,这个状态是无效的。所以$k$这一维最大是$\sum s_i$级别的。 每一层的转移就是普通的背包转移，从$i$到$i-1$的时候，当前的$2^i$可以变成$2\times 2^{i-1}$，相当于$k\times 2$，再更新上下一位$C$的取值，就可以转移了。 本质上相当于做一个二进制的背包。总时间复杂度$O(n^2\sum s_ilogC)$ 讲的不是很清楚，看代码吧 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n;char s[548];int a[148],bit[1048],tot;inline void TEN_TO_TWO()&#123; int len=strlen(s+1); for (register int i=1;i&lt;=len;i++) s[i]-='0'; reverse(s+1,s+len+1);tot=0; while (len) &#123; bit[++tot]=(s[1]&amp;1); for (register int i=len;i&gt;=1;i--) &#123; if (s[i]&amp;1 &amp;&amp; i&gt;1) s[i-1]+=10; s[i]/=2; &#125; while (len &amp;&amp; s[len]==0) len--; &#125;&#125;int dp[2][58][60048];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%s",&amp;n,s+1);int sum=0; for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),sum+=a[i]; TEN_TO_TWO();int cur=0,nxt=1;dp[cur][0][1]=1; for (register int i=tot;i&gt;=1;i--,cur^=1,nxt^=1) &#123; memset(dp[nxt],0,sizeof(dp[nxt])); for (register int j=0;j&lt;=n-1;j++) for (register int k=0;k&lt;=2*sum;k++) if (dp[cur][j][k]) &#123; Add(dp[cur][j+1][k],dp[cur][j][k]); if (k-a[j+1]&gt;=0) Add(dp[cur][j+1][k-a[j+1]],dp[cur][j][k]); &#125; for (register int k=0;k*2+bit[i-1]&lt;=2*sum;k++) if (dp[cur][n][k]) Add(dp[nxt][0][k*2+bit[i-1]],dp[cur][n][k]); &#125; printf("%d\n",dp[cur][0][0]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>背包</category>
        <category>二进制拆分</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NFLSoj</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #346][Jiangsu Training Contest #8]01串 题解]]></title>
    <url>%2Fblog%2Fnflsoj346%2F</url>
    <content type="text"><![CDATA[Description给定 $S$ 和 $T$，它们都是仅包含字母 $A$ 和 $B$ 的字符串。 $A$ 和 $B$ 是两个仅包含数字 $0$ 和 $1$ 的非空字符串。现在，将 $S$ 和 $T$ 中的字母 $A$ 都替换成字符串 $A$，字母 $B$ 都替换成字符串 $B$，如果替换完成后，$S$ 和 $T$ 相同，那么就称这是一个完美的替换。问有多少组字符串是完美的替换，且满足 $A$ 和 $B$ 的长度都小于等于 $n$。两组字符串 $(A,B)$ 和 $(A’,B’)$ 不同当且仅当 $A\neq A’$ 或 $B\neq B’$。$S$ 和 $T$ 对应的完美替换的数量记作 $F(S,T)$。 例如当 $S=AAB$，$T=BB$ 时，$A=01$，$B=0101$ 时就是一个完美的替换，因为替换完成后 $S=T=010101$。 输入 $S’$,$T’$，$S’$ 和 $T’$ 中仅包含字母 $A$，$B$ 和 $?$。将每个问号都替换成 $A$ 或 $B$ 后你会得到 $2^t$ 个 $S$ 和 $T$ 的组合（其中 $t$ 是问号的数量），问这些 $S$ 和 $T$ 的组合的 $F$ 的和。输出答案模 $10^9+7$。 Input Format第一行一个字符串 $S’$。 第二行一个字符串 $T’$。 第三行一个正整数 $n$。 Output Format输出一行答案。 Sample Input 1A B 10 Sample Output 12046 Sample Input 2A? ? 3 Sample Output 22 Constraints 对于 $100\%$ 的数据，$1\leq n,\mid S’\mid ,\mid T’\mid \leq 3\times 10^5$。 Solution伪装成字符串题的数学题（大雾 如果$S=T$,那么$A$,$B$取任意字符串都可行，简单计算即可。当$S$和$T$中有问号的时候，统计使得$S=T$的方案，这部分比较简单。 当$S\neq T$时，有一个结论，$A+B=B+A$，即$A$和$B$都有长度为$gcd(A,B)$的循环节，证明先鸽着 既然有$A+B=B+A$,我们就可以把$S$和$T$都变成前面全是$A$，后面全是$B$的形式，这样答案就只和$S$和$T$中$A$,$B$的个数有关了。 设最后$S$中$A$的个数为$a$,$B$的个数为$b$,$T$中$A$的个数为$c$,$B$的个数为$d$,有以下情况： $(a-c)(b-d)\geq 0$且$a=c,b=d$不同时成立，此时必然无解，方案数为$0$。 $(a-c)(b-d)&lt;0$，此时要使得$S$和$T$的长度相等，必然有$(a-c)\mid A\mid = (b-d)\mid B\mid$，如果$gcd(a-c,b-d)\neq 1$就除一下。考虑之前的结论，我们可以设$A=(b-d)X$，$B=(a-c)X$，其中字符串$X$可以任取。注意到$A$和$B$长度不超过$n$的限制，我们的答案应该是$$\sum_{i=1}^{\frac{n}{max{a-c,b-d}}}2^i=2^{(\frac{n}{max{a-c,b-d}}+1)}-2$$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这个式子可以$O(1)$计算。 $a=c$且$b=d$，此时我们只要满足$A+B=B+A$即可，只要考虑长度$n$的限制。根据之前的结论，只要保证长度为$gcd(\mid A\mid ,\mid B\mid)$的循环节即可，循环节可以任选。我们的答案应该是$$\sum_{i=1}^n\sum_{j=1}^n2^{gcd(i,j)}$$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这是一个比较套路的式子，枚举gcd，我们有$$\sum_{g=1}^n2^g\sum_{i=1}^{\left \lfloor \frac{n}{g} \right \rfloor}\sum_{j=1}^{\left \lfloor \frac{n}{g} \right \rfloor}[gcd(i,j)=1]$$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 根据恒等式$$\sum_{d\mid n}\mu(d)=[d=1]$$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以将原式改写为$$\sum_{g=1}^n2^g\sum_{d=1}^n\mu(d)\sum_{i=1}^{\left \lfloor \frac{n}{gd} \right \rfloor}\sum_{j=1}^{\left \lfloor \frac{n}{gd} \right \rfloor}1=\sum_{g=1}^n2^g\sum_{d=1}^n\mu(d) \left \lfloor \frac{n}{gd} \right \rfloor^2$$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 根据调和级数，算这个式子的复杂度是$O(nlogn)$ 最后我们只要处理问号的问题就可以了。如果我们暴力枚举$S$中有多少个问号变成$A$，$T$中有多少个问号变成$A$，再来计算两者$A$的差值，可以得到一个$O(\mid S\mid \mid T\mid)$的算法。 但我们注意到我们至始至终只关注$S$和$T$中$A$的个数的差值，所以我们只要枚举$S$中变成$A$的问号个数比$T$中变成$A$的问号个数多多少，然后计算即可。 至于乘多少系数，只要用一点点组合知识。假设$S$中有$s$个问号，$T$中有$t$个问号，则$S$中变成$A$的问号个数比$T$中变成$A$的问号个数多$x$个的方案数应该是$$\sum_{i=1}^{min{s-x,t}}\binom{s}{i+x}\binom{t}{i}$$根据$\binom{n}{m}=\binom{n}{n-m}$，可以将原式化为$$\sum_{i=1}^{min{s-x,t}}\binom{s}{s-x-i}\binom{t}{i}$$ 这个可以看做要在$s+t$个物品中选出$s-x$个物品，我们枚举这$s-x$个物品中有多少个来自$t$，就有上面的式子，所以答案就是$\binom{s+t}{s-x}$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e6;char S[MAXN+48],T[MAXN+48];int len1,len2,n,s,t,cnta,cntb,cntc,cntd;int fac[MAXN+48],ifac[MAXN+48],pw[MAXN+48];int mu[MAXN+48],prime[MAXN+48],tot;bool isprime[MAXN+48];inline void init()&#123; fac[0]=1;for (register int i=1;i&lt;=MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD; pw[0]=1;for (register int i=1;i&lt;=MAXN;i++) pw[i]=add(pw[i-1]+pw[i-1]); memset(isprime,true,sizeof(isprime));tot=0;mu[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i,mu[i]=-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125; for (register int i=1;i&lt;=MAXN;i++) if (mu[i]&lt;0) mu[i]+=MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;y || x&lt;0) return 0; return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;&#125;int ans=0,valueg=0;inline void doit(int coef)&#123; valueg=0; for (register int g=1;g&lt;=n;g++) &#123; int curans=0; for (register int d=1;d*g&lt;=n;d++) Add(curans,1ll*(n/g/d)*(n/g/d)%MOD*mu[d]%MOD); Add(valueg,1ll*curans*pw[g]%MOD); &#125; Add(ans,1ll*valueg*coef%MOD);&#125;inline void doit2()&#123; int coef=1; for (register int i=1;i&lt;=len1;i++) &#123; if (S[i]!='?' &amp;&amp; T[i]!='?' &amp;&amp; S[i]!=T[i]) return; if (S[i]=='?' &amp;&amp; T[i]=='?') coef=1ll*coef*2%MOD; &#125; int sum=0; for (register int i=1;i&lt;=n;i++) Add(sum,pw[i]); sum=1ll*sum*sum%MOD; Add(ans,1ll*coef*sum%MOD); Sub(ans,1ll*coef*valueg);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%s%s%d",S+1,T+1,&amp;n);len1=strlen(S+1);len2=strlen(T+1);init(); s=cnta=cntb=0;for (register int i=1;i&lt;=len1;i++) s+=(S[i]=='?'),cnta+=(S[i]=='A'),cntb+=(S[i]=='B'); t=cntc=cntd=0;for (register int i=1;i&lt;=len2;i++) t+=(T[i]=='?'),cntc+=(T[i]=='A'),cntd+=(T[i]=='B'); for (register int i=-t;i&lt;=s;i++) &#123; int delta1=cnta-cntc+i,delta2=cntb-cntd+(s-i-t); if (delta1==0 &amp;&amp; delta2==0) &#123;doit(C(s+t,s-i));continue;&#125; if (1ll*delta1*delta2&gt;=0) continue; int coef=C(s+t,s-i); delta1=(delta1&lt;0?-delta1:delta1);delta2=(delta2&lt;0?-delta2:delta2); int g=gcd(delta1,delta2);delta1/=g;delta2/=g; Add(ans,1ll*coef*(pw[n/max(delta1,delta2)+1]-2)%MOD); &#125; if (cnta+cntb+s==cntc+cntd+t) doit2(); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>莫比乌斯函数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>NFLSoj</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Regular Contest 059F]Unhappy Hacking 题解]]></title>
    <url>%2Fblog%2Farc059f%2F</url>
    <content type="text"><![CDATA[Problem StatementSig has built his own keyboard. Designed for ultimate simplicity, this keyboard only has $3$ keys on it: the $0$ key, the $1$ key and the backspace key. To begin with, he is using a plain text editor with this keyboard. This editor always displays one string (possibly empty). Just after the editor is launched, this string is empty. When each key on the keyboard is pressed, the following changes occur to the string: The $0$ key: a letter $0$ will be inserted to the right of the string. The $1$ key: a letter $1$ will be inserted to the right of the string. The backspace key: if the string is empty, nothing happens. Otherwise, the rightmost letter of the string is deleted. Sig has launched the editor, and pressed these keys $N$ times in total. As a result, the editor displays a string $s$. Find the number of such ways to press the keys, modulo $10^9+7$. Constraints $1\leq N\leq 5000$ $1\leq \mid s\mid \leq N$ $s$ consists of the letters $0$ and $1$. Partial Score $400$ points will be awarded for passing the test set satisfying $1\leq N\leq 300$. InputThe input is given from Standard Input in the following format: N s OutputPrint the number of the ways to press the keys $N$ times in total such that the editor displays the string $s$ in the end, modulo $10^9+7$. Sample Input 13 0 Sample Output 15 We will denote the backspace key by $B$. The following $5$ ways to press the keys will cause the editor to display the string $0$ in the end: $00B$, $01B$, $0B0$, $1B0$, $BB0$. In the last way, nothing will happen when the backspace key is pressed. Sample Input 2300 1100100 Sample Output 2519054663 Sample Input 35000 01000001011101000100001101101111011001000110010101110010000 Sample Output 3500886057 Solution这题思维还是挺神仙的。 我们可以发现一个重要的性质：其实给定的串$s$里面的内容是没有意义的，有意义的只有串的长度$n$。因为所有的$2^n$种串出现的方案数肯定是一样的。所以我们只要算出$N$次操作后长度为$n$的方案数，再除以$2^n$即可。 剩下的就是一个简单dp。令$dp[i][j]$表示考虑了前$i$次操作，当前的位数是$j$的方案数。转移非常简单，考虑下一次是加$0$，加$1$（这两种是等价的，都是使得$j+1$）还是删掉（注意$j-1$要和$0$取$max$）即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=5000;int n,len;char s[MAXN+48];int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%s",&amp;n,s+1);len=strlen(s+1); dp[0][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) if (dp[i][j]) &#123; Add(dp[i+1][max(j-1,0)],dp[i][j]); Add(dp[i+1][j+1],1ll*dp[i][j]*2%MOD); &#125; int inv=quick_pow(2,len);inv=quick_pow(inv,MOD-2); printf("%d\n",1ll*dp[n][len]*inv%MOD); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2537][PKUWC2018]Minimax 题解]]></title>
    <url>%2Fblog%2Floj2537%2F</url>
    <content type="text"><![CDATA[Description小 $C$ 有一棵 $n$ 个结点的有根树，根是 $1$ 号结点，且每个结点最多有两个子结点。 定义结点 $x$ 的权值为： 若 $x$ 没有子结点，那么它的权值会在输入里给出，保证这类点中每个结点的权值互不相同。 若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$ 的概率是它的子结点的权值的最小值。 现在小 $C$ 想知道，假设 $1$ 号结点的权值有 $m$ 种可能性，权值第 $i$ 小的可能性的权值是 $V_i$​，它的概率为 $D_i(D_i&gt;0)$，求： $$\sum_{i=1}^mi\cdot V_i\cdot D_i^2$$ 你需要输出答案对 $998244353$ 取模的值。 Input Format第一行一个正整数 $n$；第二行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个结点的父亲的编号，其中第 $1$ 个结点的父亲为 $0$；第三行 $n$ 个整数，若第 $i$ 个结点没有子结点，则第 $i$ 个数为它的权值，否则第 $i$ 个数为 $p_i\cdot 10000$，保证 $p_i\cdot 10000$ 是个正整数。 Output Format输出答案 Sample Input3 0 1 1 5000 1 2 Sample Output748683266 Explanation$1$号结点的权值有 $\frac{1}{2}$​ 的概率是 $1$，有 $\frac{1}{2}$​ 的概率是 $2$，所以答案是 $\frac{5}{4}$​。 Constraints对于 $10\%$ 的数据，有 $1\leq n\leq 20$ 对于 $20\%$ 的数据，有 $1\leq n\leq 400$ 对于 $40\%$ 的数据，有 $1\leq n\leq 5000$ 对于 $60\%$ 的数据，有 $1\leq n\leq 10^5$ 另有 $10\%$ 的数据保证树的形态随机。 对于 $100\%$ 的数据，有 $1\leq n \leq 3\times 10^5,1\leq W_i\leq 10^9$。 对于所有数据，满足 $0&lt; p_i\cdot 10000&lt;10000$，所以易证明所有叶子的权值都有概率被根取到。 Solution先考虑一个显然的dp 令$dp[i][j]$表示以$i$为根的子树，最后选上来的数是第$j$大的概率。 转移还是比较好转移的，因为是二叉树，所以只要维护$j$不在的那棵子树的概率的前缀和就可以转移了，复杂度是$O(n^2)$ 考虑怎么优化。先推一波式子。对于某棵子树的某个值$x$,令$Bx$表示它的兄弟子树中出现比他大的数的概率，那么$x$贡献到父亲的概率是$$(1-p)\cdot B_x+p\cdot (1-B_x)=B_x-2pB_x+p$$ 也就是说对于某一个点只要知道$B_x$就能算出它到了父亲时出现的概率。 考虑线段树合并，动态开点线段树的叶子就表示最后出现的权值是第$i$个的概率，同时维护乘法的懒标记。这样我们考虑在合并的过程中，如果一起合并左子树，那么第二棵树的右子树的和就会贡献第一棵树的左子树的$B_x$，类似的，第一棵树的右子树的和会贡献第二棵树的左子树的$B_x$。线段树merge的时候同步记录一个sum1和sum2来表示这个贡献。这样，如果碰到仅有root1的时候，就把sum2乘到root1的懒标记上，同理，仅有root2的时候把sum1乘到root2的懒标记上。 这样总复杂度只有线段树合并的复杂度，为$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3e5;const int lim=MAXN;int n;vector&lt;int&gt; v[MAXN+48];int Inv,p[MAXN+48],ans;int vv[MAXN+48],vtot;int table[MAXN+48];int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*30+48],rson[MAXN*30+48],sum[MAXN*30+48],lazy[MAXN*30+48],tot; inline int Create() &#123; ++tot;lson[tot]=rson[tot]=0; sum[tot]=0;lazy[tot]=1; return tot; &#125; inline void pushdown(int cur) &#123; if (lazy[cur]!=1) &#123; lazy[lson[cur]]=1ll*lazy[lson[cur]]*lazy[cur]%MOD;sum[lson[cur]]=1ll*sum[lson[cur]]*lazy[cur]%MOD; lazy[rson[cur]]=1ll*lazy[rson[cur]]*lazy[cur]%MOD;sum[rson[cur]]=1ll*sum[rson[cur]]*lazy[cur]%MOD; lazy[cur]=1; &#125; &#125; inline void pushup(int cur) &#123; sum[cur]=0; if (lson[cur]) Add(sum[cur],sum[lson[cur]]); if (rson[cur]) Add(sum[cur],sum[rson[cur]]); &#125; inline void insert(int &amp;cur,int pos,int val,int l,int r) &#123; if (!cur) cur=Create(); if (l==r) &#123;sum[cur]=val;lazy[cur]=1;return;&#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) insert(lson[cur],pos,val,l,mid); else insert(rson[cur],pos,val,mid+1,r); pushup(cur); &#125; inline int merge(int root1,int root2,int sum1,int sum2,int p,int l,int r) &#123; if (!root1 &amp;&amp; !root2) return 0; if (!root2) &#123; lazy[root1]=1ll*lazy[root1]*add(sub(sum2-2ll*p*sum2%MOD)+p)%MOD; sum[root1]=1ll*sum[root1]*add(sub(sum2-2ll*p*sum2%MOD)+p)%MOD; return root1; &#125; if (!root1) &#123; lazy[root2]=1ll*lazy[root2]*add(sub(sum1-2ll*p*sum1%MOD)+p)%MOD; sum[root2]=1ll*sum[root2]*add(sub(sum1-2ll*p*sum1%MOD)+p)%MOD; return root2; &#125; pushdown(root1);pushdown(root2); int mid=(l+r)&gt;&gt;1; lson[root1]=merge(lson[root1],lson[root2],add(sum1+(rson[root1]?sum[rson[root1]]:0)),add(sum2+(rson[root2]?sum[rson[root2]]:0)),p,l,mid); rson[root1]=merge(rson[root1],rson[root2],sum1,sum2,p,mid+1,r); pushup(root1);return root1; &#125; int cnt=0; inline void solve(int cur,int l,int r) &#123; if (!cur) return; if (l==r) &#123; cnt++;Add(ans,1ll*cnt*table[l]%MOD*sum[cur]%MOD*sum[cur]%MOD); return; &#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; solve(lson[cur],l,mid);solve(rson[cur],mid+1,r); &#125;&#125;inline void dfs(int cur)&#123; if (!int(v[cur].size())) root[cur]=SegmentTree::Create(),SegmentTree::insert(root[cur],p[cur],1,1,lim); if (int(v[cur].size())==1) dfs(v[cur][0]),root[cur]=root[v[cur][0]]; if (int(v[cur].size())==2) &#123; int y1=v[cur][0],y2=v[cur][1]; dfs(y1);dfs(y2); root[cur]=SegmentTree::merge(root[y1],root[y2],0,0,p[cur],1,lim); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);int x; for (register int i=1;i&lt;=n;i++) io.Get(x),v[x].pb(i); Inv=quick_pow(10000,MOD-2); for (register int i=1;i&lt;=n;i++) &#123; io.Get(p[i]); if (int(v[i].size())) assert(p[i]&lt;=10000),p[i]=1ll*p[i]*Inv%MOD; else vv[++vtot]=p[i]; &#125; sort(vv+1,vv+vtot+1); for (register int i=1;i&lt;=n;i++) if (!int(v[i].size())) &#123; int tmp=lower_bound(vv+1,vv+vtot+1,p[i])-vv; table[tmp]=p[i];p[i]=tmp; &#125; dfs(1);SegmentTree::solve(root[1],1,lim); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线段树合并</tag>
        <tag>LOJ</tag>
        <tag>PKUWC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029A]Irreversible operation 题解]]></title>
    <url>%2Fblog%2Fagc029a%2F</url>
    <content type="text"><![CDATA[Problem StatementThere are $N$ Reversi pieces arranged in a row. (A Reversi piece is a disc with a black side and a white side.) The state of each piece is represented by a string $S$ of length $N$. If $S_i=$’B‘, the $i$-th piece from the left isshowing black; If $S_i=$’W‘, the $i$-th piece from the left is showing white. Consider performing the following operation: Choose $i$ $(1\leq i&lt;N)$ such that the $i$-th piece from the left is showing black and the $(i+1)$-th piece from the left is showing white, then flip both of those pieces. That is, the $i$-th piece from the left is now showing white and the $(i+1)$-th piece from the left is now showing black. Find the maximum possible number of times this operation can be performed. Constraints $1\leq \mid S\mid \leq 2\times 10^5$ $S_i=$’B‘ or ‘W‘ InputInput is given from Standard Input in the following format: S OutputPrint the maximum possible number of times the operation can be performed. Sample Input 1BBW Sample Output 12 The operation can be performed twice, as follows: Flip the second and third pieces from the left. Flip the first and second pieces from the left. Sample Input 2BWBWBW Sample Output 26 Solution我们尝试考虑当没有操作能做的时候，整个序列长什么样子。我们发现一定是所有的W在左边，所有的R在右边，否则一定会出现RW的结构。 接而我们发现每次交换一个RW就将一个在某个W之前的某个R换到后面，也就是说，对于每一个R,它要和它后面的每一个W做一次交换。 于是只要算每个R后面有多少个W即可。或者换一个角度，你可以把R和W想象成1和0,然后类似冒泡排序，需要的就是逆序对个数次交换。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;char s[MAXN+48];int n;LL ans;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); for (register int i=n,cnt=0;i&gt;=1;i--) if (s[i]=='W') cnt++; else ans+=cnt; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029B]Powers of Two 题解]]></title>
    <url>%2Fblog%2Fagc029b%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi has $N$ balls with positive integers written on them. The integer written on the $i$-th ball is $A_i$. He would like to form some number of pairs such that the sum of the integers written on each pair of balls is a power of $2$. Note that a ball cannot belong to multiple pairs. Find the maximum possible number of pairs that can be formed. Here, a positive integer is said to be a power of $2$ when it can be written as $2^t$ using some non-negative integer $t$. Constraints $1\leq N\leq 2\times 10^5$ $1\leq A_i\leq 10^9$ $A_i$ is an integer. InputInput is given from Standard Input in the following format: N A1 A2 ... An OutputPrint the maximum possible number of pairs such that the sum of the integers written on each pair of balls is a power of $2$. Sample Input 13 1 2 3 Sample Output 11 We can form one pair whose sum of the written numbers is $4$ by pairing the first and third balls. Note that we cannot pair the second ball with itself. Sample Input 25 3 11 14 5 13 Sample Output 22 Solution个人认为这题甚至比当场的E还难（大雾 看上去很像一道贪心题，但不知道该怎么做。 通过奇怪的尝试，发现从大到小给每个数匹配就是对的 还是来简单证明一下正确性，尝试考虑这个2的次幂到底提供了什么性质。我们发现，能与某个数值匹配的所有数值中，只有一个比它小，所以，我们如果对于所有能匹配的数对，从大的向小的连边，那么会形成一个树的结构。原题即要求我们将这棵树划分成尽量多的不相交的二元组。对于这个问题，还是能比较显然的看出肯定是从叶子开始贪心比较优，也就是把所有的数按从大到小的顺序来匹配。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;multiset&lt;int&gt; s;LL pw[48];int a[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int n,x;scanf("%d",&amp;n); for (register int i=1;i&lt;=n;i++) scanf("%d",&amp;x),s.insert(x);int cnt=1; for (multiset&lt;int&gt;::iterator iter=s.begin();iter!=s.end();iter++,cnt++) a[cnt]=(*iter); pw[0]=1;for (register int i=1;i&lt;=41;i++) pw[i]=pw[i-1]+pw[i-1]; int ans=0; for (register int i=n;i&gt;=1;i--) &#123; if (s.find(a[i])==s.end()) continue; multiset&lt;int&gt;::iterator iter=s.find(a[i]);s.erase(iter); int pt=31;while (a[i]+a[i]&lt;pw[pt] &amp;&amp; pt) pt--; for (register int j=pt;j&gt;=1;j--) &#123; int need=pw[j]-a[i]; if (s.find(need)!=s.end()) &#123; iter=s.find(need);s.erase(iter); ++ans;break; &#125; &#125; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029C]Lexicographic constraints 题解]]></title>
    <url>%2Fblog%2Fagc029c%2F</url>
    <content type="text"><![CDATA[Problem StatementThere are $N$ strings arranged in a row. It is known that, for any two adjacent strings, the string to the left is lexicographically smaller than the string to the right. That is, $S_1&lt;S_2&lt;…&lt;S_N$ holds lexicographically, where $S_i$ is the $i$-th string from the left. At least how many different characters are contained in $S_1,S_2,…,S_N$, if the length of $S_i$ is known to be $A_i$? Constraints $1\leq N\leq 2\times 10^5$ $1\leq A_i\leq 10^9$ $A_i$ is an integer. NoteThe strings do not necessarily consist of English alphabet; there can be arbitrarily many different characters (and the lexicographic order is defined for those characters). InputInput is given from Standard Input in the following format: N A1 A2 .. An OutputPrint the minimum possible number of different characters contained in the strings. Sample Input 13 3 2 1 Sample Output 12 The number of different characters contained in $S_1,S_2,…,S_N$ would be $3$ when, for example, $S_1=$’abc‘,$S_2=$’bb‘ and $S_3=$’c‘. However, if we choose the strings properly, the number of different characters can be$2$. Sample Input 25 2 3 2 1 2 Sample Output 22 Solutions显然答案具有单调性，考虑二分答案。 接下来是怎么check，我们的目标是尽可能最小化每个串的字典序。每次考虑相邻的两个字符串，如果后一个比前一个长，那么只要copy前一个串并在后面添上一串最小字符即可。如果后一个比前一个短，那么就要将前一个长出来的部分先截掉copy过来，然后使得最后一个字符比上一个大一。那么如果上一个的最后字符已经是最大字符了呢？那么就使得倒数第二个字符大一，最后一个字符设为最小字符，以此类推。可以发现这个很像加法的进位。如果某一次进位的时候，我们“加爆了”，就是首位也要进位，那么说明答案不合法，要寻求更大的答案，否则就可以尝试更小的答案。 分析复杂度。如果我们暴力的维护进位的话，均摊到每次只会进位$O(1)$次，复杂度可以保证。因为数位个数可能达到1e9个而可能产生的进位数量是1e5级别，所以可以用map来维护当前有进位的那些位。加上二分答案的一个log,总时间复杂度$O(nlog^2n)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,a[MAXN+48];map&lt;int,int&gt; cur;int maxbit;inline bool addone(int pt,int N)&#123; while (pt&lt;=maxbit &amp;&amp; cur[pt]==N-1) cur[pt]=0,pt++; if (pt&gt;maxbit) return false; cur[pt]++;return true;&#125;inline bool check(int N)&#123; cur.clear(); if (N==1) &#123; for (register int i=2;i&lt;=n;i++) if (a[i]&lt;=a[i-1]) return false; return true; &#125; for (register int i=2;i&lt;=n;i++) &#123; if (a[i]&gt;a[i-1]) continue; int low=maxbit-a[i]+1; while (!cur.empty() &amp;&amp; cur.begin()-&gt;x&lt;low) cur.erase(cur.begin()); bool sta=addone(low,N);if (!sta) return false; &#125; return true;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n);for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),check_max(maxbit,a[i]); int l=1,r=n,mid,ans; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>思维</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029D]Grid game 题解]]></title>
    <url>%2Fblog%2Fagc029d%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi and Aoki will play a game using a grid with $H$ rows and $W$ columns of square cells. There are $N$ obstacles on this grid; the $i$-th obstacle is at $(X_i,Y_i)$. Here, we represent the cell at the $i$-th row and $j$-th column $(1\leq i\leq H,1\leq j\leq W)$ by$(i,j)$ . There is no obstacle at $(1,1)$, and there is a piece placed there at $(1,1)$. Starting from Takahashi, he and Aoki alternately perform one of the following actions: Move the piece to an adjacent cell. Here, let the position of the piece be $(x,y)$. Then Takahashi can only move the piece to $(x+1,y)$, and Aoki can only move the piece to $(x,y+1)$. If the destination cell does not exist or it is occupied by an obstacle, this action cannot be taken. Do not move the piece, and end his turn without affecting the grid. The game ends when the piece does not move twice in a row. Takahashi would like to perform as many actions (including not moving the piece) as possible before the game ends, while Aoki would like to perform as few actions as possible before the game ends. How many actions will Takahashi end up performing? Constraints $1\leq H,W\leq 2\times 10^5$ $0\leq N\leq 2\times 10^5$ $1\leq X_i\leq H$ $1\leq Y_i\leq W$ if $i\neq j,(X_i,Y_i)\neq (X_j,Y_j)$ $(X_i,Y_i)\neq (1,1)$ $X_i$ and $Y_i$ are integers. InputInput is given from Standard Input in the following format: H W N X1 Y1 . . . Xn Yn OutputPrint the number of actions Takahashi will end up performing. Sample Input 13 3 1 3 2 Sample Output 12 For example, the game proceeds as follows: Takahashi moves the piece to $(2,1)$. Aoki does not move the piece. Takahashi moves the piece to $(3,1)$. Aoki does not move the piece. Takahashi does not move the piece. Takahashi performs three actions in this case, but if both players play optimally, Takahashi will perform only two actions before the game ends. Sample Input 210 10 14 4 3 2 2 7 3 9 10 7 7 8 1 10 10 5 4 3 4 2 8 6 4 4 4 5 8 9 2 Sample Output 26 Sample Input 3100000 100000 0 Sample Output 3100000 Solution感觉这题放D有点水了。 首先一个显然的性质是只要A还有路可走，他就一定会把棋子向下移，否则只要B也停下来游戏就玩完了。 那么B就有选择是否在当前这一列结束游戏的权利。 直接模拟移动的过程，如果选择在当前列结束，就找一下这一列当前点下方最靠上的障碍物（包括地图的下边界）算一下步数，否则如果可以向右走的话就向右走。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int h,w,n;vector&lt;int&gt; v[MAXN+48];int pt[MAXN+48];map&lt;Pair,int&gt; Mp;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d%d",&amp;h,&amp;w,&amp;n);int ans=h,x,y; for (register int i=1;i&lt;=n;i++) scanf("%d%d",&amp;x,&amp;y),v[y].pb(x),Mp[mp(x,y)]=1; for (register int i=1;i&lt;=w;i++) sort(v[i].begin(),v[i].end()),pt[i]=0; x=1;y=1;int cnt=0; for (;;) &#123; // cerr&lt;&lt;"*"&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;cnt&lt;&lt;endl; while (pt[y]&lt;=int(v[y].size())-1 &amp;&amp; v[y][pt[y]]&lt;x) pt[y]++; int lim=(pt[y]&lt;=int(v[y].size())-1)?v[y][pt[y]]:h+1; check_min(ans,cnt+lim-x); if (lim==x+1) break;if (y==w) break; ++x;++cnt; if (Mp.find(mp(x,y+1))==Mp.end()) ++y; &#125; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029F]Construction of a tree 题解]]></title>
    <url>%2Fblog%2Fagc029f%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given $N−1$ subsets of ${1,2,3,…,N}$. Let the $i$-th set be $E_i$. Let us choose two distinct elements $u_i$ and $v_i$ from each set $E_i$, and consider a graph $T$ with $N$ vertices and $N−1$ edges, whose vertex set is ${1,2,3,…,N}$ and whose edge set is $(u_1,v_1),(u_2,v_2),…,(u_{N-1},v_{N-1})$. Determine if $T$ can be a tree by properly deciding $u_i$ and $v_i$. If it can,additionally find one instance of $(u_1,v_1),(u_2,v_2),…,(u_{N-1},v_{N-1})$ such that $T$ is actually a tree. Constraints $2\leq N\leq 10^5$ $E_i$ is a subset of ${1,2,3,…,N}$. $\mid E_i\mid \geq 2$ The sum of $\mid E_i\mid$ is at most $2\times 10^5$. InputInput is given from Standard Input in the following format: N c1 w(1,1) w(1,2) ... w(1,c1) . . cn-1 w(n-1,1) w(n-1,2) ... w(n-1,cn-1) Here, $c_i$ stands for the number of elements in $E_i$, and $w_{i,1}…w_{i,c_i}$ are the $c_i$ elements in $c_i$. Here, $2\leq c_i\leq N,1\leq w_{i,j}\leq N$, and $w_{i,j}\neq w_{i,k}(1\leq j&lt;k\leq c_i)$ hold. OutputIf $T$ cannot be a tree, print -1; otherwise, print the choices of $(u_i,v_i)$ that satisfy the condition, in the following format: u1 v1 u2 v2 . . un-1 vn-1 Sample Input 15 2 1 2 3 1 2 3 3 3 4 5 2 4 5 Sample Output 11 2 1 3 3 4 4 5 Sample Input 26 3 1 2 3 3 2 3 4 3 1 3 4 3 1 2 4 3 4 5 6 Sample Output 2-1 Sample Input 310 5 1 2 3 4 5 5 2 3 4 5 6 5 3 4 5 6 7 5 4 5 6 7 8 5 5 6 7 8 9 5 6 7 8 9 10 5 7 8 9 10 1 5 8 9 10 1 2 5 9 10 1 2 3 Sample Output 31 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 Solution膜了wxh的博客，并没有怎么搞懂，准备以后再填坑。 考虑到每条边都连接着一个父亲和儿子，而除了根节点每个节点都有且仅有一个父亲，我们不妨令所有的$u_i$为儿子，$v_i$为父亲，那么$u_i$一定是一个2~n的排列。我们可以先用最大流来判断一下是否能分配出一个排列，只要像二分图匹配那样建图即可。 如果能给出一个排列，考虑怎么构造答案。考虑如下贪心：刚开始我们已经确定了1，然后我们把所有包含1的集合加入一个队列，给这些点都认领$1$作为父亲。之后每次从队列中取出一个集合编号$i$，就把包含$u_i$的集合加入队列中。 这个贪心显然是对的。但wxh说初始的$u_i$的选择不会影响结果，如果有解就能构造出来，如果无解选择任意一组$u_i$均无解，这个就不懂了（菜的真实 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n;vector&lt;int&gt; a[MAXN+48];vector&lt;int&gt; v[MAXN+48];int u[MAXN+48];bool inq[MAXN+48];int head,tail,q[MAXN+48];int ans[MAXN+48];namespace flow&#123; int head[800048],cur[800048],to[800048],nxt[800048],f[800048],tot,t; inline void init() &#123;memset(head,0,sizeof(head));tot=1;&#125; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[800048],Head,Tail;int depth[800048]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; if (depth[t]==-1) return false; else return true; &#125; inline int dfs(int x,int maxf) &#123; if (x==t || !maxf) return maxf; int y,minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; &#125; if (ans&gt;=maxf) return ans; &#125; if (!ans) depth[x]=0; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n);int num,x; for (register int i=1;i&lt;=n-1;i++) &#123; scanf("%d",&amp;num); while (num--) &#123; scanf("%d",&amp;x); a[i].pb(x);v[x].pb(i); &#125; &#125; flow::init();flow::t=n+n+1; for (register int i=1;i&lt;=n-1;i++) flow::addedge(0,i,1); for (register int i=2;i&lt;=n;i++) flow::addedge(n+i,flow::t,1); for (register int i=1;i&lt;=n-1;i++) for (auto to : a[i]) if (to!=1) flow::addedge(i,n+to,1); int res=flow::dinic(); if (res!=n-1) &#123;puts("-1");return 0;&#125; for (register int i=1;i&lt;=n-1;i++) for (register int j=flow::head[i];j;j=flow::nxt[j]) &#123; int y=flow::to[j]; if (n+2&lt;=y &amp;&amp; y&lt;=n+n &amp;&amp; flow::f[j]==0) &#123;u[i]=y-n;break;&#125; &#125; memset(inq,false,sizeof(inq));head=1;tail=0; for (auto item : v[1]) q[++tail]=item,q[++tail]=1,inq[item]=true; while (head&lt;=tail) &#123; int cur=q[head++],father=q[head++]; ans[cur]=father; for (auto item : v[u[cur]]) if (!inq[item]) inq[item]=true,q[++tail]=item,q[++tail]=u[cur]; &#125; for (register int i=1;i&lt;=n-1;i++) if (!ans[i]) &#123;puts("-1");return 0;&#125; for (register int i=1;i&lt;=n-1;i++) printf("%d %d\n",u[i],ans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>最大流</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 029E]Wandering TKHS 题解]]></title>
    <url>%2Fblog%2Fagc029e%2F</url>
    <content type="text"><![CDATA[Problem StatementTakahashi’s office has $N$ rooms. Each room has an ID from $1$ to $N$. There are also $N−1$ corridors, and the $i$-th corridor connects Room $a_i$ and Room $b_i$. It is known that we can travel between any two rooms using only these corridors. Takahashi has got lost in one of the rooms. Let this room be $r$. He decides to get back to his room, Room $1$, by repeatedly traveling in the following manner: Travel to the room with the smallest ID among the rooms that are adjacent to the rooms already visited, but not visited yet.Let $c_r$ be the number of travels required to get back to Room $1$. Find all of $c_2,c_3,…,c_N$ . Note that, no matter how many corridors he passes through in a travel, it still counts as one travel. Constraints $2\leq N\leq 2\times 10^5$ $1\leq a_i,b_i\leq N$ $a_i\neq b_i$ The graph given as input is a tree. InputInput is given from Standard Input in the following format: N a1 b1 . . . an-1 bn-1 OutputPrint $c_r$ for each $r$, in the following format: c2 c3 ... cn Sample Input 16 1 5 5 6 6 2 6 3 6 4 Sample Output 15 5 5 1 5 For example, if Takahashi was lost in Room $2$, he will travel as follows: Travel to Room $6$. Travel to Room $3$. Travel to Room $4$. Travel to Room $5$. Travel to Room $1$. Sample Input 26 1 2 2 3 3 4 4 5 5 6 Sample Output 21 2 3 4 5 Sample Input 310 1 5 5 6 6 10 6 4 10 3 10 8 8 2 4 7 4 9 Sample Output 37 5 3 1 3 4 7 4 5 Solution首先一个显然的性质是我们最后经过的所有的点是树上的一个联通块。 考虑对于任意一个点的c值该怎么求。我们发现一个点要到达根节点，至少要做的事情是打通从它到1的这条路径。 然后考虑这条链上挂的若干棵子树。我们发现对于每棵子树，与子树根连通的所有小于从1到子树根祖父的max的节点会访问到，其他的不会访问到（有点拗口）。 如果我们提前求好了每个节点的上述东西的答案。那我们只要一边搜索一边把各个子树的答案加起来，就可以得到所有的c了。 接下来考虑怎么算之前的那个东西。因为是祖父，跨过了父亲，所以有些难算。考虑离线。我们把所有的点按照1~祖父的max从小到大排序。这样我们可以按照编号去依次“点亮”一些节点，然后每次来统计某棵子树内和根节点相连的“点亮”的节点的个数。一个显然的想法是每次点亮一个节点后用LCT来维护子树和，但太难写了，没有很好的运用树的结构是固定的这个性质。 考虑这样一个做法：事实上我们要支持的是一些link操作。每次link会影响的节点是从被link的节点向上的一条被点亮的链的子树和。这样我们可以在树上打差分标记，在链的最下端加，在链的最上端的父亲减，这样把树映射到dfs序上之后只要查一个子树在dfs序上的和就行了。至于怎么找最上端的点，可以考虑并查集。定义一个联通块的代表元是深度最小的节点即可。 因为有一个BIT，所以总时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,maxn[MAXN+48],fa[MAXN+48];vector&lt;int&gt; v[MAXN+48];int dp[MAXN+48],ans[MAXN+48];int L[MAXN+48],R[MAXN+48],ind;int id[MAXN+48];inline bool cmp(int x,int y)&#123; int xx=fa[fa[x]],yy=fa[fa[y]]; return maxn[xx]&lt;maxn[yy];&#125;bool exist[MAXN+48];namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=1;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;namespace BIT&#123; int c[MAXN+48]; inline void init() &#123;memset(c,0,sizeof(c));&#125; inline void update(int x,int delta) &#123;if (!x) return;while (x&lt;=n) c[x]+=delta,x+=LOWBIT(x);&#125; inline int query(int x) &#123;int res=0;while (x) res+=c[x],x^=LOWBIT(x);return res;&#125; inline int calc(int x,int y) &#123;return query(y)-query(x-1);&#125;&#125;inline void dfs(int cur,int father)&#123; L[cur]=++ind;fa[cur]=father; for (auto y : v[cur]) if (y!=father) maxn[y]=max(maxn[cur],y),dfs(y,cur); R[cur]=ind;&#125;inline void Dfs(int cur,int father,int curans)&#123; int cursum=0; for (auto y : v[cur]) if (y!=father) cursum+=dp[y]; ans[cur]=curans+1+cursum; for (auto y : v[cur]) if (y!=father) Dfs(y,cur,curans+1+cursum-dp[y]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d",&amp;n); for (register int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); v[x].pb(y);v[y].pb(x); &#125; maxn[1]=1;dfs(1,0); for (register int i=1;i&lt;=n;i++) id[i]=i; maxn[0]=INF;sort(id+1,id+n+1,cmp); DSU::init();BIT::init();int curpt=0; for (register int i=1;i&lt;=n;i++) &#123; if (fa[fa[id[i]]]==0) continue; int need=maxn[fa[fa[id[i]]]]; while (curpt&lt;need-1) &#123; ++curpt;exist[curpt]=true; BIT::update(L[curpt],1);BIT::update(L[fa[curpt]],-1); for (auto y : v[curpt]) if (exist[y]) &#123; int xx=curpt,yy=y;if (fa[xx]==yy) swap(xx,yy); int ynum=BIT::calc(L[yy],R[yy]),anc=DSU::find_anc(xx); BIT::update(L[xx],ynum);BIT::update(L[fa[anc]],-ynum); DSU::update(yy,xx); &#125; &#125; dp[id[i]]=BIT::calc(L[id[i]],R[id[i]]); &#125; Dfs(1,0,0); for (register int i=2;i&lt;=n;i++) printf("%d ",ans[i]-1); puts(""); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>BIT</category>
        <category>dfs序</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>并查集</tag>
        <tag>BIT</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UOJ #3][NOI2014]魔法森林 题解]]></title>
    <url>%2Fblog%2Fuoj3%2F</url>
    <content type="text"><![CDATA[Description为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个$N$节点$M$条边的无向图，节点标号为 $1…n$，边标号为$1…m$。初始时小E同学在 $1$ 号节点，隐士则住在 $n$ 号节点。小E需要通过这一片魔法森林，才能够拜访到隐士。 魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。 只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$。若身上携带的A型守护精灵个数不少于 $a_i$，且B型守护精灵个数不少于 $b_i$，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。 由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。 Input Format第$1$行包含两个整数 $n$,$m$，表示无向图共有 $n$ 个节点，$m$ 条边。 接下来 $m$ 行，第 $i+1$ 行包含4个正整数 $x_i$,$y_i$,$a_i$,$b_i$，描述第 $i$ 条无向边。其中 $x_i$ 与 $y_i$ 为该边两个端点的标号，$a_i$ 与 $b_i$的含义如题所述。 注意数据中可能包含重边与自环。 Output Format输出一行一个整数：如果小E可以成功拜访到隐士，输出小E最少需要携带的守护精灵的总个数；如果无论如何小E都无法拜访到隐士，输出“$-1$”（不含引号）。 Sample Input 14 5 1 2 19 1 2 3 8 12 2 4 12 15 1 3 17 8 3 4 1 17 Sample Output 132 Explanation 1如果小E走路径1→2→4，需要携带 $19+15=34$ 个守护精灵； 如果小E走路径1→3→4，需要携带 $17+17=34$ 个守护精灵； 如果小E走路径1→2→3→4，需要携带 $19+17=36$ 个守护精灵； 如果小E走路径1→3→2→4，需要携带 $17+15=32$ 个守护精灵。 综上所述，小E最少需要携带 $32$ 个守护精灵。 Sample Input 23 1 1 2 1 1 Sample Output 2-1 Explanation 2小E无法从$1$号节点到达$3$号节点，故输出$-1$。 Constraints 对于$100\%$的数据，$2\leq n\leq 50000$,$0\leq m\leq 100000$,$1\leq a_i,b_i\leq 50000$ Solution将所有的边按照$a_i$为关键字升序从小到大排序，这样我们之后可以从小到大枚举最后的$A$，随着$A$的增大，我们可用的边也就逐渐增多，要在这个不断加边的图中找到让$B$最小的方案。 不难发现，对于图中的任意两点，使得他们之间的路径的最大值最小，这条路径一定在图的最小生成树上，因此我们只要动态的维护以$b_i$为边权的图的最小生成树即可。 考虑用LCT维护最小生成树。对于当前的一条新边$(x,y)$，如果$x$,$y$不连通就直接link。否则我们找到$x$到$y$的路径上的最大边，如果最大边的权值大于当前边，就cut掉最大边，link上当前边，否则直接丢掉当前边。 PS: 注意LCT判断两个点是否连通的条件:应该都find_root之后判断根是否相同。 Code这份代码在UOJ上97pts,可能常数大了点，洛谷是能过的2333123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,m;struct Edge&#123; int u,v,a,b; inline void input() &#123;scanf("%d%d%d%d",&amp;u,&amp;v,&amp;a,&amp;b);&#125; inline bool operator &lt; (const Edge &amp;other) const &#123;return a&lt;other.a;&#125;&#125;edge[MAXN+48];namespace LCT&#123; struct node &#123; int ch[2],val,maxn,maxind,flip,father; &#125;tree[MAXN+48]; inline void update(int x,int y) &#123; if (!y) return; if (tree[y].maxn&gt;tree[x].maxn) tree[x].maxn=tree[y].maxn,tree[x].maxind=tree[y].maxind; &#125; inline void pushup(int cur) &#123; tree[cur].maxn=tree[cur].val;tree[cur].maxind=cur; update(cur,tree[cur].ch[0]);update(cur,tree[cur].ch[1]); &#125; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].ch[0]].flip^=1; tree[tree[cur].ch[1]].flip^=1; tree[cur].flip=0;swap(tree[cur].ch[0],tree[cur].ch[1]); &#125; &#125; inline void Create(int cur,int val) &#123; tree[cur].val=val;tree[cur].ch[0]=tree[cur].ch[1]=tree[cur].flip=tree[cur].father=0; pushup(cur); &#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; pushdown(y);pushdown(x); int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; pushdown(x); while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void makeroot(int cur) &#123; access(cur);splay(cur); tree[cur].flip^=1; &#125; inline int find_root(int x) &#123; access(x);splay(x); while (tree[x].ch[0]) x=tree[x].ch[0]; return x; &#125; inline bool issame(int x,int y) &#123; return find_root(x)==find_root(y); &#125; inline void link(int x,int y) &#123; makeroot(x); tree[x].father=y; &#125; inline void cut(int x,int y) &#123; makeroot(x);access(y);splay(y); tree[x].father=0;tree[y].ch[0]=0;pushup(y); &#125; inline Pair query(int x,int y) &#123; makeroot(x);access(y);splay(y); return mp(tree[y].maxn,tree[y].maxind); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m); for (register int i=1;i&lt;=m;i++) edge[i].input(); sort(edge+1,edge+m+1); for (register int i=1;i&lt;=n;i++) LCT::Create(i,0); for (register int i=1;i&lt;=m;i++) LCT::Create(n+i,edge[i].b); int ans=INF; for (register int i=1;i&lt;=m;i++) &#123; if (edge[i].a&gt;=ans) break; if (edge[i].u!=edge[i].v) &#123; if (!LCT::issame(edge[i].u,edge[i].v)) LCT::link(n+i,edge[i].u),LCT::link(n+i,edge[i].v); else &#123; Pair res=LCT::query(edge[i].u,edge[i].v); if (res.x&gt;edge[i].b) &#123; LCT::cut(res.y,edge[res.y-n].u);LCT::cut(res.y,edge[res.y-n].v); LCT::link(n+i,edge[i].u);LCT::link(n+i,edge[i].v); &#125; &#125; &#125; if (LCT::issame(1,n)) check_min(ans,edge[i].a+LCT::query(1,n).x); &#125; if (ans&gt;=INF) ans=-1; printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数据结构</category>
        <category>最小生成树</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>LCT</tag>
        <tag>UOJ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4530][BJOI2014]大融合 题解]]></title>
    <url>%2Fblog%2Fbzoj4530%2F</url>
    <content type="text"><![CDATA[Description小强要在$N$个孤立的星球上建立起一套通信系统。这套通信系统就是连接$N$个点的一个树。这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。 例如，在上图中，现在一共有了$5$条边。其中，$(3,8)$这条边的负载是$6$，因为有六条简单路径$2$-$3$-$8$,$2$-$3$-$8$-$7$,$3$-$8$,$3$-$8$-$7$,$4$-$3$-$8$,$4$-$3$-$8$-$7$路过了$(3,8)$。 现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。 Input第一行包含两个整数$N$,$Q$，表示星球的数量和操作的数量。星球从$1$开始编号。 接下来的$Q$行，每行是如下两种格式之一： A x y 表示在$x$和$y$之间连一条边。保证之前$x$和$y$是不联通的。 Q x y 表示询问$(x,y)$这条边上的负载。保证$x$和$y$之间有一条边。 Output对每个查询操作，输出被查询的边的负载。 Sample Input8 6 A 2 3 A 3 4 A 3 8 A 8 7 A 6 5 Q 3 8 Sample Output6 Constraints$1\leq N,Q\leq 100000$ Solution一条边的访问个数就是他两端的子树大小之积。所以只要用LCT维护子树大小即可。 经典的LCT是维护链上信息的。考虑如何用LCT维护子树信息。我们定义一个节点在splay中的儿子为实儿子，只由儿子指向父亲，父亲不指向儿子的儿子为虚儿子。 我们考虑某个节点$x$在LCT中对应的点，在$x$子树内的节点在LCT中有以下两种： 和当前点在同一棵splay中且中序遍历之后在$z$之后。因为splay是以深度为关键字维护一条重链，同在一条链中且深度比$x$大自然在$x$的子树内。 $x$的所有虚儿子的子树和。 于是我们考虑对于LCT中的每个节点，多维护一个vsum表示所有虚儿子的子树和,一个sum表示所有虚儿子的子树和加上splay中他的子树的和。我们发现LCT的所有操作中只有access和link两种操作和虚儿子有关。 对于link操作，有一个动作是将$x$挂到$y$的下方作为$y$的虚儿子，此时我们只要将$y$的vsum加上$x$的sum即可。 对于access操作，本质上它是修改了一串节点的实儿子，相当于废掉一个实儿子，又从虚儿子中拎了一个出来作为实儿子。我们只要对于vsum加上前实儿子（现虚儿子）的sum,减去前虚儿子（现实儿子）的sum即可。 查询的时候按照上面的两点统计答案即可。其他操作都和经典LCT一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,q;namespace LCT&#123; struct node &#123; int ch[2],vsum,sum,Sum,father; int flip; &#125;tree[MAXN+48]; inline void init() &#123; for (register int i=1;i&lt;=n;i++) tree[i].ch[0]=tree[i].ch[1]=tree[i].flip=0,tree[i].vsum=0,tree[i].sum=tree[i].Sum=1,tree[i].father=0; &#125; inline void pushup(int cur) &#123; tree[cur].sum=tree[tree[cur].ch[0]].sum+tree[tree[cur].ch[1]].sum+tree[cur].vsum+1; tree[cur].Sum=tree[tree[cur].ch[1]].sum+tree[cur].vsum+1; &#125; inline void pushdown(int cur) &#123; if (tree[cur].flip) &#123; tree[tree[cur].ch[0]].flip^=1; tree[tree[cur].ch[1]].flip^=1; swap(tree[cur].ch[0],tree[cur].ch[1]); tree[cur].flip=0; &#125; &#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; pushdown(y);pushdown(x); int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; pushdown(x); while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].vsum+=tree[tree[cur].ch[1]].sum; tree[cur].vsum-=tree[pre].sum; tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void makeroot(int cur) &#123; access(cur);splay(cur);tree[cur].flip^=1; pushdown(cur);pushup(cur); &#125; inline void link(int x,int y) &#123; makeroot(x);access(y);splay(y); tree[x].father=y;tree[y].vsum+=tree[x].sum; pushup(y); &#125; inline LL query(int x,int y) &#123; makeroot(x);makeroot(y); return 1ll*tree[x].Sum*(tree[y].Sum-tree[x].Sum); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q);char op[5];int x,y; LCT::init();int cnt=0; while (q--) &#123; ++cnt; scanf("%s%d%d",op+1,&amp;x,&amp;y); if (op[1]=='A') LCT::link(x,y); else printf("%lld\n",LCT::query(x,y)); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder4415][JAGSC2018]ADD DIV MAX RESTORE 题解]]></title>
    <url>%2Fblog%2Fatcoder4415%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given an integer sequence $a_0,a_1,…,a_{N−1}$. You have to perform $Q$ queries, each query is one of the following: ADD QUERY(t=0 l r x) : for each $i$ between $l$ and $r$, inclusive, replace $a_i$ with $a_i+x$. DIV QUERY(t=1 l r x) : for each i between $l$ and $r$, inclusive, replace ai with $floor(a_i⁄x)$, where $floor(y)$ is the biggest integer that is not greater than $y$. MAX QUERY(t=2 l r x=0) : print $max(a_l,a_{l+1},…,a_r)$. RESTORE QUERY(t=3 l r x=0) : for each $i$ between $l$ and $r$, inclusive, set $a_i$ to the initial value of $a_i$, that is, the value given in the input. Constraints All input values are integers. $1\leq N,Q\leq 200,000$ $0\leq a_i\leq 10^8$ $t_i=0,1,2,3$ $0\leq l_i\leq r_i\leq N−1$ $1\leq x_i\leq 1000$(when $t_i\neq 2,3$) InputInput is given from Standard Input in the following format: N Q a0 a1 ... aN−1 t1 l1 r1 x1 t2 l2 r2 x2 : tQ lQ rQ xQ OutputFor each MAX QUERY, print $max(a_l,a_{l+1},…,a_r)$, one per line. Sample Input 15 9 1 2 3 4 5 2 0 4 0 0 0 1 10 2 0 4 0 2 2 2 0 1 0 1 4 2 0 0 0 2 1 1 0 3 0 4 0 2 0 1 0 Sample Output 15 12 3 2 3 2 $max(1,2,3,4,5)=5$ $1,2,3,4,5\rightarrow 11,12,3,4,5$ $max(11,12,3,4,5)=12$ $max(3)=3$ $11,12,3,4,5\rightarrow 2,3,3,4,5$ $max(2)=2$ $max(3)=3$ The array is restored to $1,2,3,4,5$ $max(1,2)=2$ Sample Input 24 7 0 1 0 1 2 0 3 0 0 0 3 1 1 0 3 2 2 0 3 0 0 0 3 1 1 0 3 2 2 0 3 0 Sample Output 21 1 1 Sample Input 310 23 13 1 22 8 28 18 23 9 22 27 1 3 4 5 1 8 8 8 0 3 9 5 0 2 6 3 3 0 4 0 1 1 3 7 2 2 2 0 2 3 5 0 0 1 4 2 3 0 9 0 2 0 1 0 0 3 9 8 2 1 9 0 0 8 9 5 1 5 7 7 0 3 5 7 0 7 9 7 3 3 6 0 2 1 6 0 0 1 1 7 1 4 8 10 2 0 9 0 1 5 6 1 Sample Output 33 28 13 36 28 47 Solution看到这个除法的时候以为是吉司机线段树相关，但又有RESTORE操作，不知道该怎么弄。 听了题解发现很神。除法难就难在不知道该怎么在线段树上维护懒标记。我们可以像这样维护标记：$$x\rightarrow \frac{x+d-a}{d}+e$$ 这里的$a\in [0,d-1]$,否则可以除出去加到$e$上 首先考虑加法操作，这个比较简单，直接在$e$上加就可以了 然后考虑除法操作，设要除以x,我们先通分：$$\frac{d-a}{d}+e=\frac{d-a+de}{d}$$ 现在新的除数变成了$dx$,我们拿$d-a+de$整除$dx$的结果作为新的$e$，拿$dx$减模数作为新的$a$即可。 这里要注意的是$dx$一直乘下去可能会爆long long，但因为加法操作的和不会超过$10^8$,所以$dx$和$1e9$取一个min就可以了。 最后考虑标记的合并。因为每次都会有pushdown操作，所以父节点的标记一定是后于子节点的，所以拿着父节点的标记对着子节点先加，再除，最后加即可。 这样这题剩下的部分就是基本的线段树操作了。至于RESTORE操作，可以额外维护一个flushed标记表示是否被清空。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct Tag &#123; LL a,d,e; Tag () &#123;&#125; inline void clear() &#123;a=1;d=1;e=0;&#125; inline Tag(LL _a,LL _d,LL _e) &#123;a=_a;d=_d;e=_e;&#125; inline Tag operator + (LL other) &#123;return Tag(a,d,e+other);&#125; inline Tag operator / (LL other) &#123; LL tmp=d-a+d*e,nd=d*other; LL ne=tmp/nd,na=nd-tmp%nd; check_min(nd,1ll*INF);check_min(na,1ll*INF); return Tag(na,nd,ne); &#125; inline void merge(Tag other) &#123; Tag tmp=(*this); tmp=(tmp+(other.d-other.a))/other.d+other.e; (*this)=tmp; &#125; inline int getval(int x) &#123;return (x+d-a)/d+e;&#125; &#125;; Tag lazy[MAXN*4];int ori[MAXN*4],maxn[MAXN*4];bool flushed[MAXN*4]; inline void pushup(int cur) &#123; maxn[cur]=max(maxn[cur&lt;&lt;1],maxn[cur&lt;&lt;1|1]); &#125; inline void pushdown(int cur) &#123; if (flushed[cur]) &#123; flushed[cur&lt;&lt;1]=flushed[cur&lt;&lt;1|1]=true; lazy[cur&lt;&lt;1].clear();lazy[cur&lt;&lt;1|1].clear(); maxn[cur&lt;&lt;1]=ori[cur&lt;&lt;1];maxn[cur&lt;&lt;1|1]=ori[cur&lt;&lt;1|1]; flushed[cur]=false; &#125; lazy[cur&lt;&lt;1].merge(lazy[cur]);lazy[cur&lt;&lt;1|1].merge(lazy[cur]); maxn[cur&lt;&lt;1]=lazy[cur].getval(maxn[cur&lt;&lt;1]); maxn[cur&lt;&lt;1|1]=lazy[cur].getval(maxn[cur&lt;&lt;1|1]); lazy[cur].clear(); &#125; inline void build(int cur,int l,int r) &#123; lazy[cur].clear();flushed[cur]=false; if (l!=r) &#123; int mid=(l+r)&gt;&gt;1; build(cur&lt;&lt;1,l,mid);build(cur&lt;&lt;1|1,mid+1,r); pushup(cur);ori[cur]=maxn[cur]; &#125; else &#123; maxn[cur]=ori[cur]=a[l]; &#125; &#125; inline void modify(int op,int cur,int left,int right,int x,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; if (!op) &#123;lazy[cur]=lazy[cur]+x;maxn[cur]+=x;return;&#125; if (op==1) &#123;lazy[cur]=lazy[cur]/x;maxn[cur]/=x;return;&#125; if (op==3) &#123;flushed[cur]=true;maxn[cur]=ori[cur];lazy[cur].clear();return;&#125; &#125; pushdown(cur);int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) modify(op,cur&lt;&lt;1,left,right,x,l,mid); if (mid+1&lt;=right) modify(op,cur&lt;&lt;1|1,left,right,x,mid+1,r); pushup(cur); &#125; inline int query(int cur,int left,int right,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) return maxn[cur]; pushdown(cur);int mid=(l+r)&gt;&gt;1,res=-1; if (left&lt;=mid) check_max(res,query(cur&lt;&lt;1,left,right,l,mid)); if (mid+1&lt;=right) check_max(res,query(cur&lt;&lt;1|1,left,right,mid+1,r)); pushup(cur);return res; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;q); for (register int i=1;i&lt;=n;i++) scanf("%d",a+i); SegmentTree::build(1,1,n); int op,l,r,x; while (q--) &#123; scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;x);++l;++r; if (op!=2) SegmentTree::modify(op,1,l,r,x,1,n); else printf("%d\n",SegmentTree::query(1,l,r,1,n)); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces GYM 101955A]Sockpuppets 题解]]></title>
    <url>%2Fblog%2Fgym101955a%2F</url>
    <content type="text"><![CDATA[DescriptionPheatr has a lot of accounts competing in online programming contests such as contests on TopForces. Sometimes when Pheatr participates in a contest on TopForces but cannot attain a good score directly, he takes advantage of some extra accounts applied for cheating (i. e. sockpuppets) to achieve a higher score: Initially, he builds some wrong codes which can pass the pre-system tests and submits them through the sockpuppets. After that, he uses his main account to challenge these sockpuppets immediately, since a successful challenge provides him 100 more score points. Actually, Pheatr is not the only one who cheats in the contests. Many competitors use the same strategy during online programming contests. It is well known that everyone has only one account as the main account. If one’s cheating is revealed, the main account of the one will be banned forever. To prevent the notorious fact from being exposed, each competitor would not register more than two sockpuppets. In spite of great peril, when they register their sockpuppets, these competitors always follow the same rule that the username of a sockpuppet belonging to one competitor should be a prefix of that of the competitor’s main account, otherwise the username of the main account should be a prefix of that of the sockpuppet. Recently, a leak from TopForces provided a list of verified cheaters who have used sockpuppets for cheating, containing the usernames of their main accounts. Besides, TopForces also published a list of suspicious accounts, implying some of them may be sockpuppets. In order to differentiate these suspicious accounts and point out their owners, Pheatr intends to describe all the possibilities according to the published information. Certainly, one should notice that some of the suspicious accounts may be wronged and do not belong to any known cheaters. After recognizing your outstanding programming skills, Pheatr asks you to count the number of distinct possibilities in total for claiming the affiliations between verified cheaters and suspicious accounts. Two possibilities are considered the same if each suspicious account is wronged simultaneously or belongs to the same competitor in both possibilities. Since the answer can be pretty large, you are only asked to report the answer modulo $(10^9+7)$. InputThe input contains several test cases, and the first line contains a positive integer $T$ indicating the number of test cases which is up to $100$. For each test case, the first line contains two integers $n$ and $m$ indicating the number of known cheaters in the leak and the number of suspicious accounts provided by TopForces respectively, where $1\leq n,m\leq 1000$. Each of the following $n$ lines contains a non-empty string $s$ in all lowercase letters representing the username of the main account for a known cheater, where the length of $s$ is up to $10$. And each of the following $m$ lines contains a non-empty string $t$ in all lowercase letters representing the username of a suspicious account, where the length of $t$ is up to $10$. We guarantee that all usernames appeared in the same test case are distinct. OutputFor each test case, output a line containing “Case #x: y” (without quotes), where $x$ is the test case number starting from $1$, and $y$ is the answer modulo $(10^9+7)$ to this test case. Exampleinput 3 1 2 a aa aaa 1 2 aa a ab 5 5 a ah ahd ahdo ahdoc ahdoca ahdocah ahdocahd ahdocahdo ahdocahdoc output Case #1: 4 Case #2: 2 Case #3: 6396 NoteIn the first sample case, both sockpuppets $aa$ and $aaa$ can belong to the owner of $a$. In the second sample case, the sockpuppet $ab$ cannot belong to the owner of $aa$, while $a$ can. In the third sample case, each sockpuppet can belong to anyone in the list leaked from TopForces. Solution刚开始我的思路没有很好的运用这个前缀后缀匹配的性质，这样即使直接给你一张二分图，告诉你哪些点之间有边，求匹配的方案，也是不好求的。 事实上前缀后缀匹配的优良性质是：与一个串匹配的且比他短的串不会超过10个，因为$\mid s\mid \leq 10$。 我们先对所有的大号和小号合起来建一棵Trie。我们称大号的结尾节点为1类节点，小号的结尾节点为2类节点。这样对于一个串来说，能和它匹配的是结尾节点所在子树内节点和结尾节点的所有祖先。 考虑树型$dp$,$dp[i][j][k]$表示考虑Trie树上以$i$为根的子树，在子树内匹配完后大号们对祖先还有$a$个匹配需求，小号们对祖先还有$b$个匹配需求的方案数。我们的答案显然是$dp[root][0][0]$。考虑一下$j$和$k$的范围。即使祖先们全是小号最多再匹配$10$个大号，即使祖先们全是大号最多再匹配$20$个小号，所以$j\leq 10,k\leq 20$。 对于从子树转移而来的部分，只要简单的做一个树上背包即可。接下来考虑根节点。如果根节点是一个1类节点，就要分它向下匹配几个，向上需求几个来讨论，并不复杂，只有一个要特别注意一下：如果该节点选择向上需求两个，我们的$j$会加2，但事实上这两份需求来自同一个节点，是一样的，所以我们可以提前除以一个2，这样后面匹配的时候就可以为所欲为了。如果是一个2类节点，同样是分类讨论。 时间复杂度$O(T(n\mid s\mid )\mid s\mid ^2)$,不过我在树上背包的时候直接强上没有和size取min竟然也过了？（大雾 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=24848;int n,m,inv2;char s[48];int dp[MAXN+48][11][21],dp2[11][21];/*------ Trie begin ------*/int nxt[MAXN+48][27],type[MAXN+48],tot,root;inline int Create() &#123;++tot;type[tot]=0;memset(nxt[tot],0,sizeof(nxt[tot]));return tot;&#125;inline void init() &#123;tot=0;root=Create();&#125;inline void insert(char s[],int t)&#123; int cur=root,len=strlen(s+1); for (register int i=1;i&lt;=len;i++) &#123; int w=s[i]-'a'+1; if (!nxt[cur][w]) nxt[cur][w]=Create(); cur=nxt[cur][w]; &#125; type[cur]=t;&#125;/*------ Trie end ------*/inline void dfs(int cur)&#123; for (register int i=1;i&lt;=26;i++) if (nxt[cur][i]) dfs(nxt[cur][i]); memset(dp[cur],0,sizeof(dp[cur]));dp[cur][0][0]=1; for (register int i=1;i&lt;=26;i++) if (nxt[cur][i]) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) if (dp[cur][anum][bnum]) for (register int toanum=0;anum+toanum&lt;=10;toanum++) for (register int tobnum=0;bnum+tobnum&lt;=20;tobnum++) Add(dp2[anum+toanum][bnum+tobnum],1ll*dp[cur][anum][bnum]*dp[nxt[cur][i]][toanum][tobnum]%MOD); for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125; if (type[cur]==1) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) if (dp[cur][anum][bnum]) &#123; //up: 0;down: 0; Add(dp2[anum][bnum],dp[cur][anum][bnum]); //up: 1;down: 0; if (anum+1&lt;=10) Add(dp2[anum+1][bnum],dp[cur][anum][bnum]); //up: 2;down 0; if (anum+2&lt;=10) Add(dp2[anum+2][bnum],1ll*dp[cur][anum][bnum]*inv2%MOD); //up: 0;down 1; if (bnum-1&gt;=0) Add(dp2[anum][bnum-1],1ll*dp[cur][anum][bnum]*bnum%MOD); //up: 1;down 1; if (anum+1&lt;=10 &amp;&amp; bnum-1&gt;=0) Add(dp2[anum+1][bnum-1],1ll*dp[cur][anum][bnum]*bnum%MOD); //up: 0;down 2; if (bnum-2&gt;=0) Add(dp2[anum][bnum-2],1ll*dp[cur][anum][bnum]*(bnum*(bnum-1)/2)%MOD); &#125; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125; if (type[cur]==2) &#123; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=10;bnum++) if (dp[cur][anum][bnum]) &#123; //up: 0;down 0; Add(dp2[anum][bnum],dp[cur][anum][bnum]); //up: 1;down 0; if (bnum+1&lt;=20) Add(dp2[anum][bnum+1],dp[cur][anum][bnum]); //up: 0;down 1; if (anum-1&gt;=0) Add(dp2[anum-1][bnum],1ll*dp[cur][anum][bnum]*anum%MOD); &#125; for (register int anum=0;anum&lt;=10;anum++) for (register int bnum=0;bnum&lt;=20;bnum++) dp[cur][anum][bnum]=dp2[anum][bnum],dp2[anum][bnum]=0; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int ca;scanf("%d",&amp;ca);inv2=(MOD+1)&gt;&gt;1; for (register int casenum=1;casenum&lt;=ca;casenum++) &#123; scanf("%d%d",&amp;n,&amp;m);init(); for (register int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); insert(s,1); &#125; for (register int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); insert(s,2); &#125; dfs(root); printf("Case #%d: %d\n",casenum,dp[root][0][0]); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>字符串</category>
        <category>树型dp</category>
        <category>背包</category>
        <category>Trie树</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>GYM</tag>
        <tag>树型dp</tag>
        <tag>Trie树</tag>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder4417][JAGSC2018]Short LIS 题解]]></title>
    <url>%2Fblog%2Fatcoder4417%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given three integers N, A, and B. Let $P=(P_0,P_1,…,P_{N−1})$ be a permutation of $(0,1,…,N−1)$. $P$ is said good if and only if it satisfies all of the following conditions: The length of a longest increasing subsequence of $P$ is at most $2$. $P_A$=$B$ Count the number of good permutations modulo 1e9+7. Constraints $1\leq N \leq 10^6$ $0\leq A\leq N-1$ $0\leq B\leq N-1$ InputInput is given from Standard Input in the following format: N A B OutputPrint the number of good permutations modulo 1e9+7. Sample Input 13 0 0 Sample Output 11 The only good permutation is $(0,2,1)$. Sample Input 212 2 3 Sample Output 25390 Sample Input 310000 9875 5431 Sample Output 3135608808 Solution非常神的一道题 我们考虑一个permutation, 把所有是前缀最小值的点拎出来，我们会发现剩下的数列也一定是一个下降序列，因为任意两个前缀最小值之间如果有一对升序的点，和前面的前缀最小值合起来就形成了一个长度为3的上升序列从而不合法。 设这些前缀最小值为$(a_1,p_{a_1}),(a_2,p_{a_2})\dots(a_k,p_{a_k})$,我们将这些点在平面上画出来，然后两两之间先向下走再向右走，我们我们可以得到一条从$(0,n)$到$(n,0)$的路径，这条路径始终在正方形左上-右下对角线的下方。我们发现，这种路径和原序列是一一对应的。因而我们只要对这样的路径进行计数即可。 如果我们将坐标轴旋转$45^。$,可以把问题变成这样：从$(0,0)$出发，每次位移的向量是$(1,1)$或$(1,-1)$且任意时刻必须在$x$轴上方，最终到达$(n,0)$，求路径条数。 这是非常著名的Dyck Path,在不加限制的情况下路径的条数是卡特兰数的第$n$项。 现在考虑$P_A=B$的限制。我们比较希望$P_A$是一个前缀最小值，这样我们就能在路径上明确的找到他。注意到如果$A+B&gt;n-1$的话$P_A$肯定不是前缀最小值，此时我们可以做变换$a=n-1-a,b=n-1-b$，相当于将整个序列reverse之后再将每个数取补。 如果$A+B\leq n-1$的话我们可以证明合法的序列$P_A$一定是前缀最小值。考虑反证法，假设存在一个$C&lt;A$使得$P_C&lt;P_A$,那么可以得到$P_A$后面的数必须都比$P_A$小。因此序列中比$P_A$小的数至少有$(n-1)-A+1=n-A$个，因为$P_A=B$,所以有$n-A\leq B$，即$A+B\geq n$，与之前的$A+B\leq n-1$矛盾。 于是我们只要求过点$(A,P_A)$的Dyck Path有多少条。考虑到$P_A$是前缀最小值，所以一定有这样一个局部$(A,P_A+1)\Rightarrow(A,P_A)\Rightarrow(A+1,P_A)$，所以我们只要分别统计从$(0,n)$到$(A,P_A+1)$和从$(A+1,P_A)$到$(n,0)$的Dyck Path即可。 这种变种的Dyck Path有一种经典优美的求法： 根据终点的横纵坐标差，我们可以得到有多少次向上，多少次向下。不妨设$n$次向上,$m$次向下$(n\geq m)$。先不考虑必须在$x$轴上方的条件，这就是在$n+m$次中选择$n$次向上，$C_{n+m}^n$。再考虑扣除那些到过$x$轴以下的路径。这些路径必然和$y=-1$相交。考虑该路径和$y=-1$的第一个交点以左的部分，我们将这个部分关于$y=-1$对称，可以得到一条从$(0,-2)$出发的路径。接而我们发现刚才那些不合法的路径和这些从$(0,-2)$到目标点的路径一一对应。从$(0,-2)$到目标点，纵坐标多了2，相当于向上$n+1$次，向下$m-1$次，所以这部分有$C_{n+m}^{n+1}$条。综上，合法的Dyck Path共有$C_{n+m}^n-C_{n+m}^{n+1}$ 完结撒花 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3e6;int fac[MAXN+48],ifac[MAXN+48];inline void init_inv()&#123; fac[0]=1;for (register int i=1;i&lt;=MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;y) return 0; return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;&#125;int n,a,b;inline int calc(int x,int y)&#123; if (x&lt;y) return 0; return C(x,(x+y)&gt;&gt;1);&#125;inline int solve(int x,int y)&#123; int xx=n-(y-x),yy=n-(x+y); return sub(calc(xx,yy)-calc(xx,yy+2));&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif init_inv(); scanf("%d%d%d",&amp;n,&amp;a,&amp;b); if (a+b&gt;n-1) a=n-1-a,b=n-1-b; printf("%d\n",1ll*solve(a,b+1)*solve(b,a+1)%MOD); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2555]SubString 题解]]></title>
    <url>%2Fblog%2Fbzoj2555%2F</url>
    <content type="text"><![CDATA[Description懒得写背景了，给你一个字符串init，要求你支持两个操作 (1):在当前字符串的后面插入一个字符串 (2):询问字符串s在当前字符串中出现了几次？(作为连续子串) 你必须在线支持这些操作。 Input第一行一个数Q表示操作个数 第二行一个字符串表示初始字符串init 接下来Q行，每行2个字符串Type,Str Type是ADD的话表示在后面插入字符串。 Type是QUERY的话表示询问某字符串在当前字符串中出现了几次。 为了体现在线操作，你需要维护一个变量mask，初始值为0 读入串Str之后，使用这个过程将之解码成真正询问的串TrueStr。 询问的时候，对TrueStr询问后输出一行答案Result 然后mask=maskxorResult 插入的时候，将TrueStr插到当前字符串后面即可。 HINT:ADD和QUERY操作的字符串都需要解压 新加数据一组–2015.05.20 Sample Input2 A QUERY B ADD BBABBBBAAB Sample Output0 Constraints长度 &lt;= 600000，询问次数&lt;= 10000,询问总长度&lt;= 3000000 Solution要求在线的向后面添加字符，这个SAM很支持。要查询某个字符串在母串中出现了多少次，只要在SAM上跑一边，然后统计一下子树的right集合的大小即可。但考虑到SAM的结构在不断变化，为了快速统计所有节点的size，我们应该用LCT来维护SAM的parent树。 PS：题目中的Mask很鬼畜，正确的做法见代码，大概是decode的时候传值进去，异或result的时候才真正改变mask的值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1200000;int q;char s[4000048];namespace LCT&#123; struct node &#123; int ch[2],vsum,sum,val,father; &#125;tree[MAXN+48]; inline void Create(int cur,int val) &#123;tree[cur].val=tree[cur].sum=val;tree[cur].vsum=tree[cur].ch[0]=tree[cur].ch[1]=tree[cur].father=0;&#125; inline void pushup(int cur) &#123;tree[cur].sum=tree[cur].vsum+tree[tree[cur].ch[0]].sum+tree[tree[cur].ch[1]].sum+tree[cur].val;&#125; inline bool isroot(int cur) &#123;return tree[tree[cur].father].ch[0]!=cur &amp;&amp; tree[tree[cur].father].ch[1]!=cur;&#125; inline void rotate(int x) &#123; int y=tree[x].father,z=tree[y].father; int k=(tree[y].ch[1]==x); if (!isroot(y)) tree[z].ch[tree[z].ch[1]==y]=x; tree[y].ch[k]=tree[x].ch[k^1];tree[x].ch[k^1]=y; tree[tree[y].ch[k]].father=y;tree[y].father=x;tree[x].father=z; pushup(y);pushup(x); &#125; inline void splay(int x) &#123; while (!isroot(x)) &#123; int y=tree[x].father,z=tree[y].father; if (!isroot(y)) ((tree[y].ch[1]==x)^(tree[z].ch[1]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline void access(int cur) &#123; for (register int pre=0;cur;pre=cur,cur=tree[cur].father) &#123; splay(cur); tree[cur].vsum+=tree[tree[cur].ch[1]].sum; tree[cur].vsum-=tree[pre].sum; tree[cur].ch[1]=pre;pushup(cur); &#125; &#125; inline void link(int x,int y) &#123; access(x);splay(x);access(y);splay(y); tree[x].father=y;tree[y].vsum+=tree[x].sum;pushup(y); &#125; inline void cut(int x) &#123; access(x);splay(x); tree[tree[x].ch[0]].father=0;tree[x].ch[0]=0;pushup(x); &#125; inline int query(int x) &#123; access(x);splay(x); return tree[x].vsum+tree[tree[x].ch[1]].sum+tree[x].val; &#125;&#125;namespace SAM&#123; int nxt[MAXN*2][27],par[MAXN*2],maxn[MAXN*2],root,last,tot; inline void init() &#123;tot=1;root=last=1;LCT::Create(root,0);&#125; inline void extend(char ch) &#123; int p=last,np=++tot,w=ch-'A'+1;maxn[np]=maxn[p]+1;LCT::Create(np,1); while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;LCT::link(np,root);last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;LCT::link(np,q);last=np;return;&#125; int nq=++tot;LCT::Create(nq,0); maxn[nq]=maxn[p]+1;memcpy(nxt[nq]+1,nxt[q]+1,26*sizeof(int)); par[nq]=par[q];LCT::link(nq,par[nq]); LCT::cut(q);par[q]=nq;LCT::link(q,nq); par[np]=nq;LCT::link(np,nq); while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline int go(int cur,char ch) &#123;return nxt[cur][ch-'A'+1]?nxt[cur][ch-'A'+1]:-1;&#125;&#125;int mask;inline void decodeWithMask(int mask)&#123; int len=strlen(s); for (register int j=0;j&lt;len;j++) &#123; mask=(mask*131+j)%len; char t=s[j]; s[j]=s[mask]; s[mask]=t; &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(q);io.getstring(s);int len=strlen(s);char op[10]; SAM::init();for (register int i=0;i&lt;len;i++) SAM::extend(s[i]); while (q--) &#123; io.getstring(op+1);io.getstring(s); decodeWithMask(mask);len=strlen(s); if (op[1]=='A') &#123; for (register int i=0;i&lt;len;i++) SAM::extend(s[i]); &#125; else &#123; int ans=0,cur=SAM::root; for (register int i=0;i&lt;len;i++) &#123; cur=SAM::go(cur,s[i]); if (cur==-1) break; &#125; if (cur!=-1) ans=LCT::query(cur); printf("%d\n",ans); mask^=ans; &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #28][CTSC2010]珠宝商 题解]]></title>
    <url>%2Fblog%2Fnflsoj28%2F</url>
    <content type="text"><![CDATA[Description给出无根树 $T$，每个节点有一个字符。另给出字符串 $S$。求 $\sum_{u,v}occur(u,v)$。其中 $occur(u,v)$ 为 $T$ 中节点 $u$ 到节点 $v$ 的有向最短路径上的节点连成的字符串在 $S$ 中的出现次数。 Input Format第一行包含两个整数 $N$,$M$，表示 $T$ 的节点个数及 $S$ 的长度。 接下来的 $N−1$ 行，每行两个整数 $x$,$y$，表示节点 $x$ 与节点 $y$ 有无向边相连。 节点由 $1$ ~ $N$ 进行编号。 接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在节点 $i$ 的字符。 最后一行，包含一个长度为 $M$，仅包含小写字母的字符串，表示 $S$。 Output Format一行一个整数为答案。 Sample Input3 5 1 2 1 3 aab abaab Sample Output15 Constraints $100\%$的数据满足，$N,M\leq 50000$ Solution容易想到一个暴力的做法其实也不是很暴力：对字符串$S$建出SAM，枚举树中的每一个点作为根对整棵树进行搜索，搜索移动的同时在SAM上移动，这样树上路径在$S$中出现的次数就是SAM中对应点的right集合大小。在SAM上移动是$O(1)$的，所以该算法时间复杂度为$O(n^2)$ 考虑另外一个不显然的暴力：我们考虑枚举路径的$LCA$，设$LCA$为$z$，那么一条以$z$为转折点的路径$(x,y)$就可以拆成$(x,z)$和$(z,y)$。我们从$z$出发搜索，在一个正串的后缀树上和一个反串的后缀树上移动并打标记，做完之后将两棵后缀树上的标记都下放到叶子，这样从$z$出发的正串和反串都会在$z$上打到标记，最后只要枚举$S$的每一位，将正标记和反标记乘一下即可。至于为什么用后缀树不用SAM，因为如果在SAM上打标记标记会落在子串的两头，在后缀树上打标记才能都落在$z$上。（这个部分讲的很混乱，看代码吧）这个暴力的复杂度是$O(n^2+nm)$ 稍稍优化一下第二个暴力，考虑点分治，每次考虑以重心为$LCA$的情况，这样搜索的总复杂度是$O(nlogn)$,因为每个点都会作为一次重心且每次都要遍历一遍$S$，所以复杂度是$O(nlogn+nm)$ 考虑这个暴力的瓶颈，我们发现有一些很小的子树，我们最后仍然要遍历整个$S$，使得效率下降。 考虑将两个暴力结合，在点分治的过程中，如果剩下的树大小小于$\sqrt m$则使用第一个暴力直接结束。这样的话大小不超过$\sqrt m$的子树个数是$O(\sqrt m)$个，所以这部分是$O(n\sqrt m)$,大于$\sqrt n$的子树也不超过$O(\sqrt m)$个，所以这部分复杂度是$O(m \sqrt m)$,从而时间复杂度为$O((n+m)\sqrt m)$这段复杂度证明非常假 最后要注意一点，点分治的时候要在子树内去重，去重的时候要根据子树的大小选择合适的去重方法，不能只用第二种方法，否则会被菊花图卡掉。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=5e4;int n,m,MAGIC;LL ans;vector&lt;int&gt; v[MAXN+48];char a[MAXN+48],s[2][MAXN+48];bool visited[MAXN+48];int sz[MAXN+48];struct SAM&#123; int maxn[MAXN*2],par[MAXN*2],nxt[MAXN*2][27],to[MAXN*2][27],root,last,tot; int mark[MAXN*2],sz[MAXN*2],ind[MAXN*2],pos[MAXN*2];Pair ord[MAXN*2]; inline int Create() &#123; ++tot; maxn[tot]=par[tot]=mark[tot]=sz[tot]=ind[tot]=0; memset(nxt[tot],0,sizeof(nxt[tot])); return tot; &#125; inline void init() &#123;tot=0;root=last=Create();&#125; inline void extend(char ch,int id) &#123; int p=last,np=Create();maxn[np]=maxn[p]+1;sz[np]=1;ind[np]=id;pos[id]=np; int w=ch-'a'+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=Create();maxn[nq]=maxn[p]+1;memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[np]=nq;par[q]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline int go(int cur,int w) &#123;return nxt[cur][w]?nxt[cur][w]:-1;&#125; inline void build(char s[]) &#123; for (register int i=1;i&lt;=tot;i++) ord[i]=mp(maxn[i],i); sort(ord+1,ord+tot+1); for (register int i=tot;i&gt;=1;i--) &#123; int x=ord[i].y; ind[par[x]]=ind[x];sz[par[x]]+=sz[x]; to[par[x]][s[ind[par[x]]-maxn[par[x]]]-'a'+1]=x; &#125; &#125; inline void pushdown() &#123; for (register int i=1;i&lt;=tot;i++) &#123; int x=ord[i].y; if (par[x]) mark[x]+=mark[par[x]]; &#125; &#125; inline void clear_mark() &#123;for (register int i=1;i&lt;=tot;i++) mark[i]=0;&#125;&#125;sam[2];inline void getsz(int cur,int father)&#123; sz[cur]=1; for (auto y : v[cur]) if (!visited[y] &amp;&amp; y!=father) getsz(y,cur),sz[cur]+=sz[y];&#125;inline void dfs(int cur,int scur,int father,int op)&#123; scur=sam[op].go(scur,a[cur]-'a'+1);if (scur==-1) return; if (!op || father!=-1) ans+=sam[op].sz[scur]; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) dfs(y,scur,cur,op);&#125;inline void swork(int cur,int father)&#123; dfs(cur,sam[0].root,-1,0); for (auto y : v[cur]) if (!visited[y] &amp;&amp; y!=father) swork(y,cur);&#125;inline int getrt(int cur,int father,int Sz)&#123; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y] &amp;&amp; sz[y]&gt;=Sz/2) return getrt(y,cur,Sz); return cur;&#125;inline Pair trans(Pair tmp,int op,int x)&#123; int cur=tmp.x,cnt=tmp.y; if (cnt&lt;sam[op].maxn[cur]) &#123; if (s[op][sam[op].ind[cur]-cnt]!=a[x]) return mp(-1,-1); &#125; else &#123; if (!sam[op].to[cur][a[x]-'a'+1]) return mp(-1,-1); cur=sam[op].to[cur][a[x]-'a'+1]; &#125; return mp(cur,cnt+1);&#125;inline void dfs_sam(int cur,int father,Pair scur,int op)&#123; scur=trans(scur,op,cur); if (scur.x==-1) return; sam[op].mark[scur.x]++; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) dfs_sam(y,cur,scur,op);&#125;vector&lt;int&gt; tree_list,List;int fa[MAXN+48],depth[MAXN+48];inline void dfs_small(int cur,int father)&#123; tree_list.pb(cur);fa[cur]=father; for (auto y : v[cur]) if (y!=father &amp;&amp; !visited[y]) depth[y]=depth[cur]+1,dfs_small(y,cur);&#125;inline int getlca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); while (depth[u]&gt;depth[v]) u=fa[u]; if (u==v) return u; while (u!=v) u=fa[u],v=fa[v]; return u;&#125;inline void solve(int cur)&#123; getsz(cur,-1); if (sz[cur]&lt;=MAGIC) &#123;swork(cur,-1);return;&#125; int rt=getrt(cur,-1,sz[cur]);getsz(rt,-1);visited[rt]=true; for (auto y : v[rt]) if (!visited[y]) &#123; if (sz[y]&gt;=MAGIC) &#123; dfs_sam(y,rt,mp(1,0),0);dfs_sam(y,rt,trans(mp(1,0),1,rt),1); sam[0].pushdown();sam[1].pushdown(); for (register int i=2;i&lt;=m;i++) ans-=1ll*sam[0].mark[sam[0].pos[i-1]]*sam[1].mark[sam[1].pos[m+1-i]]; sam[0].clear_mark();sam[1].clear_mark(); &#125; else &#123; tree_list.clear();depth[y]=1;dfs_small(y,-1); for (register int i=0;i&lt;int(tree_list.size());i++) for (register int j=0;j&lt;int(tree_list.size());j++) &#123; int pt1=tree_list[i],pt2=tree_list[j]; int LCA=getlca(pt1,pt2);int scur=sam[0].root; while (pt1!=LCA) &#123; scur=sam[0].go(scur,a[pt1]-'a'+1); if (scur==-1) break; pt1=fa[pt1]; &#125; if (scur==-1) continue; List.clear(); do &#123; List.pb(pt1); if (pt1==y) break; pt1=fa[pt1]; &#125; while (true); for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; reverse(List.begin(),List.end()); scur=sam[0].go(scur,a[rt]-'a'+1); if (scur==-1) continue; for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; List.clear();while (pt2!=LCA) List.pb(pt2),pt2=fa[pt2]; reverse(List.begin(),List.end()); for (auto pt : List) &#123; scur=sam[0].go(scur,a[pt]-'a'+1); if (scur==-1) break; &#125; if (scur==-1) continue; ans-=sam[0].sz[scur]; &#125; &#125; &#125; for (auto y : v[rt]) if (!visited[y]) dfs_sam(y,rt,mp(1,0),0),dfs_sam(y,rt,trans(mp(1,0),1,rt),1); sam[0].pushdown();sam[1].pushdown(); for (register int i=2;i&lt;=m;i++) ans+=1ll*sam[0].mark[sam[0].pos[i-1]]*sam[1].mark[sam[1].pos[m-i+1]]; sam[0].clear_mark();sam[1].clear_mark(); dfs(rt,sam[0].root,-1,0);dfs(rt,sam[1].root,-1,1); vector&lt;int&gt; sonlist;sonlist.clear(); for (auto y : v[rt]) if (!visited[y]) sonlist.pb(y); for (auto y : sonlist) solve(y);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif scanf("%d%d",&amp;n,&amp;m);int x,y; for (register int i=1;i&lt;=n-1;i++) scanf("%d%d",&amp;x,&amp;y),v[x].pb(y),v[y].pb(x); scanf("%s%s",a+1,s[0]+1); for (register int i=1;i&lt;=m;i++) s[1][i]=s[0][m-i+1]; for (register int op=0;op&lt;=1;op++) &#123; sam[op].init(); for (register int i=1;i&lt;=m;i++) sam[op].extend(s[op][i],i); sam[op].build(s[op]); &#125; for (MAGIC=0;1ll*MAGIC*MAGIC&lt;=m;MAGIC++); ans=0;solve(1); printf("%lld\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
        <category>字符串</category>
        <category>SAM</category>
        <category>后缀树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>根号暴力</tag>
        <tag>NFLSoj</tag>
        <tag>SAM</tag>
        <tag>字符串</tag>
        <tag>CTSC</tag>
        <tag>后缀树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Regular Contest #096E]Everything on It 题解]]></title>
    <url>%2Fblog%2Farc096e%2F</url>
    <content type="text"><![CDATA[Problem StatementIn “Takahashi-ya”, a ramen restaurant, basically they have one menu: “ramen”, but N kinds of toppings are also offered. When a customer orders a bowl of ramen, for each kind of topping, he/she can choose whether to put it on top of his/her ramen or not. There is no limit on the number of toppings, and it is allowed to have all kinds of toppings or no topping at all. That is, considering the combination of the toppings, $2^N$ types of ramen can be ordered. Akaki entered Takahashi-ya. She is thinking of ordering some bowls of ramen that satisfy both of the following two conditions: Do not order multiple bowls of ramen with the exactly same set of toppings.Each of the N kinds of toppings is on two or more bowls of ramen ordered.You are given N and a prime number M. Find the number of the sets of bowls of ramen that satisfy these conditions, disregarding order, modulo M. Since she is in extreme hunger, ordering any number of bowls of ramen is fine. Constraints 2≤N≤3000 1e8≤M≤1e9+9 N is an integer. M is a prime number. Subscores600 points will be awarded for passing the test set satisfying N≤50. InputInput is given from Standard Input in the following format: N M OutputPrint the number of the sets of bowls of ramen that satisfy the conditions, disregarding order, modulo M. Sample Input 12 1000000007 Sample Output 12 Let the two kinds of toppings be A and B. Four types of ramen can be ordered: “no toppings”, “with A”, “with B” and “with A, B”. There are two sets of ramen that satisfy the conditions: The following three ramen: “with A”, “with B”, “with A, B”. Four ramen, one for each type. Sample Input 23 1000000009 Sample Output 2118 Let the three kinds of toppings be A, B and C. In addition to the four types of ramen above, four more types of ramen can be ordered, where C is added to the above four. There are 118 sets of ramen that satisfy the conditions, and here are some of them: The following three ramen: “with A, B”, “with A, C”, “with B, C”. The following five ramen: “no toppings”, “with A”, “with A, B”, “with B, C”, “with A, B, C”. Eight ramen, one for each type. Note that the set of the following three does not satisfy the condition: “‘with A’, ‘with B’, ‘with A, B’”, because C is not on any of them. Sample Input 350 111111113 Sample Output 31456748 Remember to print the number of the sets modulo M. Note that these three sample inputs above are included in the test set for the partial score. Sample Input 43000 123456791 Sample Output 416369789 This sample input is not included in the test set for the partial score. Solution注意到拉面的碗数是不固定的，所以从拉面的碗数的角度考虑不好做。 考虑根据每种配料容斥。由题意得，一种配料是坏的，当且仅当它只出现了0或1次，我们枚举有几种配料是坏的，则$$ans=\sum_{i=0}^n(-1)^iC_n^if(i)$$其中$f(i)$表示有$i$种配料是坏的，其他的随意的方案数。 考虑如何计算$f(i)$。枚举这$i$种配料一共加到了$j$碗面中，则$$f(i)=2^{2^{n-i}}\sum_{j=0}^{i}g[i][j]*(2^{j})^{n-i}$$其中$g[i][j]$表示将$i$中坏的配料加入$j$碗面的方案数,考虑剩下的$n-i$中配料如何加入面中，对于每种配料来说，每一碗面都可以放或者不放，是$2^j$种方案，$(n-i)$种配料就是$(2^j)^{n-i}$,再考虑这$j$碗面以外的面，这些面中除了$j$中坏的配料其他的配料都可以放或不放，所以一共有$2^{n-i}$种可行的面，每一种面都可以选择加入或者不加入我的集合当中，所以共有$2^{2^{n-i}}$种情况。 最后考虑$g[i][j]$怎么求，我们发现是将$i$种配料放入$j$碗面中且要求没有面非空，这个定义非常像第二类斯特林数，但这里每种配料还可以选择不在任意一碗中出现，所以稍稍魔改一下第二类斯特林数的递推式，得到$$g[i][j]=g[i-1][j-1]+g[i-1][j]*(j+1)$$注意和第二类斯特林数不一样的是最后乘的是$(j+1)$而不是$j$，因为如果$j$碗面中都有配料了，最后一种配料可以选择不加，多一种情况。 总时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=3000;int n,M;int s[MAXN+48][MAXN+48];inline void init_stirling()&#123; s[0][0]=1; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=i;j++) s[i][j]=add(s[i-1][j-1]+1ll*j*s[i-1][j]%M,M);&#125;int c[MAXN+48][MAXN+48];inline void init_c()&#123; c[0][0]=1; for (register int i=1;i&lt;=n;i++) &#123; c[i][0]=c[i][i]=1; for (register int j=1;j&lt;=i-1;j++) c[i][j]=add(c[i-1][j-1]+c[i-1][j],M); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(M); init_stirling();init_c();int ans=0; for (register int i=0;i&lt;=n;i++) &#123; int pw1=quick_pow(2,quick_pow(2,n-i,M-1),M); int pw2=quick_pow(2,n-i,M),pw=1; for (register int j=0;j&lt;=i;j++) &#123; int res=1ll*add(1ll*(j+1)*s[i][j+1]%M+s[i][j],M)*pw%M*pw1%M*c[n][i]%M; if (i&amp;1) Sub(ans,res,M); else Add(ans,res,M); pw=1ll*pw*pw2%M; &#125; &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>斯特林数</category>
        <category>第二类斯特林数</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>第二类斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2541][PKUWC2018]猎人杀 题解]]></title>
    <url>%2Fblog%2Floj2541%2F</url>
    <content type="text"><![CDATA[Description猎人杀是一款风靡一时的游戏“狼人杀”的民间版本，他的规则是这样的： 一开始有 $n$ 个猎人，第 $i$ 个猎人有仇恨度 $w_i$，每个猎人只有一个固定的技能：死亡后必须开一枪，且被射中的人也会死亡。 然而向谁开枪也是有讲究的，假设当前还活着的猎人有 $[i_1\ldots i_m]$[i ，那么有 $\frac{w_{i_k}}{\sum\limits_{j = 1}^{m} w_{i_j}}$的概率是向猎人 $i_k$ 开枪。 一开始第一枪由你打响，目标的选择方法和猎人一样（即有 $\frac{w_i}{\sum\limits_{j=1}^{n}w_j}$ 的概率射中第 $i$ 个猎人）。由于开枪导致的连锁反应，所有猎人最终都会死亡，现在 $1$ 号猎人想知道它是最后一个死的的概率。 答案对 $998244353$ 取模。 Constraints$w_i&gt;0,1\leq \sum_{i=1}^nw_i\leq 100000$ Solution考虑容斥，每次钦定一个集合$S$,令$p(S)$表示要求$S$内的猎人必须在$1$之后死亡，容斥系数显然是$(-1)^{\mid S\mid}$，则$$ans=\sum_S(-1)^{\mid S\mid}p(S)$$ 考虑怎么算$p(S)$,首先有一个很烦的点是每次击杀一个猎人之后，概率的分母会变，从而很不好算。 令$W=\sum_{i=1}^nw_i$,$B=\sum_{i\in dead}w_i$,则第$i$个人下一轮被射杀的概率是$p_i=\frac{w_i}{W-B}$。考虑一个新的规则，每次猎人可以打活人也可以打死人，如打到了死人就可以免费再打一次，直到打到活人为止。设这种情况下$p_i’$表示第$i$个人下一轮被射杀的概率，则$p_i’=\frac{B}{W}p_i’+\frac{w_i}{W}$,其中第一项表示如果打到死人概率还是$p_i’$。解这个方程得$p_i’=\frac{w_i}{W-B}$,所以这两个规则是等价的。 这样我们每次的分母都是一样的，令$sum(S)=\sum_{i\in S}w_i$,写出$p(S)$的表达式：$$p(S)=\sum_{i=0}^{\infty}(1-\frac{w_1+sum(S)}{W})^{i}\cdot \frac{w_1}{W}$$ 把$\frac{w_1}{W}$提出来，剩余部分是一个无穷级数。考虑到$1-\frac{w_1+sum(S)}{W}\in(0,1)$，所以它是收敛的，根据$\sum_{i=0}^{\infty}x^i=\frac{1}{1-x}$，得到$$p(S)=\frac{w_1}{W}\frac{1}{1-(1-\frac{w_1+sum(S)}{W})}=\frac{w_1}{w_1+sum(S)}$$ $$ans=w_1\sum_S\frac{(-1)^{\mid S\mid}}{w_1+sum(S)}$$ 我们已经极大地化简了此式，注意到范围中$\sum w_i$较小，考虑背包。$dp[i][j][0/1]$表示当前考虑到第$i$个数字，选择的$sum(S)=j$,当前选择的数字个数是奇数还是偶数的情况下的方案数。 这样做复杂度是$O(nW)$的，不足以通过。但是01背包有喜闻乐见的基于生成函数的优化方法。 对于第$i$个物品，考虑令$f_i(x)=1-x^{w_i}$，注意这个负号很好地模拟了容斥，奇数个-1相乘是-1，偶数个则是1。所以$\Pi_{i=1}^nf_i(x)$这个多项式中,$x^i$的系数就是所有满足$sum(S)=i$的$S$的容斥系数的和。 上述的$\Pi$可以用分治NTT优化，从而复杂度降到$O(nlognlogW)$，可以通过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;const int NTT_MAX=8e5;int n,w[MAXN+48],sum[MAXN+48];namespace polynomial&#123; const int G=3; int wpos[NTT_MAX+48],wneg[NTT_MAX+48];bool done=false; inline void poly_init() &#123; done=true; for (register int clen=2;clen&lt;=262144*2;clen&lt;&lt;=1) wpos[clen]=quick_pow(G,(MOD-1)/clen),wneg[clen]=quick_pow(G,(MOD-1)-(MOD-1)/clen); &#125; int w[NTT_MAX+48]; inline void poly_ntt(int c[],int len,int fl) &#123; int i,j,k; for (i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; int wn=(fl==1?wpos[clen]:wneg[clen]); w[0]=1;for (register int i=1;i&lt;=(clen&gt;&gt;1);i++) w[i]=1ll*w[i-1]*wn%MOD; for (j=0;j&lt;len;j+=clen) for (k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; int tmp1=c[k],tmp2=1ll*c[k+(clen&gt;&gt;1)]*w[k-j]%MOD; c[k]=add(tmp1+tmp2);c[k+(clen&gt;&gt;1)]=sub(tmp1-tmp2); &#125; &#125; if (fl==-1) &#123; int ilen=quick_pow(len,MOD-2); for (i=0;i&lt;len;i++) c[i]=1ll*c[i]*ilen%MOD; &#125; &#125; inline void poly_mul(int A[],int B[],int n,int m) &#123; if (!done) poly_init(); int len=1;while (len&lt;=n+m) len&lt;&lt;=1; memset(A+n,0,(len-n)*sizeof(int)); memset(B+m,0,(len-m)*sizeof(int)); poly_ntt(A,len,1);poly_ntt(B,len,1); for (register int i=0;i&lt;len;i++) A[i]=1ll*A[i]*B[i]%MOD; poly_ntt(A,len,-1); &#125;&#125;int tmp[NTT_MAX+48],A[NTT_MAX+48],B[NTT_MAX+48];inline void solve(int left,int right)&#123; if (left==right) &#123; memset(tmp,0,(w[left]+1)*sizeof(int)); tmp[0]=1;tmp[w[left]]=MOD-1;return; &#125; int mid=(left+right)&gt;&gt;1,N=sum[mid]-sum[left-1]+1,M=sum[right]-sum[mid]+1; int len=1;while (len&lt;=N+M) len&lt;&lt;=1; int Tmp[len+48]; solve(left,mid);memcpy(Tmp,tmp,N*sizeof(int)); solve(mid+1,right); memcpy(A,Tmp,N*sizeof(int));memcpy(B,tmp,M*sizeof(int)); polynomial::poly_mul(A,B,N,M); memcpy(tmp,A,len*sizeof(int));&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(w[i]); sum[1]=0;for (register int i=2;i&lt;=n;i++) sum[i]=sum[i-1]+w[i]; solve(2,n);int ans=0; for (register int i=0;i&lt;=sum[n];i++) Add(ans,1ll*A[i]*quick_pow(w[1]+i,MOD-2)%MOD); ans=1ll*ans*w[1]%MOD;printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>分治</category>
        <category>生成函数</category>
        <category>多项式</category>
        <category>NTT</category>
        <category>背包</category>
        <category>普通型生成函数</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>LOJ</tag>
        <tag>PKUWC</tag>
        <tag>分治NTT</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记]Min-Max容斥]]></title>
    <url>%2Fblog%2Fmin-max%2F</url>
    <content type="text"><![CDATA[规定$Max(S)$表示集合$S$中最大的元素，$Min(S)$表示集合$S$中最小的元素，$\mid S\mid$表示集合$S$的大小。 Min-Max容斥的公式如下：$$Max(S)=\sum_{T\subseteq S}(-1)^{\mid T\mid +1}Min(T)$$ 证明： 首先证明一个引理：对于$\forall n&gt;0$，$\sum_{i=0}^n(-1)^iC_n^i=0$ 证明：$\sum_{i=0}^n(-1)^iC_n^i=C_n^0+C_n^n+\sum_{i=1}^{n-1}(-1)^i(C_{n-1}^{i-1}+C_{n-1}^i)=C_n^0+C_n^n-C_{n-1}^0-C_{n-1}^{n-1}=0$ &nbsp; $\blacktriangle$ 不妨设$S$中的元素是有序的，即对于$\forall i&lt;j$,有$a_i&lt;=a_j$ 考虑每个元素作为最小值的贡献，可以将Min-Max容斥的结果写成$$\sum_{i=1}^na_i\sum_{j=0}^{n-i}(-1)^jC_{n-i}^j$$ 注意$j$和$\mid T\mid$正好相差2(最小值$a_i$被单独拎了出来),所以直接写$(-1)^j$是对的。 根据引理，只有当$n-i=0$，即$i=n$时后面一半不是0,所以原式等于$a_n$ &nbsp; $\blacktriangle$]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>Min-Max容斥</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Min-Max容斥</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM664DIV1A]BearPlays 题解]]></title>
    <url>%2Fblog%2Ftcsrm664div1a%2F</url>
    <content type="text"><![CDATA[Problem StatementLimak is a little bear who loves to play. Today he is playing by moving some stones between two piles of stones. Initially, one of the piles has A and the other has B stones in it. Limak has decided to perform a sequence of K operations. In each operation he will double the size of the currently smaller pile. Formally, if the current pile sizes are labeled X and Y in such a way that X &lt;= Y, he will move X stones from the second pile to the first one. After this move the new pile sizes will be X+X and Y-X. You are given the ints A, B, and K. Determine the pile sizes after Limak finishes all his operations. Return the size of the smaller of those piles. Formally, suppose that the final pile sizes are labeled P and Q in such a way that P &lt;= Q. Return P. DefinitionClass: BearPlays Method: pileSize Parameters: int, int, int Returns: int Method signature: int pileSize(int A, int B, int K)(be sure your method is public) Notes Pay attention to the unusual time limit. Constraints A and B will be between 1 and 1,000,000,000, inclusive. K will be between 1 and 2,000,000,000, inclusive. Examples0) 4 7 2 Returns: 5 The process will look as follows: Initially, the pile sizes are 4 and 7. First operation: Limak doubles the pile of size 4 by moving 4 stones from the other pile to this pile. The new pile sizes are 8 and 3. Second operation: Limak doubles the pile of size 3. The final pile sizes are 5 and 6. As 5 &lt;= 6, the correct return value is 5. 1) 5 5 3 Returns: 0 The initial pile sizes are 5 and 5. In the first operation Limak will double one of them, so after the operation the new pile sizes will be 10 and 0. The second and third operation do nothing: in each of them Limak doubles the size of an empty pile. As 0 ≤ 10, the correct return value is 0. 2) 2 6 1 Returns: 4 After the only operation the pile sizes will be 4 and 4, hence the correct return value is 4. 3) 2 8 2000000000 Returns: 2 4) 900000000 350000000 3 Returns: 300000000 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution数学神思维题 首先的性质是$x+y$的和不会变，设$x+y=n$ 考虑如果当前$x\leq y$,则$x=2x$ 如果当前$x\ge y$,则$x=x-y=2x-(x+y)=2x-n\equiv 2x(mod$ &nbsp; $n)$ 综上，进行$k$轮之后,$x\equiv x*2^k(mod$ &nbsp; $n)$ 所以算出这个，返回$min(x,n-x)$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;class BearPlays&#123; int n; inline int quick_pow(int x,int y) &#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%n,y--; x=(1ll*x*x)%n;y&gt;&gt;=1; &#125; return res; &#125; public: inline int pileSize(int x,int y,int k) &#123; n=x+y; x=(1ll*x*quick_pow(2,k))%n; return min(x,n-x); &#125;&#125;;#ifdef LOCALint main ()&#123; freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); BearPlays A; int nn,mm,kk; while (cin&gt;&gt;nn&gt;&gt;mm&gt;&gt;kk) cout&lt;&lt;A.pileSize(nn,mm,kk)&lt;&lt;endl; return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #270][六校联合训练 #9]菊凯的疑惑 题解]]></title>
    <url>%2Fblog%2Fnflsoj270%2F</url>
    <content type="text"><![CDATA[Description有一棵 $n$ 个节点的树，你将从任意一个点出发开始随机游走。具体来说，在点 $u$ 的每个单位时间内，你将会有 $p_u$ 的概率留在原地，有 $1−p_u$ 的概率等概率的向相邻的点移动，直到移动到 $1$ 号点才停下。 现在询问从每个点出发直至停下，所花费的时间的 $k$ 次方的期望。 可以证明，答案可以被表示成 $q\times p^{−1}$ 的形式，你需要输出一个正整数 $ans$，使得 $ans\equiv q\times p^{−1}(mod$&nbsp; $998244353)$。保证 $p$ 将不会是 $998244353$ 的倍数。 Input Format第一行两个整数 $n$ 和 $k$，含义如题目所示。 接下来 $n−1$ 行，每行两个整数 $u$,$v$,代表一条树边。 接下来一行，$n−1$ 个整数，第 $i$ 个数为 $p′{i+1}$。$p{i+1}=p′_{i+1}\times 10^{−6}$ ,代表留在原地的概率。 Output Format输出 $n−1$ 行，第 $i$ 个输出表示从 $i+1$ 号点出发直至停下，所花费的时间的 $k$ 次方的期望。 Constraints 对于 15% 的数据，n,k≤10。 对于 30% 的数据，n,k≤50。 对于 50% 的数据，n≤1000，k≤100。 对于另外 5% 的数据，保证 k=0。 对于另外 15% 的数据，保证 k=1。 对于另外 15% 的数据，保证 pi=0。 对于 95% 的数据，k≤1000。 对于 100% 的数据，保证 1≤n≤1e5，0≤k≤1e5，n⋅k≤1e6，0≤p′i&lt;1e60。 Solution这果真是noip模拟题 一个显然的思路是树型dp,我们令$f_{u,i}$表示从$u$出发到根的路径长度的$i$次方的期望。(注意这个和长度期望的$i$次方是两码事) 我们先考虑简单的情况，$i=1$时怎么做。 可以轻易地列出状态转移方程(其中$deg_u$表示节点$u$的度数)$$f_{u,1}=p_u(f_{u,1}+1)+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}(f_{v,1}+1)$$ 注意到这个方程既要从孩子转移来也要从父亲转移来，所以没有明显的阶段性，需要高斯消元。针对树上的高斯消元有树上高消的黑科技可以在线性时间内解出所有的变量，后面再讲。 接下来考虑一般的情况，一个比较显然的想法是利用二项式定理展开，就是暴力展开$(f_{u,i}+1)^k$类似的东西，注意展开后的每一项都要用对应的次方的期望。这样我们可以得到状态转移方程$$f_{u,i}=\sum_{j=0}^i\binom{i}{j}(p_uf_{u,j}+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,j})$$ 这样我们可以$O(k)$的转移，加上$O(nk)$个状态，总时间复杂度是$O(nk^2)$，大概可以拿70分。 然后就不会了 接下来的部分比较神奇 考虑如下等式 $$x^k=\sum_{j=0}^{k}\binom{x}{j}S(k,j)j!$$ 其中$S(k,j)$表示第二类斯特林数。 可以这样简证上述等式的正确性：等式的左边可以看做将$k$个不同的球放入$x$个不同的盒子中,每个球都有$x$种放法所以是$x^k$，右边可以看做先枚举有$j$个盒子是有球的，从$x$个盒子中先选出$j$个盒子保证非空，然后假装这$j$个盒子是不可分辨的，那么将球放入的方案数就是第二类斯特林数，最后再乘上$j$个盒子的排列数。 有了这个式子我们发现，我们令$x^k$表示从某一点出发到根的时间的$k$次方的期望，我们只要求出所有的$\binom{x}{i}$的期望就可以了。 我们修改之前定义的状态，令$f_{u,i}$表示从$u$出发到根，所用时间$t$的$\binom{t}{i}$的期望。我们发现组合数有一个非常好的性质：$\binom{t}{i}=\binom{t-1}{i}+\binom{t-1}{i-1}$，这就比二项式定理的递推要很多，因为我们的递推式只有两项，转移的复杂度从$O(k)$降到了$O(1)$。 写出新的状态转移方程：$$f_{u,i}=p_u(f_{u,i}+f_{u,i-1})+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E} (f_{v,i}+f_{v,i-1})$$ 是时候来化成可以树上高消的形式了我们先拆拆括号移项整理，可得$$(1-p_u)f_{u,i}=\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,i}+p_uf_{u,i-1}+\frac{(1-p_u)}{deg_u}\sum_{(u,v)\in E}f_{v,i-1}$$$$f_{u,i}=\frac{\sum_{(u,v)\in E}f_{v,i}}{deg_u}+\frac{p_u}{1-p_u}f_{u,i-1}+\frac{\sum_{(u,v)\in E}f_{v,i-1}}{deg_u}$$ 由于我们是按$i$从小到大递推的，所以所有下标为$i-1$的项都是已知项，为了简化表达，我们令$$g_{u,i}=\frac{p_u}{1-p_u}f_{u,i-1}+\frac{\sum_{(u,v)\in E}f_{v,i-1}}{deg_u}$$ 则原式可以写成$$f_{u,i}=\frac{\sum_{(u,v)\in E}f_{v,i}}{deg_u}+g_{u,i}$$ 上式中所有的$v$里面有一个是$u$的父亲(我们暂时不考虑根节点),其他的都是$u$的儿子，我们把父亲单独提出来:$$f_{u,i}=\frac{\sum_{v\in son_u}f_{v,i}}{deg_u}+\frac{f_{fa_u,i}}{deg_u}+g_{u,i}$$ 稍微想一下可以知道，所有的叶节点是没有儿子的，所以它们的$f$值只和父亲相关，倒数第二层的节点，它们的孩子都是叶子节点，可以用它们自己来表示，所以它们也只和父亲相关……依次类推，每个节点的$f$值都是关于父亲的$f$值的一次函数，设$f_{u,i}=k_uf_{fa_u,i}+b_u$，我们要推出$k_u$和$b_u$的表达式。 对于上式，我们把所有的$f_{v,i}$换成$k_vf_{u,i}+b_v$,有$$f_{u,i}=\frac{\sum_{v\in son_u}(k_vf_{u,i}+b_v)}{deg_u}+\frac{f_{fa_u,i}}{deg_u}+g_{u,i}$$ $$(1-\frac{\sum_{v\in son_u}k_v}{deg_u})f_{u,i}=\frac{f_{fa_u,i}}{deg_u}+g_{u,i}+\frac{\sum_{v\in son_u}b_v}{deg_u}$$ $$f_{u,i}=\frac{1}{deg_u-\sum_{v\in son_u}k_v}f_{fa_u,i}+\frac{\sum_{v\in son_u}b_v+deg_ug_{u,i}}{deg_u-\sum_{v\in son_u}k_v}$$ 所以$$ k_u = \frac{1}{deg_u-\sum_{v\in son_u}k_v}$$$$ b_u = \frac{\sum_{v\in son_u}b_v+deg_ug_{u,i}}{deg_u-\sum_{v\in son_u}k_v}$$ 这样只要从下到上算一遍$k_u$和$b_u$，再根据$f_{root,i}=0$从上到下推一遍就解出了所有的未知数。 这样可以得到95分，还有一个问题是暴力推第二类斯特林数是$O(n^2)$的。这里有一个喜闻乐见的多项式做法。 考虑第二类斯特林数的通项公式:$$S(n,k)=\frac{1}{k!}\sum_{i=0}^k(-1)^i\binom{k}{i}(k-i)^n$$ 这个公式是基于容斥的，考虑枚举至少有$i$个盒子是空的，从$k$个盒子中选出$i$个空盒子是$\binom{k}{i}$，$n$个球每个球有$(k-i)$种放置方案，可得到上式。 对式子做一些变换$$S(n,k) = \frac{1}{k!}\sum_{i=0}^k(-1)^i(k-i)^n\frac{k!}{i!(k-i)!}= \sum_{i=0}^k\frac{(k-i)^n}{(k-i)!}\frac{(-1)^i}{i!}$$ 这显然是一个卷积的形式，用$NTT$加速即可做到$O(klogk)$ 总时间复杂度$O(nk+klogk)$ 终于完结撒花了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=4e5;namespace polynomial&#123; const int G=3; const int NTT_MAX=8e5; int wn_pos[NTT_MAX+48],wn_neg[NTT_MAX+48]; inline void poly_init() &#123; for (register int clen=2;clen&lt;=524288;clen&lt;&lt;=1) wn_pos[clen]=quick_pow(G,(MOD-1)/clen),wn_neg[clen]=quick_pow(G,(MOD-1)-(MOD-1)/clen); &#125; inline void poly_ntt(int c[],int len,int fl) &#123; int i,j,k; for (i=(len&gt;&gt;1),j=1;j&lt;len;j++) &#123; if (i&lt;j) swap(c[i],c[j]); for (k=(len&gt;&gt;1);i&amp;k;k&gt;&gt;=1) i^=k;i^=k; &#125; for (register int clen=2;clen&lt;=len;clen&lt;&lt;=1) &#123; int wn=(fl==1?wn_pos[clen]:wn_neg[clen]); for (j=0;j&lt;len;j+=clen) &#123; int w=1; for (k=j;k&lt;j+(clen&gt;&gt;1);k++) &#123; int tmp1=c[k],tmp2=1ll*c[k+(clen&gt;&gt;1)]*w%MOD; c[k]=add(tmp1+tmp2);c[k+(clen&gt;&gt;1)]=sub(tmp1-tmp2); w=1ll*w*wn%MOD; &#125; &#125; &#125; if (fl==-1) &#123; int ilen=quick_pow(len,MOD-2); for (i=0;i&lt;len;i++) c[i]=1ll*c[i]*ilen%MOD; &#125; &#125; inline void poly_mul(int A[],int B[],int n,int m,int C[]) &#123; int len=1;while (len&lt;=n+m) len&lt;&lt;=1; memset(A+n,0,(len-n)*sizeof(int)); memset(B+m,0,(len-m)*sizeof(int)); poly_ntt(A,len,1);poly_ntt(B,len,1); for (register int i=0;i&lt;len;i++) C[i]=1ll*A[i]*B[i]%MOD; poly_ntt(C,len,-1); &#125;&#125;int fac[MAXN+48],ifac[MAXN+48];inline void init_fac()&#123; fac[0]=1;for (register int i=1;i&lt;=MAXN;i++) fac[i]=1ll*fac[i-1]*i%MOD; ifac[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;&#125;int A[MAXN+48],B[MAXN+48],s[MAXN+48];int n,k;vector&lt;int&gt; v[MAXN+48];int d[MAXN+48],p[MAXN+48],dinv[MAXN+48],pinv[MAXN+48];vector&lt;int&gt; f[MAXN+48];int g[MAXN+48];int K[MAXN+48],b[MAXN+48];inline void dfs(int cur,int father)&#123; int ksum=0,bsum=0; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) dfs(y,cur),Add(ksum,K[y]),Add(bsum,b[y]); &#125; K[cur]=quick_pow(sub(d[cur]-ksum),MOD-2); b[cur]=add(1ll*K[cur]*bsum%MOD+1ll*K[cur]*d[cur]%MOD*g[cur]%MOD);&#125;inline void Dfs(int cur,int father,int step)&#123; if (cur==1) f[cur][step]=0; else f[cur][step]=add(b[cur]+1ll*K[cur]*f[father][step]%MOD); for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) Dfs(y,cur,step); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif polynomial::poly_init();init_fac(); io.Get(n);io.Get(k);int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x);d[x]++;d[y]++; &#125; int Inv=quick_pow(int(1e6),MOD-2); for (register int i=2;i&lt;=n;i++) io.Get(p[i]),p[i]=1ll*p[i]*Inv%MOD; for (register int i=1;i&lt;=n;i++) dinv[i]=quick_pow(d[i],MOD-2),pinv[i]=quick_pow(p[i],MOD-2); for (register int i=1;i&lt;=n;i++) f[i].resize(k+10,0),f[i][0]=1; for (register int i=1;i&lt;=k;i++) &#123; for (register int j=2;j&lt;=n;j++) &#123; g[j]=1ll*p[j]*quick_pow(sub(1-p[j]),MOD-2)%MOD*f[j][i-1]%MOD; for (auto y : v[j]) Add(g[j],1ll*f[y][i-1]*dinv[j]%MOD); &#125; dfs(1,-1);Dfs(1,-1,i); &#125; for (register int i=0;i&lt;=k;i++) A[i]=1ll*ifac[i]*((i&amp;1)?(MOD-1):1)%MOD; for (register int i=0;i&lt;=k;i++) B[i]=1ll*ifac[i]*quick_pow(i,k)%MOD; polynomial::poly_mul(A,B,k+1,k+1,s); for (register int i=0;i&lt;=k;i++) s[i]=1ll*s[i]*fac[i]%MOD; for (register int i=2;i&lt;=n;i++) &#123; int ans=0; for (register int j=0;j&lt;=k;j++) Add(ans,1ll*f[i][j]*s[j]%MOD); printf("%d\n",ans); &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数学</category>
        <category>容斥原理</category>
        <category>树型dp</category>
        <category>多项式</category>
        <category>高斯消元</category>
        <category>NTT</category>
        <category>树上高消</category>
        <category>斯特林数</category>
        <category>第二类斯特林数</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>第二类斯特林数</tag>
        <tag>NFLSoj</tag>
        <tag>树型dp</tag>
        <tag>树上高消</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Grand Contest 011E]Increasing Numbers 题解]]></title>
    <url>%2Fblog%2Fagc011e%2F</url>
    <content type="text"><![CDATA[Problem StatementWe will call a non-negative integer increasing if, for any two adjacent digits in its decimal representation, the digit to the right is greater than or equal to the digit to the left. For example, 1558, 11, 3 and 0 are all increasing; 10 and 20170312 are not. Snuke has an integer N. Find the minimum number of increasing integers that can represent N as their sum. Constraints $1 \leq N \leq 10500000$ InputThe input is given from Standard Input in the following format: N OutputPrint the minimum number of increasing integers that can represent N as their sum. Sample Input 180 Sample Output 12 One possible representation is 80=77+3. Sample Input 2123456789 Sample Output 21 123456789 in itself is increasing, and thus it can be represented as the sum of one increasing integer. Sample Input 320170312 Sample Output 34 Sample Input 47204647845201772120166980358816078279571541735614841625060678056933503 Sample Output 431 Solution很神的一道题 首先我们可以发现一个性质：任何一个好数都可以拆成不超过9个全1数的和，更贴切地说，任何一个好数可以拆成它个位数个全1数的和。 因此我们想到一个方向：我们试图将原数$N$分解成尽可能少的全1数的和，然后每9个全1数我们都能将其合成一个好数，这样就能用最少的好数组成$N$。换句话来说，一个数$N$能表示成$k$个好数的和，当且仅当它能被表示成$9k$个全1数的和。 接下来是非常关键神奇的一步 对于一个全1数$\underbrace{11\dots 1}_{x个}$，我们可以将其表示为$\frac{10^x-1}{9}$ 这样假设$N$可以被表示成$k$个全1数，第$i$个数的长度是$a_i$，我们有如下等式：$$\sum_{i=1}^{9k}\frac{10^{a_i}-1}{9}=N$$ 移项，可得$$\sum_{i=1}^{9k}10^{a_i}=9N+9k$$ 我们发现左边的东西是一些10的次幂相加，而一个数要分解成若干个10的次幂相加的形式，最少需要的就是数字和个10的次幂。因此我们判断一个数$N$能否表示成$k$个全1数的和，只要判断$9N+9k$的数字和是否小于等于$9k$。 记$N$的位数是$L$,这样我们可以在$O(L)$的时间内check一个答案，注意到答案具有单调性，所以可以二分答案，这样复杂度是$O(LlogL)$。 事实上有一个更简单的线性做法：我们不用二分答案，只要从小到大枚举答案即可，每次我们给目标数+9即可，这样每轮均摊的进位次数是$O(1)$的，在进位的时候动态更新一下数字和即可，复杂度$O(L)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e6;int len;char s[MAXN+48];int b[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);len=strlen(s+1); for (register int i=len,j=1;i&gt;=1;i--,j++) b[j]=s[i]-'0'; for (register int i=1;i&lt;=len;i++) b[i]*=9; for (register int i=1;i&lt;=len;i++) b[i+1]+=b[i]/10,b[i]%=10; if (b[len+1]) len++; int sum=0;for (register int i=1;i&lt;=len;i++) sum+=b[i]; for (register int ans=1;;++ans) &#123; sum-=b[1];b[1]+=9;int pt=1; while (b[pt]&gt;9) sum-=b[pt+1],b[pt+1]+=b[pt]/10,b[pt]%=10,pt++; for (register int i=1;i&lt;=pt;i++) sum+=b[i]; if (sum&lt;=9*ans) &#123;printf("%d\n",ans);return 0;&#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #294]c 题解]]></title>
    <url>%2Fblog%2Fnflsoj294%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点,带边权的树。 有$m$次询问,每次给出$x$, $y$,求最小的非负整数$s$,满足树上$x$到$y$路径上的边权都不等于$s$。 Input Format第一行共两个正整数$n$, $m$,分别表示点数和询问数。 接下来$n − 1$行,每行共3个正整数$x$, $y$, $v$,分别表示有一条连接$x$,$y$,边权为$v$的边。 接下来$m$行,每行共2个正整数$x$, $y$,表示询问的两个顶点。 Output Format对于每一个询问输出一行,共一个非负整数表示这次询问的答案。 Sample Input 7 6 2 1 1 3 1 2 1 4 0 4 5 1 5 6 3 5 7 4 1 3 4 1 2 4 2 5 3 5 3 7 Sample Output 0 1 2 2 3 3 Constraints 对于$40\%$ 的数据,$n, m \leq 1000$, $0 \leq v \leq 100$。 另有$20\%$ 的数据,满足输入的树是一条链。 另有$30\%$ 的数据,满足$0 \leq v \leq 1$。 对于$100\%$ 的数据,$n, m \leq 100000$, $0 \leq v \leq 100000$。 Solution这种求$mex$的问题无法高效地用数据结构维护，考虑莫队。 我们先考虑如果树是一条链的情况。这时就是一个普通的序列莫队。一个朴素的想法是用一个BIT来维护每种数是否出现过，如果增加操作中$cnt=1$就加入BIT,如果减少操作中$cnt=0$就从BIT中删掉。查询的时候只要在BIT中二分就可以了，用类似线段树二分的方法这部分可以做到一个log,通过合理选取块的大小，该算法的复杂度可以做到$O(n\sqrt{nlogn}+mlogn)$ 这个做法有一定几率被卡常，考虑如何把根号下的log去掉。我们注意到在莫队的端点移动过程中，总共会有$n\sqrt n$次加入和删除操作，而查询操作只有$m$次，所以我们应该设法用减少插入删除的复杂度，增加查询复杂度的方式来平衡两边的复杂度。 考虑分块，我们对每一个块，记录$bucket[i]$表示第$i$个块中有多少个数存在。插入删除的时候我们只要维护cnt和对应的bucket即可，复杂度为$O(1)$，查询的时候，我们先找到第一个有空缺的bucket,再在bucket中暴力查找第一个空缺的数，时间复杂度$O(\sqrt n)$，这样总复杂度降到$O((m+n)\sqrt n)$,可以比较轻松地通过。 现在考虑树上的情况，我们可以把序列莫队变成树上莫队。有关路径查询的树上莫队有一种非常神的做法。 我们考虑维护这棵树的欧拉dfs序（即进入子树和出子树的时候都加入序列）,这样对于每个节点$i$我们有一个$st[i]$表示它在序列中的第一次出现位置和一个$ed[i]$表示它在序列中的第二次出现位置。我们注意到对于树上的一条链$(u,v)$，不妨设$st[u]&lt;st[v]$，则dfs序中的$[ed[u],st[v]]$这个区间，$(u,v)$上的点会在区间中出现1次，之外的点会出现0次或两次，所以我们在dfs序上莫队的时候只要记录一个每个点的visited数组，如果没有visited就insert,否则就delete即可。 注意几个特殊情况： 当$u$是$v$的祖先的时候，上述的区间是不对的，显然我们应该用$[st[u],st[v]]$这个区间。 当$u$不是$v$的祖先的时候，上述的做法没有包含$lca(u,v)$，所以最后要单独将$lca(u,v)$加入一下。 本题中可以将边权赋给对应的儿子节点，从而在查询一条链的时候$lca$的权值不在路径内，上述的情况2就不用考虑了，情况一要注意将区间改为$[st[u]+1,st[v]]$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];int st[MAXN+48],ed[MAXN+48],seq[MAXN*2+48],val[MAXN+48],ind;int anc[MAXN+48][21],depth[MAXN+48];int cnt[MAXN+48],bucket[MAXN+48],N;inline int calc()&#123; int tar=N; for (register int i=1;i&lt;=N-1;i++) if (bucket[i]&lt;magic) &#123;tar=i;break;&#125; for (register int i=(tar-1)*magic;i&lt;=tar*magic-1;i++) if (!cnt[i]) return i;&#125;inline void dfs(int cur,int father)&#123; st[cur]=++ind;seq[ind]=cur; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i].x; if (y!=father) &#123; depth[y]=depth[cur]+1;val[y]=v[cur][i].y; anc[y][0]=cur; for (register int j=1;j&lt;=17;j++) anc[y][j]=anc[anc[y][j-1]][j-1]; dfs(y,cur); &#125; &#125; ed[cur]=++ind;seq[ind]=cur;&#125;inline int getlca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); for (register int i=17;i&gt;=0;i--) if (depth[anc[u][i]]&gt;=depth[v]) u=anc[u][i]; if (u==v) return u; for (register int i=17;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) u=anc[u][i],v=anc[v][i]; return anc[u][0];&#125;struct node&#123; int u,v,ind; inline void input() &#123;io.Get(u);io.Get(v);&#125; inline bool operator &lt; (const node &amp;other) const &#123; if (u/magic!=other.u/magic) return u/magic&lt;other.u/magic; return v&lt;other.v; &#125;&#125;q[MAXN+48];bool visited[MAXN+48];int fans[MAXN+48];inline void ins(int cur)&#123; cnt[val[cur]]++; if (cnt[val[cur]]==1) bucket[val[cur]/magic+1]++;&#125;inline void del(int cur)&#123; cnt[val[cur]]--; if (!cnt[val[cur]]) bucket[val[cur]/magic+1]--;&#125;inline void doit(int pos)&#123; if (!visited[seq[pos]]) visited[seq[pos]]=true,ins(seq[pos]); else visited[seq[pos]]=false,del(seq[pos]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int x,y,c; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y);io.Get(c); v[x].pb(mp(y,c));v[y].pb(mp(x,c)); &#125; depth[1]=1;dfs(1,-1); for (register int i=1;i&lt;=m;i++) &#123; q[i].input();q[i].ind=i; if (st[q[i].u]&gt;st[q[i].v]) swap(q[i].u,q[i].v); if (getlca(q[i].u,q[i].v)==q[i].u) q[i].u=st[q[i].u]+1,q[i].v=st[q[i].v]; else q[i].u=ed[q[i].u],q[i].v=st[q[i].v]; &#125; sort(q+1,q+m+1);N=100000/magic+1; memset(cnt,0,sizeof(cnt));memset(visited,false,sizeof(visited)); for (register int i=q[1].u;i&lt;=q[1].v;i++) doit(i); fans[q[1].ind]=calc();int L=q[1].u,R=q[1].v; for (register int i=2;i&lt;=m;i++) &#123; while (L&lt;q[i].u) doit(L++); while (L&gt;q[i].u) doit(--L); while (R&lt;q[i].v) doit(++R); while (R&gt;q[i].v) doit(R--); fans[q[i].ind]=calc(); &#125; for (register int i=1;i&lt;=m;i++) printf("%d\n",fans[i]); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>莫队</category>
        <category>树上莫队</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>分块</tag>
        <tag>树上莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #115D]Unambiguous Arithmetic Expression 题解]]></title>
    <url>%2Fblog%2Fcf115d%2F</url>
    <content type="text"><![CDATA[DescriptionLet’s define an unambiguous arithmetic expression (UAE) as follows. All non-negative integers are UAE’s. Integers may have leading zeroes (for example, 0000 and 0010 are considered valid integers). If X and Y are two UAE’s, then “(X) + (Y)”, “(X) - (Y)”, “(X) * (Y)”, and “(X) / (Y)” (all without the double quotes) are UAE’s. If X is an UAE, then “ - (X)” and “ + (X)” (both without the double quotes) are UAE’s. You are given a string consisting only of digits (“0” - “9”) and characters “-“, “+”, “*”, and “/“. Your task is to compute the number of different possible unambiguous arithmetic expressions such that if all brackets (characters “(“ and “)”) of that unambiguous arithmetic expression are removed, it becomes the input string. Since the answer may be very large, print it modulo 1000003 (1e6 + 3). InputThe first line is a non-empty string consisting of digits (‘0’-‘9’) and characters ‘-‘, ‘+’, ‘*’, and/or ‘/‘. Its length will not exceed 2000. The line doesn’t contain any spaces. OutputPrint a single integer representing the number of different unambiguous arithmetic expressions modulo 1000003 (106 + 3) such that if all its brackets are removed, it becomes equal to the input string (character-by-character). ExamplesInput 1+2*3 Output 2 Input 03+-30+40 Output 3 Input 5//4 Output 0 Input 5/0 Output 1 Input 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 Output 100728 NoteFor the first example, the two possible unambiguous arithmetic expressions are: ((1) + (2)) * (3) (1) + ((2) * (3)) For the second example, the three possible unambiguous arithmetic expressions are: (03) + (( - (30)) + (40)) (03) + ( - ((30) + (40))) ((03) + ( - (30))) + (40) Solution一道神dp题。 首先一个$O(n^3)$的dp是非常好想的，直接考虑区间dp，然后枚举中间断点转移即可。 然后就不会了 我们先把一些必定无解的情况判掉，有两种： 乘号和除号必须作为连接运算符而不能作为符号位，所以如果乘号和除号的前面不是数字必然无解 如果最后一个字符不是数字必然无解 其他的情况都有解。与此同时，我们还能判断出每个加号和减号是什么类型的：对于一串连续的符号，只有第一个符号是连接运算符，其他的都是符号位。 我们考虑这样的一个例子： (+(233))−(8) 这其中的加减运算符有的是连接运算符，有的是符号位，我们考虑统一一下，对于所有的符号位，我们看做是一个空括号和后面的东西相加，这样所有的符号就都是连接运算符了，上述的例子变成了这样 (()+(233))-(8) 这时每个符号作为连接运算符，都对应着左边的一对括号和右边的一对括号，我们把每个运算符右边对应的括号去掉，上述例子变成这样 (()+233)-8 再把所有的数字去掉，得到 (()) 以此为例，我们发现一个UAE可以对应到一个括号序列上，而且所有括号对的右括号按照运算符的出现顺序出现。这里的括号之间的嵌套和并列关系本质上刻画了UAE运算过程中左边和右边谁包含谁的关系，比如上面的例子中是一对嵌套的括号，就意味着加号所连接的东西以一个整体作为减号的左边部分，即右边包含了左边。 我们再看一个例子，还是上面的数字和符号，另一个UAE +((233)-(8)) 按照规则对应的括号序列是 ()() 这样并列的括号刻画的是右边的减号所连接的东西以一个整体作为加号的右边部分，即左边包含了右边。 因此一个括号序列可以非常严密的刻画UAE所有运算的顺序，从而与UAE中符号个数相等的括号形成的括号序列和UAE成一一对应关系。另外要注意的是，所有在先前作为符号位出现的运算符，因为我们是给它人为地加了一对括号，所以它对应的括号不能包含任何其他的括号。 现在我们只要计算符合上述条件的括号序列个数即可，到了这一步就很容易了。令$dp[i][j]$表示当前考虑到第$i$个运算符，当前序列由$j$个并列的括号构成的方案数。转移考虑最后一对括号的左括号放在哪里。如果第$i$个运算符是一个符号位，那么它只能是在原序列的基础上在结尾加一对空括号形成，$dp[i][j]$从$dp[i-1][j-1]$转移而来，否则当前的这对括号可以包住之前的0对，1对，2对…括号，那些被包在里面的括号将不能继续用于转移。$dp[i][j]$从$dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]…$转移而来，这个可以在dp的过程中维护一个后缀和。 总时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e6+3;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2000;char s[MAXN+48];int len;int n,type[MAXN+48];int dp[MAXN+48][MAXN+48],sum[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);len=strlen(s+1); for (register int i=1;i&lt;=len;i++) &#123; if (isdigit(s[i])) continue; if (s[i]=='*' || s[i]=='/') &#123; type[++n]=0; if (i==1 || !isdigit(s[i-1])) &#123;printf("0\n");return 0;&#125; &#125; if (s[i]=='+' || s[i]=='-') &#123; ++n; if (i&gt;1 &amp;&amp; !isdigit(s[i-1])) type[n]=1; &#125; &#125; if (!isdigit(s[len])) &#123;printf("0\n");return 0;&#125; dp[0][0]=1;sum[0][0]=1; for (register int i=1;i&lt;=n;i++) for (register int j=i;j&gt;=1;j--) &#123; Add(dp[i][j],dp[i-1][j-1]); if (!type[i]) Add(dp[i][j],sum[i-1][j]); sum[i][j]=add(sum[i][j+1]+dp[i][j]); &#125; int ans=0; for (register int i=0;i&lt;=n;i++) Add(ans,dp[n][i]); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #458C]Elections 题解]]></title>
    <url>%2Fblog%2Fcf458c%2F</url>
    <content type="text"><![CDATA[DescriptionYou are running for a governor in a small city in Russia. You ran some polls and did some research, and for every person in the city you know whom he will vote for, and how much it will cost to bribe that person to vote for you instead of whomever he wants to vote for right now. You are curious, what is the smallest amount of money you need to spend on bribing to win the elections. To win elections you need to have strictly more votes than any other candidate. InputFirst line contains one integer n (1 ≤ n ≤ 1e5) — number of voters in the city. Each of the next n lines describes one voter and contains two integers ai and bi (0 ≤ ai ≤ 1e5; 0 ≤ bi ≤ 1e4) — number of the candidate that voter is going to vote for and amount of money you need to pay him to change his mind. You are the candidate 0 (so if a voter wants to vote for you, ai is equal to zero, in which case bi will also be equal to zero). OutputPrint one integer — smallest amount of money you need to spend to win the elections. ExamplesInput 5 1 2 1 2 1 2 2 1 0 0 Output 3 Input 4 1 2 1 2 2 1 0 0 Output 2 Input 1 100000 0 Output 0 Solution我们考虑对于一个数$x$,如果将其他政党的支持人数压到不超过$x$，且保证自己政党的人数超过$x$从而获得胜利，最小的花费$f(x)$是多少。 刚开始我以为这个东西是有单调性的，但后来发现不是。我们可以略微感性地理解一下$f(x)$的变化趋势：当$x$很小时，我们要将其他政党的很多人都拉到我们这边来，这样是一笔很大的花费，而此时我的人数其实已经远超过$x$了，所以其实我并不需要拉这么多人来，因此在一个阶段内，随着$x$的递增,$f(x)$的值会减小。但考虑在某个时刻之后，当$x$变得很大时，为了让我的政党的人数超过$x$，我需要从别的政党那里挖大量的墙脚，当我终于超过$x$的时候却发现别的政党其实剩的人已经很少了，所以其实我并不需要拉那么多人，因此在过了一个临界值之后我拉更多的人显得没有必要。通过上面的论述，应该能感觉到$f(x)$有一个转折点，即$f(x)$是单峰函数（其实应该叫单谷？），我们就是要找到那个最小的点。 找单峰函数的极值点的喜闻乐见的做法是三分。现在我们要解决的问题是对于一个$x$如何快速的求出$f(x)$ 考虑贪心，我们对每个政党的所有投票人，将他们的价格从小到大排序，然后考虑每一个政党，如果它的人数大于$x$,那么就至少要从其中挖掉一定数量的人，显然挖掉那些价格比较小的人会比较好。保证每个政党的人数都不大于$x$之后，如果我们政党的人加上刚才挖来的人数量仍然够不到$x$，就需要从别的政党继续挖人，此时应该取其他所有政党剩下的人中价格最小的，考虑到所有的$b_i\leq 10^4$，我们可以将其他政党剩下的人的价格进行桶排序。 这样单独计算一个$f(x)$的时间复杂度是$O(n)$，所以总时间复杂度是$O(nlog_3n)$，但注意到三分有一个2的常数，所以三分是没有二分快的这不是显然的吗 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int #define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);template&lt;typename T&gt; inline void Get(T &amp;x)&#123; bool f;char ch;T res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; x=(f?res:-res);&#125;template&lt;typename T&gt; inline void check_max(T &amp;x,T y) &#123;x=(x&gt;y?x:y);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T y) &#123;x=(x&lt;y?x:y);&#125;template&lt;typename T&gt; inline void gcd(T x,T y) &#123;return ((!y)?x:gcd(y,x%y));&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e5;int n;vector&lt;int&gt; v[MAXN+48];int cc[MAXN+48];inline int calc(int cmp)&#123; if (cmp==n) return INF; int cnt=int(v[0].size()),res=0; for (register int i=0;i&lt;=10000;i++) cc[i]=0; for (register int i=1;i&lt;=MAXN;i++) &#123; if (int(v[i].size())&gt;cmp) &#123; for (register int j=0;j&lt;int(v[i].size())-cmp;j++) res+=v[i][j]; cnt+=int(v[i].size())-cmp; &#125; int st=((int(v[i].size())&gt;cmp)?int(v[i].size())-cmp:0); for (register int j=st;j&lt;int(v[i].size());j++) cc[v[i][j]]++; &#125; int pt=0; while (cnt&lt;=cmp) &#123; while (!cc[pt]) pt++; res+=pt;cnt++;cc[pt]--; &#125; return res;&#125;int main ()&#123; Get(n);int x,y; for (register int i=1;i&lt;=n;i++) Get(x),Get(y),v[x].pb(y); for (register int i=0;i&lt;=MAXN;i++) sort(v[i].begin(),v[i].end()); int l=0,r=n,mid1,mid2; while (r-l+1&gt;10) &#123; mid1=(l+l+r)/3;mid2=(l+r+r)/3; if (calc(mid1)&gt;calc(mid2)) l=mid1; else r=mid2; &#125; int ans=INF; for (register int i=l;i&lt;=r;i++) check_min(ans,calc(i)); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>三分</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>三分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #490F]Treeland Tour 题解]]></title>
    <url>%2Fblog%2Fcf490f%2F</url>
    <content type="text"><![CDATA[DescriptionThe “Road Accident” band is planning an unprecedented tour around Treeland. The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have. Treeland consists of n cities, some pairs of cities are connected by bidirectional roads. Overall the country has n - 1 roads. We know that it is possible to get to any city from any other one. The cities are numbered by integers from 1 to n. For every city we know its value ri — the number of people in it. We know that the band will travel along some path, having concerts in some cities along the path. The band’s path will not pass one city twice, each time they move to the city that hasn’t been previously visited. Thus, the musicians will travel along some path (without visiting any city twice) and in some (not necessarily all) cities along the way they will have concerts. The band plans to gather all the big stadiums and concert halls during the tour, so every time they will perform in a city which population is larger than the population of the previously visited with concert city. In other words, the sequence of population in the cities where the concerts will be held is strictly increasing. In a recent interview with the leader of the “road accident” band promised to the fans that the band will give concert in the largest possible number of cities! Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities, so that the population number will increase, and the number of concerts will be the largest possible. The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland. Looks like they can’t manage without some help from a real programmer! Help the fans find the sought number of concerts. InputThe first line of the input contains integer n (2 ≤ n ≤ 6000) — the number of cities in Treeland. The next line contains n integers r1, r2, …, rn (1 ≤ ri ≤ 106), where ri is the population of the i-th city. The next n - 1 lines contain the descriptions of the roads, one road per line. Each road is defined by a pair of integers aj, bj (1 ≤ aj, bj ≤ n) — the pair of the numbers of the cities that are connected by the j-th road. All numbers in the lines are separated by spaces. OutputPrint the number of cities where the “Road Accident” band will have concerts. Examplesinput 6 1 2 3 4 5 1 1 2 2 3 3 4 3 5 3 6 output 4 input 5 1 2 3 4 5 1 2 1 3 2 4 3 5 output 3 Solution 1这题一眼看上去感觉数据范围出小了，但是还是先想一个$O(n^2)$的算法比较好。 考虑$dp1[i]$表示以$i$为根的子树，且选择了$i$的最长上升序列长度(从下往上看)，$dp2[i]$表示以$i$为根的子树，且选择了$i$的最长下降序列长度(从下往上看)，这两个dp非常好转移，只要枚举子树内的下一个状态就可以了，这个部分显然是$O(n^2)$的。 接下来考虑如何计算答案。一方面，如果这条链在树上没有“拐弯”，那么一定被$dp1[i]$和$dp2[i]$统计到了，将这些dp值取一个max;另一方面，如果拐弯了，考虑枚举转折点$i$，再枚举一对$lca$为$i$的点$(u,v)$作为接下去的状态，那么在$u$和$v$的$r$值符合条件的情况下，用$dp1[u]+dp2[v]$和$dp1[v]+dp2[u]$更新答案，如果转折点$i$的$r$值介于$u$和$v$之间，用上述两个值+1去更新答案。 因为每个点对只会在它们的$lca$处被枚举，所以总时间复杂度$O(n^2)$，枚举$lca$为某个点的点对可以用dfs序作为小技巧。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=6000;int n;int dp1[MAXN+48],dp2[MAXN+48],r[MAXN+48];vector&lt;int&gt; v[MAXN+48];int ans=0;int L[MAXN+48],R[MAXN+48],seq[MAXN+48],link[MAXN+48],ind;inline void dfs(int cur,int father)&#123; seq[++ind]=cur;L[cur]=ind;dp1[cur]=dp2[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) dfs(y,cur); &#125; R[cur]=ind;int maxn1=0,maxn2=0; for (register int i=L[cur]+1;i&lt;=R[cur];i++) &#123; if (r[seq[i]]&lt;r[cur]) check_max(maxn1,dp1[seq[i]]); if (r[seq[i]]&gt;r[cur]) check_max(maxn2,dp2[seq[i]]); &#125; dp1[cur]+=maxn1;dp2[cur]+=maxn2; check_max(ans,dp1[cur]);check_max(ans,dp2[cur]); for (register int i=L[cur]+1;i&lt;=R[cur];i=R[seq[i]]+1) for (register int j=i;j&lt;=R[seq[i]];j++) link[j]=R[seq[i]]+1; for (register int i=L[cur]+1;i&lt;=R[cur];i++) for (register int j=link[i];j&lt;=R[cur];j++) &#123; if (r[seq[i]]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]); if (r[seq[i]]&gt;r[seq[j]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]); if (r[seq[i]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[j]]) check_max(ans,dp1[seq[i]]+dp2[seq[j]]+1); if (r[seq[j]]&lt;r[cur] &amp;&amp; r[cur]&lt;r[seq[i]]) check_max(ans,dp1[seq[j]]+dp2[seq[i]]+1); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]); int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); dfs(1,-1); printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125; Solution 2这个过程显然是可以优化的，首先考虑该dp的第一部分，在子树内找$r$值比根节点$r$值大的点中的$lid$和$lds$的长度，显然可以用一个BIT或者权值线段树来解决，这样这个部分可以做到$O(nlogn)$ 第二个部分涉及两个子树之间的合并，考虑线段树合并，在合并两个子树的权值线段树的过程中，我们可以借助线段树本身的分治性来帮我们统计答案，对于线段树合并的每一层，我们只要拿着第一棵树的左孩子的$lis$加上第二棵树的右孩子的$lds$,以及第二棵树的左孩子的$lis$和第一棵树的右孩子的$lds$来更新答案，这样相当于将小于$mid$和大于$mid$的部分进行了合并，再左右分治下去就完成了所有的子树信息的合并。 Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n;vector&lt;int&gt; v[MAXN+48];int r[MAXN+48],val[MAXN+48],cnt;int ans=0;int root[MAXN+48];namespace SegmentTree&#123; int lson[MAXN*4],rson[MAXN*4],lis[MAXN*4],lds[MAXN*4],tot; inline void init() &#123; memset(root,0,sizeof(root)); memset(lson,0,sizeof(lson)); memset(rson,0,sizeof(rson)); memset(lis,0,sizeof(lis)); memset(lds,0,sizeof(lds)); tot=0; &#125; inline void pushup(int cur) &#123; lis[cur]=lds[cur]=0; if (lson[cur]) check_max(lis[cur],lis[lson[cur]]),check_max(lds[cur],lds[lson[cur]]); if (rson[cur]) check_max(lis[cur],lis[rson[cur]]),check_max(lds[cur],lds[rson[cur]]); &#125; inline int merge(int root1,int root2) &#123; if (!root1 || !root2) return root1^root2; check_max(ans,lis[lson[root1]]+lds[rson[root2]]); check_max(ans,lis[lson[root2]]+lds[rson[root1]]); lson[root1]=merge(lson[root1],lson[root2]);rson[root1]=merge(rson[root1],rson[root2]); pushup(root1);return root1; &#125; inline void modify(int &amp;cur,int pos,int nv,int l,int r,int type) &#123; if (!cur) cur=++tot; if (l==r) &#123; if (type==1) check_max(lis[cur],nv); else check_max(lds[cur],nv); return; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) modify(lson[cur],pos,nv,l,mid,type); else modify(rson[cur],pos,nv,mid+1,r,type); pushup(cur); &#125; inline int query(int &amp;cur,int left,int right,int l,int r,int type) &#123; if (!cur) return 0; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;if (type==1) return lis[cur]; else return lds[cur];&#125; int mid=(l+r)&gt;&gt;1,res=0; if (left&lt;=mid) check_max(res,query(lson[cur],left,right,l,mid,type)); if (mid+1&lt;=right) check_max(res,query(rson[cur],left,right,mid+1,r,type)); return res; &#125;&#125;inline void dfs(int cur,int father)&#123; int maxn1=0,maxn2=0,cmaxn1,cmaxn2; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); cmaxn1=SegmentTree::query(root[y],1,r[cur]-1,1,cnt,1); cmaxn2=SegmentTree::query(root[y],r[cur]+1,cnt,1,cnt,2); check_max(ans,maxn1+cmaxn2+1);check_max(ans,cmaxn1+maxn2+1); check_max(maxn1,cmaxn1);check_max(maxn2,cmaxn2); root[cur]=SegmentTree::merge(root[cur],root[y]); &#125; &#125; SegmentTree::modify(root[cur],r[cur],maxn1+1,1,cnt,1); SegmentTree::modify(root[cur],r[cur],maxn2+1,1,cnt,2);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);for (register int i=1;i&lt;=n;i++) io.Get(r[i]),val[i]=r[i]; int x,y;for (register int i=1;i&lt;=n-1;i++) io.Get(x),io.Get(y),v[x].pb(y),v[y].pb(x); sort(val+1,val+n+1);cnt=unique(val+1,val+n+1)-(val+1); for (register int i=1;i&lt;=n;i++) r[i]=lower_bound(val+1,val+cnt+1,r[i])-val; SegmentTree::init(); dfs(1,-1);printf("%d\n",ans); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树型dp</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #19E]Fairy 题解]]></title>
    <url>%2Fblog%2Fcf19e%2F</url>
    <content type="text"><![CDATA[DescriptionOnce upon a time there lived a good fairy A. One day a fine young man B came to her and asked to predict his future. The fairy looked into her magic ball and said that soon the fine young man will meet the most beautiful princess ever and will marry her. Then she drew on a sheet of paper n points and joined some of them with segments, each of the segments starts in some point and ends in some other point. Having drawn that picture, she asked the young man to erase one of the segments from the sheet. Then she tries to colour each point red or blue so, that there is no segment having points of the same colour as its ends. If she manages to do so, the prediction will come true. B wants to meet the most beautiful princess, that’s why he asks you to help him. Find all the segments that will help him to meet the princess. InputThe first input line contains two integer numbers: n — amount of the drawn points and m — amount of the drawn segments (1 ≤ n ≤ 1e4, 0 ≤ m ≤ 1e4). The following m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v, u (1 ≤ v ≤ n, 1 ≤ u ≤ n) — indexes of the points, joined by this segment. No segment is met in the description twice. OutputIn the first line output number k — amount of the segments in the answer. In the second line output k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order. ExamplesInput 4 4 1 2 1 3 2 4 3 4 Output 4 1 2 3 4 Input 4 5 1 2 2 3 3 4 4 1 1 3 Output 1 5 Solution 1简单来说就是从图中删掉一条边，使得图中没有奇环。 考虑对原图求出dfs树，则此时我们的边只有树边和返祖边两种（因为这是一个无向图）。根据返祖边连接的两个点的深度差的奇偶性可以判断所有返祖边所在的环长的奇偶性。 如果原图中没有奇环，那么任意删去一条边以后肯定也没有奇环，这种平凡的情况以下不讨论。 否则分两种情况讨论： 删去一条非树边：则原图中必须只有一个奇环，这显然是必要的。 删去一条树边，则该树边必须为所有奇环的公共边，这也是必要的。 接下来考虑要使得条件充分还需要什么。我们考虑到如果一个奇环和一个偶环相交的话，那么这两个环的复合环肯定是一个奇环，如果删除的是奇环和偶环的公共部分的话仍然会有奇环。 那么删除不在任意一个偶环中且在所有奇环中的一条边是否是该问题的充要条件呢？答案是肯定的。轻微玄学，仔细yy若干情况感觉很对 考虑到这里这个问题就有很多做法了，比如比较暴力的做法可以直接树链剖分，对奇环所在的树链和偶环所在的树链打标记。 但这样就完全没有利用无向图的dfs树只有返祖边的这个优良性质，考虑一个简单的差分打标记做法，对于奇环,在y+1,x-1，这样从上到下做一个前缀和就能得到每条边被多少个奇环覆盖，再判断一下有没有被偶环覆盖，做法是相当的 还有一个比较神奇的做法，我们令奇环对应的非树边是坏边，偶环对应的非树边是好边，那么要判断一条边是否被偶环覆盖，我们可以考虑扔掉坏边对剩下的图求一个边双联通分量，如果某一条边是桥的话那么它没有被偶环覆盖，否则被偶环覆盖。 Code 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327// 树链剖分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];int ansnum;vector&lt;int&gt; ans;struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntgedge,ntbedge;int fa[10048],fa_ind[10048];bool visited[10048];int num[10048];vector&lt;int&gt; vv[10048];int tot;int dep[10048],depth[10048],sz[10048],son[10048],ffa[10048];int tpos[10048],ind=0,top[10048];int anc[10048][21];void dfs(int cur)&#123; visited[cur]=true; if (!fa[cur]) num[fa_ind[cur]]=++tot; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); num[v[cur][i].y]=++tot; anc[to][0]=cur;dep[to]=dep[cur]+1; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; dfs(to); vv[num[fa_ind[cur]]].pb(num[v[cur][i].y]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; dep[cur]&gt;dep[to]) &#123; if (!((dep[cur]-dep[to])&amp;1)) ntbedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); else ntgedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125; &#125;&#125;void dfs1(int cur,int father)&#123; ffa[cur]=father;sz[cur]=1;son[cur]=0; int i,to,max_size=-1; for (i=0;i&lt;int(vv[cur].size());i++) &#123; to=vv[cur][i];depth[to]=depth[cur]+1; dfs1(to,cur); sz[cur]+=sz[to]; if (sz[to]&gt;max_size) &#123; max_size=sz[to]; son[cur]=to; &#125; &#125;&#125;void dfs2(int cur,int tp)&#123; top[cur]=tp;tpos[cur]=++ind; if (son[cur]) dfs2(son[cur],tp); int i; for (i=0;i&lt;int(vv[cur].size());i++) if (vv[cur][i]!=son[cur]) dfs2(vv[cur][i],vv[cur][i]);&#125;struct node&#123; int left,right; int cnt;&#125;tree_good[40048],tree_bad[40048];void build_good(int cur,int left,int right)&#123; tree_good[cur].left=left;tree_good[cur].right=right;tree_good[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_good(cur&lt;&lt;1,left,mid); build_good(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void build_bad(int cur,int left,int right)&#123; tree_bad[cur].left=left;tree_bad[cur].right=right;tree_bad[cur].cnt=0; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build_bad(cur&lt;&lt;1,left,mid); build_bad(cur&lt;&lt;1|1,mid+1,right); &#125;&#125;void update_good(int cur,int left,int right)&#123; if (left&lt;=tree_good[cur].left &amp;&amp; tree_good[cur].right&lt;=right) &#123; tree_good[cur].cnt++; return; &#125; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (left&lt;=mid) update_good(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_good(cur&lt;&lt;1|1,left,right);&#125;void update_bad(int cur,int left,int right)&#123; if (left&lt;=tree_bad[cur].left &amp;&amp; tree_bad[cur].right&lt;=right) &#123; tree_bad[cur].cnt++; return; &#125; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (left&lt;=mid) update_bad(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) update_bad(cur&lt;&lt;1|1,left,right);&#125;int query_good(int cur,int pos)&#123; if (tree_good[cur].left==tree_good[cur].right) return tree_good[cur].cnt; int mid=(tree_good[cur].left+tree_good[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_good(cur&lt;&lt;1,pos)+tree_good[cur].cnt; else return query_good(cur&lt;&lt;1|1,pos)+tree_good[cur].cnt;&#125;int query_bad(int cur,int pos)&#123; if (tree_bad[cur].left==tree_bad[cur].right) return tree_bad[cur].cnt; int mid=(tree_bad[cur].left+tree_bad[cur].right)&gt;&gt;1; if (pos&lt;=mid) return query_bad(cur&lt;&lt;1,pos)+tree_bad[cur].cnt; else return query_bad(cur&lt;&lt;1|1,pos)+tree_bad[cur].cnt;&#125;void doit_good(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_good(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_good(1,tpos[v],tpos[u]);&#125;void doit_bad(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (depth[tp1]&lt;depth[tp2]) &#123; swap(u,v); swap(tp1,tp2); &#125; update_bad(1,tpos[tp1],tpos[u]); u=ffa[tp1];tp1=top[u]; &#125; if (depth[u]&lt;depth[v]) swap(u,v); update_bad(1,tpos[v],tpos[u]);&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int getbelow(int u,int v)&#123; int i; for (i=20;i&gt;=0;i--) if (dep[anc[u][i]]&gt;dep[v]) u=anc[u][i]; return u;&#125;Pair query_node(int u,int v)&#123; int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return mp(num[fa_ind[u]],num[fa_ind[v]]); if (dep[u]&lt;dep[v]) swap(u,v); int tmp=getbelow(u,v); return mp(num[fa_ind[u]],num[fa_ind[tmp]]);&#125;int main ()&#123; int i,j,cur,x,y;int wei; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); if (i==1) wei=x; edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0;ansnum=0; for (cur=1;cur&lt;=n;cur++) if (!visited[cur]) &#123; for (j=1;j&lt;=tot;j++) vv[j].clear(); tot=0;fa[cur]=fa_ind[cur]=0;dep[cur]=1; tedge.clear();ntgedge.clear();ntbedge.clear(); dfs(cur); depth[cur]=1;dfs1(1,0); ind=0;dfs2(1,1); if (!int(ntbedge.size())) continue; all_cnt++; if (int(ntbedge.size())==1) &#123; ansnum++; ans.pb(ntbedge[0].ind); &#125; build_good(1,1,ind);build_bad(1,1,ind); for (i=0;i&lt;int(ntgedge.size());i++) &#123; Pair res=query_node(ntgedge[i].x,ntgedge[i].y); doit_good(res.x,res.y); &#125; for (i=0;i&lt;int(ntbedge.size());i++) &#123; Pair res=query_node(ntbedge[i].x,ntbedge[i].y); doit_bad(res.x,res.y); &#125; for (i=0;i&lt;int(tedge.size());i++) &#123; if (dep[tedge[i].x]&gt;dep[tedge[i].y]) swap(tedge[i].x,tedge[i].y); if (query_good(1,tpos[num[fa_ind[tedge[i].y]]])==0 &amp;&amp; query_bad(1,tpos[num[fa_ind[tedge[i].y]]])==int(ntbedge.size())) &#123; ansnum++; ans.pb(tedge[i].ind); &#125; &#125; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// 差分#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+9;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;Pair edge[10048];vector&lt;Pair&gt; v[10048];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;bool istree[10048];int L[10048],R[10048];int a[10048],pos[10048],ind;bool visited[10048];int depth[10048];int sum1[10048],sum2[10048];bool col[10048];int node[10048],tot=0;vector&lt;int&gt; ans;int ansnum;bool ins[10048];void dfs(int cur)&#123; node[++tot]=cur; visited[cur]=true; a[++ind]=cur;pos[cur]=ind; L[cur]=ind; int i,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!visited[to]) &#123; istree[v[cur][i].y]=true; depth[to]=depth[cur]+1; col[to]=col[cur]^1; dfs(to); &#125; &#125; R[cur]=ind;&#125;int main ()&#123; int i,j,k,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; memset(visited,false,sizeof(visited)); int all_cnt=0,cnt; bool hasbaned=false; ansnum=0; for (i=1;i&lt;=n;i++) if (!visited[i]) &#123; cnt=0; depth[i]=1;col[i]=false; ind=0;tot=0; dfs(i); //for (i=1;i&lt;=n;i++) cout&lt;&lt;visited[i]&lt;&lt;' '; //cout&lt;&lt;endl; bool f=false; for (j=1;j&lt;=tot;j++) for (k=0;k&lt;int(v[node[j]].size());k++) &#123; int eind=v[node[j]][k].y; if (depth[edge[eind].x]&gt;depth[edge[eind].y]) swap(edge[eind].x,edge[eind].y); if (!ins[eind]) &#123; ins[eind]=true; if (!istree[eind]) &#123; ntedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); if (col[edge[eind].x]^col[edge[eind].y]) &#123; sum1[pos[edge[eind].x]]--; sum1[pos[edge[eind].y]]++; &#125; else &#123; hasbaned=true;f=true;cnt++; sum2[pos[edge[eind].x]]--; sum2[pos[edge[eind].y]]++; &#125; &#125; else tedge.pb(Edge&#123;edge[eind].x,edge[eind].y,eind&#125;); &#125; &#125; if (f) all_cnt++; if (!cnt) continue; if (cnt==1) &#123; ansnum=1; for (j=0;j&lt;int(ntedge.size());j++) if (!(col[ntedge[j].x]^col[ntedge[j].y])) &#123; ans.pb(ntedge[j].ind); break; &#125; &#125; for (j=1;j&lt;=tot;j++) sum1[j]+=sum1[j-1],sum2[j]+=sum2[j-1]; for (j=0;j&lt;int(tedge.size());j++) if (sum2[R[tedge[j].y]]-sum2[L[tedge[j].y]-1]==cnt &amp;&amp; sum1[R[tedge[j].y]]-sum1[L[tedge[j].y]-1]==0) &#123; ansnum++; ans.pb(tedge[j].ind); &#125; for (i=1;i&lt;=tot;i++) sum1[i]=sum2[i]=0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; if (!hasbaned) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (j=0;j&lt;int(ans.size());j++) printf("%d ",ans[j]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// 边双联通分量#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n,e;int ansnum;vector&lt;int&gt; ans;vector&lt;Pair&gt; v[10048];int dfn[10048],low[10048],ind;int depth[10048],fa[10048],fa_ind[10048];bool iseven[10048];int anc[10048][21];struct Edge&#123; int x,y; int ind;&#125;;vector&lt;Edge&gt; tedge,ntedge;Pair edge[10048];void Tarjan(int cur)&#123; dfn[cur]=low[cur]=++ind; int i,j,to; for (i=0;i&lt;int(v[cur].size());i++) &#123; to=v[cur][i].x; if (!dfn[to]) &#123; fa[to]=cur;fa_ind[to]=v[cur][i].y; depth[to]=depth[cur]+1; tedge.pb(Edge&#123;cur,to,v[cur][i].y&#125;); anc[to][0]=cur; for (j=1;j&lt;=20;j++) anc[to][j]=anc[anc[to][j-1]][j-1]; Tarjan(to); low[cur]=min(low[cur],low[to]); &#125; else &#123; if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; (depth[cur]-depth[to])&amp;1) low[cur]=min(low[cur],dfn[to]); if (to!=fa[cur] &amp;&amp; depth[cur]&gt;depth[to] &amp;&amp; !((depth[cur]-depth[to])&amp;1)) ntedge.pb(Edge&#123;to,cur,v[cur][i].y&#125;); &#125; &#125;&#125;int lca(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int i; for (i=20;i&gt;=0;i--) if (depth[anc[u][i]]&gt;=depth[v]) u=anc[u][i]; if (u==v) return u; for (i=20;i&gt;=0;i--) if (anc[u][i]!=anc[v][i]) &#123; u=anc[u][i]; v=anc[v][i]; &#125; return anc[u][0];&#125;int Low(int u,int v)&#123; if (depth[u]&lt;depth[v]) swap(u,v); int LCA=lca(u,v); if (LCA!=u &amp;&amp; LCA!=v) return -1; return u;&#125;bool isanc(int u,int v)&#123; if (u==v) return false; return lca(u,v)==u;&#125;int main ()&#123; int i,cur,x,y; n=getint();e=getint(); for (i=1;i&lt;=e;i++) &#123; x=getint();y=getint(); edge[i]=mp(x,y); v[x].pb(mp(y,i));v[y].pb(mp(x,i)); &#125; int all_cnt=0,superf=true; for (cur=1;cur&lt;=n;cur++) if (!dfn[cur]) &#123; tedge.clear();ntedge.clear(); fa[cur]=0;ind=0;depth[cur]=1; Tarjan(cur); for (i=0;i&lt;int(tedge.size());i++) &#123; if (depth[tedge[i].x]&gt;depth[tedge[i].y]) swap(edge[i].x,edge[i].y); if (low[tedge[i].y]!=dfn[tedge[i].y]) iseven[tedge[i].ind]=true; &#125; if (int(ntedge.size())) all_cnt++; if (int(ntedge.size())==1) &#123; ansnum++; ans.pb(ntedge[0].ind); &#125; int curu=-2,curv=-2; for (i=0;i&lt;int(ntedge.size());i++) &#123; if (depth[ntedge[i].x]&gt;depth[ntedge[i].y]) swap(ntedge[i].x,ntedge[i].y); if (curu==-2) &#123; curu=ntedge[i].x; curv=ntedge[i].y; continue; &#125; curu=Low(ntedge[i].x,curu); if (curu==-1) &#123; superf=false; break; &#125; curv=lca(ntedge[i].y,curv); if (!isanc(curu,curv)) &#123; superf=false; break; &#125; &#125; if (!superf) break; for (;curv!=curu;curv=fa[curv]) if (!iseven[fa_ind[curv]]) &#123; ansnum++; ans.pb(fa_ind[curv]); &#125; &#125; if (!superf) &#123; printf("0\n"); return 0; &#125; if (all_cnt==0) &#123; printf("%d\n",e); for (i=1;i&lt;=e;i++) printf("%d ",i); printf("\n");return 0; &#125; if (all_cnt&gt;1) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); printf("\n"); &#125; return 0;&#125; Solution 2如果你没有yy出那个非常好用的充要条件，我们仍然有一个非常好的基于分治和可撤销并查集的做法。 首先判断一个图是否存在奇环等价于判断一个图是否是二分图，这个有一个喜闻乐见的并查集做法： 对于一个点$i$，令编号为$i$的点表示它是白色，令编号是$n+i$的点表示它是黑色。如果图中有一条边$(u,v)$，那么$u$和$n+v$连边，$n+u$和$v$连边，表示如果一个是黑的另一个一定是白的。最后对于每一个$i$判断$i$和$n+i$是否连通，如果连通说明导出了矛盾，从而原图不是二分图。 现在对于每一条边，我们希望得到删除它之后的并查集，如果暴力的把其他剩余的边加入并查集就是$O(m^2)$的。考虑分治,$solve(l,r)$表示当前我要解决最后删除的边编号在$l$到$r$之间的情况。如果那么流程如下: 如果$l==r$，说明这条边可以删除，返回 令$mid=(l+r)/2$ 将$[mid+1,r]$之间的边加入并查集，如果仍然合法，递归$solve(l,mid)$ 将$[mid+1,r]$之间的边从并查集中撤销 将$[l,mid]$之间的边加入并查集，如果仍然合法，递归$solve(mid+1,r)$ 将$[l,mid]$之间的边从并查集中撤销，返回 注意判断是否合法的时候不需要check所有的点，只需要check当前加入的这些边所相连的点就可以了。 因为这里的并查集要支持撤销，所以只按秩合并不路径压缩，从而总时间复杂度$O(nlog^2n)$ Code 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#define LL long long#define LB long double#define x first#define y second#define Pair pair&lt;int,int&gt;#define pb push_back#define pf push_front#define mp make_pair#define LOWBIT(x) x &amp; (-x)using namespace std;const int MOD=1e9+7;const LL LINF=2e16;const int INF=2e9;const int magic=348;const double eps=1e-10;const double pi=3.14159265;inline int getint()&#123; char ch;int res;bool f; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;struct Ope&#123; int x,y; bool type;&#125;ope[100048];int tot=0;int pre[20048],rnk[20048];int find_anc(int x)&#123; while (pre[x]!=x) x=pre[x]; return x;&#125;void update(int x,int y)&#123; x=find_anc(x);y=find_anc(y); if (x==y) &#123; ope[++tot]=Ope&#123;x,y,false&#125;; return; &#125; if (rnk[x]&gt;=rnk[y]) &#123; pre[y]=x; ope[++tot]=Ope&#123;x,y,false&#125;; if (rnk[x]==rnk[y]) rnk[x]++,ope[tot].type=true; &#125; else &#123; ope[++tot]=Ope&#123;y,x,false&#125;; pre[x]=y; &#125;&#125;void undo()&#123; int x=ope[tot].x,y=ope[tot].y; pre[y]=y; if (ope[tot].type) rnk[x]--; tot--;&#125;int n,e;Pair edge[10048];int ansnum;vector&lt;int&gt; ans;bool Conflict=false;void Add(int x,int y)&#123; //if (find_anc(x)==find_anc(y+n)) Conflict=true; update(x,y+n); //if (find_anc(x+n)==find_anc(y)) Conflict=true; update(x+n,y); if (find_anc(x)==find_anc(x+n) || find_anc(y)==find_anc(y+n)) Conflict=true;&#125;void solve(int left,int right)&#123; if (left==right) &#123; ansnum++; ans.pb(left); return; &#125; int i,mid=(left+right)&gt;&gt;1; Conflict=false; for (i=left;i&lt;=mid;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(mid+1,right); for (i=left;i&lt;=mid;i++) undo(),undo(); Conflict=false; for (i=mid+1;i&lt;=right;i++) Add(edge[i].x,edge[i].y); if (!Conflict) solve(left,mid); for (i=mid+1;i&lt;=right;i++) undo(),undo(); Conflict=false;&#125;int main ()&#123; int i; n=getint();e=getint(); if (e==0) &#123; printf("0\n"); return 0; &#125; for (i=1;i&lt;=e;i++) edge[i].x=getint(),edge[i].y=getint(); for (i=1;i&lt;=n*2;i++) pre[i]=i,rnk[i]=1; solve(1,e); printf("%d\n",ansnum); if (ansnum) &#123; sort(ans.begin(),ans.end()); for (i=0;i&lt;int(ans.size());i++) printf("%d ",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>图论</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>分治</category>
        <category>可撤销并查集</category>
        <category>dfs树</category>
        <category>Tarjan求边双联通分量</category>
        <category>树链剖分</category>
        <category>重链剖分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>分治</tag>
        <tag>可撤销并查集</tag>
        <tag>dfs树</tag>
        <tag>Tarjan求边双联通分量</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #70E]Information Reform 题解]]></title>
    <url>%2Fblog%2Fcf70e%2F</url>
    <content type="text"><![CDATA[DescriptionThought it is already the XXI century, the Mass Media isn’t very popular in Walrusland. The cities get news from messengers who can only travel along roads. The network of roads in Walrusland is built so that it is possible to get to any city from any other one in exactly one way, and the roads’ lengths are equal. The North Pole governor decided to carry out an information reform. Several cities were decided to be chosen and made regional centers. Maintaining a region center takes k fishlars (which is a local currency) per year. It is assumed that a regional center always has information on the latest news. For every city which is not a regional center, it was decided to appoint a regional center which will be responsible for keeping this city informed. In that case the maintenance costs will be equal to dlen fishlars per year, where len is the distance from a city to the corresponding regional center, measured in the number of roads along which one needs to go. Your task is to minimize the costs to carry out the reform. InputThe first line contains two given numbers n and k (1 ≤ n ≤ 180, 1 ≤ k ≤ 105). The second line contains n - 1 integers di, numbered starting with 1 (di ≤ di + 1, 0 ≤ di ≤ 105). Next n - 1 lines contain the pairs of cities connected by a road. OutputOn the first line print the minimum number of fishlars needed for a year’s maintenance. On the second line print n numbers, where the i-th number will represent the number of the regional center, appointed to the i-th city. If the i-th city is a regional center itself, then you should print number i. If there are several solutions to that problem, print any of them. Examplesinput 8 10 2 5 9 11 15 19 20 1 4 1 3 1 7 4 6 2 8 2 3 3 5 output 38 3 3 3 4 3 4 3 3 Solution一道非常神的dp题。 我们可以考虑如下性质：对于任意一棵子树，其中所有被子树外的regional center控制的点，一定都是被同一个regional center控制的，否则如果被多个regional center控制，到子树的根节点最近的regional center一定比其他的优。 考虑如下dp状态：$dp[i][j]$表示考虑以$i$为根的子树，在$j$一定是regional center且$i$被$j$控制的情况下，所有点都被控制的最小花费，其中建立$j$的费用$k$也被计算在内。另外记录$best[i]$表示令$dp[i][j]$取得最小值的$j$。 转移不是非常复杂，考虑$i$的每一个孩子$v$，如果$v$选择和$i$共用一个regional center,则$v$子树的贡献是$dp[v][j]-k$，注意建立$j$的费用在$i$处已经算过了所以要扣除。另外一种情况是$v$没有选择和$i$共用一个regional center，这时$v$子树的贡献是$dp[v][best[v]]$，注意根据上面考虑的性质，$v$选择的regional center必定在$v$子树内才是最优的，所以不用考虑子树$i$向外勾连两个regional center从而导致建立费用算重的情况。更深入的来说,这个dp的转移中有一部分可能是错误的，但只有正确的部分可能是正确答案。 综上，状态转移方程为$dp[i][j]=\sum_{v\in son_i}min(dp[v][best[v]],dp[v][j]-k)$,最终$dp[1][best[1]]$的值就是第一问的答案。 考虑第二问。我们可以倒着考虑$dp[1][best[1]]$的组成，顺着树dfs一遍，每个孩子的$dp[v][j]-k$和$dp[v][best[v]]$比较一下大小就可以得出它是被哪个节点控制的了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=1e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=200;int n,k;int dp[MAXN+48][MAXN+48],best[MAXN+48];int d[MAXN+48],dist[MAXN+48][MAXN+48];vector&lt;int&gt; v[MAXN+48];inline void floyd()&#123; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) dist[i][j]=(i==j?0:INF); for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;int(v[i].size());j++) dist[i][v[i][j]]=1; for (register int k=1;k&lt;=n;k++) for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=n;j++) if (k!=i &amp;&amp; k!=j &amp;&amp; i!=j) check_min(dist[i][j],dist[i][k]+dist[k][j]);&#125;inline void dfs(int cur,int father)&#123; for (register int i=1;i&lt;=n;i++) dp[cur][i]=k+d[dist[cur][i]]; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; dfs(y,cur); for (register int j=1;j&lt;=n;j++) dp[cur][j]+=min(dp[y][j]-k,dp[y][best[y]]); &#125; &#125; best[cur]=1;for (register int i=2;i&lt;=n;i++) if (dp[cur][i]&lt;dp[cur][best[cur]]) best[cur]=i;&#125;int ans[MAXN+48];inline void getans(int cur,int father,int tar)&#123; ans[cur]=tar; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) getans(y,cur,dp[y][tar]-k&lt;=dp[y][best[y]]?tar:best[y]); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);int x,y; for (register int i=1;i&lt;=n-1;i++) io.Get(d[i]); for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; floyd();dfs(1,-1); printf("%d\n",dp[1][best[1]]); getans(1,-1,best[1]); for (register int i=1;i&lt;=n;i++) printf("%d ",ans[i]);printf("\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟赛]b 题解]]></title>
    <url>%2Fblog%2Fb%2F</url>
    <content type="text"><![CDATA[Description给定一个二分图，统计满足$1\leq x&lt;y\leq n,1\leq a&lt;b\leq m$且$(x,a),(x,b),(y,a),(y,b)$之间均有边的四元组(x,y,a,b)的个数 Constraint $1\leq n,m \leq 200,000,1\leq k \leq min(n*m,300,000)$ Solution考虑根号暴力，对于二分图左边的点，如果出边大于$\sqrt{m}$称之为大点，否则称之为小点。 考虑左边两个小点，两个大点和一小一大两个点三种匹配情况。 对于小点和小点的情况，我们考虑对于每个小点$x$向右边的出边集合，枚举所有可能的$(a,b)$，其中$a&lt;b$,这样我们只要统计右边的每一个点对$(a,b)$被覆盖了多少次即可计算。 这个部分可以无脑的用map做，但会多一个log,考虑一种比较精巧的做法，对于每个点对$(a,b)$,我们在下标为a的vector里面添加b,之后我们统计每个vector内每种相同的数有多少个，再$C_x^2$一下就好了。 接下来考虑左边的两个点中有一个是大点的情况，我们枚举每个大点，将它的出边所到达的右边的点标记为１，然后枚举左边的每一个点，看看当前点的出边所到达的右边的点有多少个被标记了，假设第$i$个点有$x_i$个，那么当前大点的贡献就是$\sum_{i=1}^nC_{x_i}^2$，注意扣除一下重复计算的情况。 计算一下时间复杂度。第二部分的时间复杂度比较容易证明，考虑到大点的个数不会超过$\sqrt m$个，所有大点的出边条数的和是$O(m)$的，所以第二部分的时间复杂度是$O(m\sqrt m)$ 第一部分的时间复杂度比较难算，我们尝试抽象这个问题：有一个整数集合${a_n}$，要求$\sum a_i\leq m$且$\forall a_i\leq \sqrt m$，我们要证明$\sum {a_i}^2$的最大值是$O(m\sqrt m)$级别的。 我们发现如下性质：如果集合${a_i}$中存在两个元素$a_1$,$a_2$满足$a_1,a_2\leq \frac{\sqrt m}{2}$，则删除这两个元素将这两个元素的和放入，目标函数的值一定更大，因为$a^2+b^2&lt;{(a+b)}^2$。所以满足目标函数最大的集合，一定对于$\forall i$有$\frac{\sqrt m}{2}\leq a_i\leq \sqrt m$，所以集合的大小$n\leq 2\sqrt m$，从而$\sum {a_i}^2$是$O(m\sqrt m)$级别的。 综上总时间复杂度$O(m\sqrt m)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=448;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=2e5;int n,m,k;bool type[MAXN+48];vector&lt;int&gt; v[MAXN+48];vector&lt;int&gt; ed[MAXN+48];int cnt[MAXN+48];inline LL doit_small()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (!type[i]) &#123; for (register int p1=0;p1&lt;int(v[i].size())-1;p1++) for (register int p2=p1+1;p2&lt;int(v[i].size());p2++) &#123; int v1=v[i][p1],v2=v[i][p2]; if (v1&gt;v2) swap(v1,v2); ed[v1].pb(v2); &#125; &#125; for (register int i=1;i&lt;=m;i++) &#123; for (register int j=0;j&lt;int(ed[i].size());j++) res+=cnt[ed[i][j]],cnt[ed[i][j]]++; for (register int j=0;j&lt;int(ed[i].size());j++) cnt[ed[i][j]]--; &#125; return res;&#125;int mark[MAXN+48];inline LL doit_big()&#123; LL res=0; for (register int i=1;i&lt;=n;i++) if (type[i]) &#123; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=1; for (register int j=1;j&lt;=n;j++) &#123; if (type[j] &amp;&amp; j&lt;=i) continue; int cnt=0; for (register int p=0;p&lt;int(v[j].size());p++) cnt+=mark[v[j][p]]; res+=1ll*cnt*(cnt-1)/2; &#125; for (register int j=0;j&lt;int(v[i].size());j++) mark[v[i][j]]=0; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("b.in","r",stdin); freopen ("b.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif int x,y;io.Get(n);io.Get(m);io.Get(k); for (register int i=1;i&lt;=k;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y); &#125; for (register int i=1;i&lt;=n;i++) if (int(v[i].size())&lt;=magic) type[i]=false; else type[i]=true; printf("%lld\n",doit_small()+doit_big()); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>根号暴力</category>
      </categories>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>根号暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces GYM 100518F]Funny Card Game 题解]]></title>
    <url>%2Fblog%2Fgym100518f%2F</url>
    <content type="text"><![CDATA[DescriptionAndrew and his k friends are playing a funny card game. They have a deck of n cards, each one contains a single integer $a_i$ . Andrew is a dealer. His friends are sitting in a circle around him and he deals cards to them. Andrew chooses one of his friends and starts dealing cards to him, one after another. After each card a player can either say “stop”, or say “more”. If the player says “more” he is dealt another card. After he says”stop”, he gets no more cards and his score is equal to the maximal number of times some value occursamong his cards. For example, if the player is dealt cards with values 2, 3, 4, 3, 2, 1, 2 and 5, his score is 3, because 2 occurs 3 times among his cards and no other value has more occurrences. Then the next player who has no cards yet is chosen and Andrew deals cards to him in the same way. The game continues until all but one friends have their cards. The last player gets all the remaining cards. Andrew’s friends has seen the order in which the cards are arranged in the deck. Now they want to choose such strategy that the sum of their scores was maximal possible. Also they want each player to be dealt at least one card. Help them to develop their strategy: for each player from 1 to k − 1 find the card that he must say “stop” after. The last player would receive the rest of the cards. Solution非常不错的dp题 一个复杂度为$O(n^2k)$的dp是非常好想的：考虑dp[i][j]表示当前看到第i张牌，已经划分出j段的最大权值，转移的时候枚举当前人的左端点k，从dp[k-1][j-1]转移来。 考虑优化这个dp,我们可以发现一个非常好的性质：对于dp[i][j]，假如最后一个元素不是第j个人的众数，我们可以直接从dp[i-1][j]转移来，相当于最后给第j个人加一张无用的牌i;假如最后一个元素是第j个人的众数，设a[i]=x,我们可以发现这个人的左端点处的牌一定也是x,因为如果不是x可以把最前面的一段不是x的牌砍掉，当前段众数个数不会变化且前面的答案可以更优。 所以我们可以直接从所有的a[k]=a[i]的k转移来，这个部分可以做一个前缀max优化，我们令maxn[i]表示从1~i所有和a[i]值相同的位置的dp值加上最后的一些a[i]的牌的数量的最大值。预处理每一个位置i之前的一个与它牌值相同的位置pre[i]，则dp[i][j]=max(maxn[pre[i]]+1,1+dp[i-1][j-1])，此时又可以用maxn[pre[i]]和dp[i][j]来更新maxn[i] 总时间复杂度$O(nk)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int k,n;int a[MAXN+48];struct node&#123; int val,from; inline bool operator &lt; (const node &amp;other) const &#123;return val&lt;other.val;&#125;&#125;b[MAXN+48];int pre[MAXN+48],pos[MAXN+48];int dp[101][MAXN+48],maxn[MAXN+48],maxpos[MAXN+48],from[101][MAXN+48];int List[MAXN+48],tot=0;inline void getans(int r,int i)&#123; if (!i) return; List[++tot]=i;getans(r-1,from[r][i]);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif freopen ("funny.in","r",stdin); freopen ("funny.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;k) &amp;&amp; n &amp;&amp; k) &#123; for (register int i=1;i&lt;=n;i++) scanf("%d",a+i),b[i].val=a[i],b[i].from=i; sort(b+1,b+n+1);int itot=0; for (register int i=1;i&lt;=n;i++) &#123; if (i==1 || b[i].val!=b[i-1].val) itot++; a[b[i].from]=itot; &#125; for (register int i=1;i&lt;=itot;i++) pos[i]=0; for (register int i=1;i&lt;=n;i++) pre[i]=pos[a[i]],pos[a[i]]=i; for (register int r=1;r&lt;=k;r++) &#123; for (register int i=0;i&lt;=n;i++) maxn[i]=0,maxpos[i]=0;maxn[0]=-INF; for (register int i=1;i&lt;=r-1;i++) dp[r][i]=-INF; for (register int i=r;i&lt;=n;i++) &#123; dp[r][i]=dp[r][i-1];from[r][i]=from[r][i-1]; maxn[i]=maxn[pre[i]]+1;maxpos[i]=maxpos[pre[i]]; if (dp[r-1][i-1]+1&gt;maxn[i]) &#123; maxn[i]=dp[r-1][i-1]+1; maxpos[i]=i-1; &#125; if (maxn[i]&gt;dp[r][i]) dp[r][i]=maxn[i],from[r][i]=maxpos[i]; &#125; &#125; printf("%d\n",dp[k][n]); tot=0;getans(k,n);reverse(List+1,List+k+1); for (register int i=1;i&lt;=k-1;i++) printf("%d ",List[i]); printf("\n"); &#125;#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Codeforces</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #260][六校联合训练 #7]环 题解]]></title>
    <url>%2Fblog%2Fnflsoj260%2F</url>
    <content type="text"><![CDATA[Description对于一张 n 个点的竞赛图 G，其中 e 条边的方向已经确定，剩下的边朝向是两边等概率的。 求 G 中最小环的期望个数对 1e9+7 取模的结果。 特别地，若 G 无环，则我们认为这种情况下最小环个数为 0。 Input第一行两个数 n,e。 接下来 e 行，每行两个数 x,y 表示一条确定的边。 Output输出一行一个数表示答案。 Sample 1 &amp; 2见下发文件。 Constraints对于 30% 的数据，n≤300。 对于另 20% 的数据，e=0。 对于另 20% 的数据，e=n(n−1)/2。 对于 100% 的数据，1≤n≤1e5，1≤e≤1e6。 Solution竞赛图有这样一个性质：整张图要么是一个DAG，要么存在三元环。因为考虑每一个三元组(i,j,k)，根据抽屉原理三条边至少有两条边是同向的，此时第三条边如果和前两条同向就形成了三元环，否则就是一个DAG。(这里同向指顺时针和逆时针) 于是这题变成了竞赛图三元环计数，有一种线性的做法：考虑容斥，所有的无序三元组(i,j,k)的个数是$C_N^3$，考虑减去那些不是三元环的三元组，我们发现对于一个不是三元环的三元组，有且仅有一个点的度数为2，我们考虑在这种点上统计个数。 我们枚举每一个点，将其出边两两搭配就能得到所有的非三元环情况，注意每个点的n-1条边中有些边确定是出边，设数量为$p$，有些边确定不是出边，还有一些边没有定向，有$\frac{1}{2}$的概率是出边，设数量为$q$，于是一个点的答案是$\frac{p(p-1)}{2}+p\cdot \frac{q}{2}+\frac{q(q-1)}{2}\cdot \frac{1}{4}$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,e;int cnt[MAXN+48],deg[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(e); int x,y; for (register int i=1;i&lt;=e;i++) &#123; io.Get(x);io.Get(y); cnt[x]++;cnt[y]++;deg[x]++; &#125; int i2=quick_pow(2,MOD-2),i8=1ll*i2*i2%MOD*i2%MOD,i6=quick_pow(6,MOD-2); int ans=1ll*n*(n-1)%MOD*(n-2)%MOD*i6%MOD; for (register int i=1;i&lt;=n;i++) &#123; Sub(ans,1ll*deg[i]*(deg[i]-1)%MOD*i2%MOD); int doubt=(n-1)-cnt[i]; Sub(ans,1ll*deg[i]*doubt%MOD*i2%MOD); Sub(ans,1ll*doubt*(doubt-1)%MOD*i8%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #233][McfXH AK Contest #2]染色 题解]]></title>
    <url>%2Fblog%2Fnflsoj233%2F</url>
    <content type="text"><![CDATA[Problem StatementWXH是天下第一的。一日，他正向众生播撒福音： WXH说——要有树。于是这世上便有了树：一棵n个节点的冒金光的树。 WXH说——要有颜色。于是这树上便有了颜色：n个节点依次从WXH处得到了WXH无私的馈赠—— m种颜色之一。 WXH说——同样的颜色不能靠的太近，也不能太远。于是，所有同色点对距离的最小值介于[L,R]之间的树被留下，而剩余的都被销毁。 WXH发现了一旁的你。WXH对你的无礼感到愤怒，并打算把你做成树的肥料。 你为了证明自己的价值，决定求出WXH一共能够得到多少棵不同的树。 WXH是慈悲的，因而你只要求出这个值对1,000,000,007取模的结果即可。 两棵树是不同的，当且仅当存在至少一个节点得到的颜色不同。 Input第一行四个空格隔开的整数 n,m,L,R,分别表示树的点数WXH的颜色数，以及 WXH钦定的最小值范围。 接下来 n−1行，每行两个空格隔开的整数 u,v，表示这棵冒金光的树上有一条边连接 u 与 v。 Output一行一个整数，表示不同的树的个数对 1,000,000,007取模的结果。 Sample Input3 3 1 2 1 2 2 3 Sample Output21 Sample Explanation除了三个点颜色互不相同的 3!=6种树之外，剩余的 27−6=21 棵树都是可能出现的。 Constraints对于所有数据，1≤n≤1e5，1≤m≤1e9，1&lt;=l,r&lt;=n-1 Subtask 1（15%）：n,m≤5； Subtask 2（10%）：L=R=n−1； Subtask 3（15%）：L=R=1； Subtask 4（20%）：n≤5000； Subtask 5（25%）：L=R； Subtask 6（15%）：无特殊限制。 by diamond_duke PS：由于某天下第一选手被卡常了，本题时限放宽为 1666 ms（std 在最慢的测试点上的运行时间只要约 300 ms）。 PPS：此题数据可能较弱，因此本题开放 hack，请不要恶意 hack。 Solution此题思路略难（逃 首先可以容斥，我们将问题转化成计算（最近点对距离大于等于L的方案数）减去（最近点对距离大于等于R+1的方案数），这样我们只要解决（最近点对距离大于等于x的方案数）这样一个子问题。 考虑最近点对距离大于等于x的这个约束，相当于对于所有距离小于x的点对，这两个点的颜色要求不同。进一步我们发现，对于每个点对只要用深度小的点去约束深度大的点，每个点最终可选的颜色数就是m-约束个数，因为如果有两个点A,B都能约束C，则A,B距离必然小于x，所以A,B的颜色必定不一样。 于是我们可以按照bfs序对原树进行搜索，每搜索到一个点，就查找一下已经被“激活”的点中有多少个和他距离小于x，乘到ans中，再将当前点“激活”即可。 接下来考虑如何计算与当前点距离小于x的点的个数。考虑点分树，即每个重心向以重心为根的所有孩子的子树的重心连边。这样的树的很好的性质是从任意点出发到根的距离都是log级别的。考虑从当前点的重心点出发顺着点分树向上走，每次计算过该重心的路径。从出发点到当前重心有一个距离dis，所以我们要查找当前重心所在树中深度不超过x-dis的点的个数（这个值根据树的深度标号方法可能有一点小出入），这个我们可以对每个重心建一个BIT来维护，但是要注意我们还要减去当前点所在子树的一些不合法的路径，所以还要记录当前点在重心的哪个儿子下面，在这个儿子的BIT里面再算一波。更新的时候就沿着点分树向各个BIT里面插就行了。 时间总复杂度$O(nlog^2n)$，码量略大。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m,L,R;vector&lt;int&gt; v[MAXN+48];int sgn[MAXN*80+48],toc[MAXN+48],tod[MAXN*80+48];int Head[MAXN*80+48],nxt[MAXN*80+48],to[MAXN*80+48],etot=1;inline void addedge(int s,int t) &#123;to[++etot]=t;nxt[etot]=Head[s];Head[s]=etot;&#125;int anc[MAXN+48][21];int depth[MAXN+48];int seq[MAXN*5+48],pos[MAXN*5],stot;inline void dfs_anc(int cur,int father)&#123; seq[++stot]=cur;pos[cur]=stot; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father) &#123; anc[y][0]=cur; depth[y]=depth[cur]+1;dfs_anc(y,cur); seq[++stot]=cur; &#125; &#125;&#125;int ST[MAXN*5+48][21],Log[MAXN*5+48];inline void init_dist()&#123; depth[1]=1;dfs_anc(1,-1); assert(stot&lt;=MAXN*5); for (register int i=1;i&lt;=stot;i++) ST[i][0]=depth[seq[i]]; for (register int j=1;j&lt;=20;j++) for (register int i=1;i&lt;=stot;i++) &#123; ST[i][j]=ST[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=stot) ST[i][j]=min(ST[i][j],ST[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (register int i=2;i&lt;=stot;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int getlca(int u,int v)&#123; int l=pos[u],r=pos[v]; if (l&gt;r) swap(l,r); int k=Log[r-l+1]; return min(ST[l][k],ST[r-(1&lt;&lt;k)+1][k]);&#125;inline int getdist(int x,int y) &#123;return depth[x]+depth[y]-2*getlca(x,y);&#125;int id=0;namespace BIT&#123; int c[MAXN*80+48]; int starter[MAXN*3+48],len[MAXN*3+48];int tot; inline void clear() &#123;for (register int i=1;i&lt;=tot;i++) c[i]=0;&#125; inline void Create(int ind,int l) &#123; starter[ind]=tot+1;len[ind]=l; tot+=l; &#125; inline void update(int ind,int x,int delta) &#123; x+=starter[ind]-1; int N=starter[ind]+len[ind]-1; while (x&lt;=N) c[x]+=delta,x+=LOWBIT(x); &#125; inline int query(int ind,int x) &#123; int res=0;x+=starter[ind]-1; x=min(x,starter[ind]+len[ind]-1); while (x&gt;=starter[ind]) res+=c[x],x^=LOWBIT(x); return res; &#125; inline int calc(int ind,int left,int right) &#123;return query(ind,right)-query(ind,left-1);&#125;&#125;int sz[MAXN+48];bool visited[MAXN+48];inline void init(int cur,int father)&#123; sz[cur]=1; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y]) init(y,cur),sz[cur]+=sz[y]; &#125;&#125;inline int getroot(int cur,int father,int Sz)&#123; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; int y=v[cur][i]; if (y!=father &amp;&amp; !visited[y] &amp;&amp; sz[y]&gt;Sz/2) return getroot(y,cur,Sz); &#125; return cur;&#125;int q[MAXN+48];int head,tail;inline void doit(int id,int Sz,int Sgn)&#123; sgn[id]=Sgn; BIT::Create(id,Sz);&#125;inline void dfs(int cur,int father)&#123; init(cur,-1); doit(++id,sz[cur],-1);tod[id]=cur; if (father!=-1) addedge(id,father); int rt=getroot(cur,-1,sz[cur]); doit(++id,sz[cur],1);visited[rt]=true;int cid=id;toc[rt]=cid;tod[id]=rt; if (father!=-1) addedge(id,id-1); for (register int i=0;i&lt;int(v[rt].size());i++) &#123; int y=v[rt][i]; if (!visited[y]) dfs(y,cid); &#125;&#125;inline int querygo(int cur,int Len)&#123; int res=0,ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); if (sgn[i]==1) res+=BIT::calc(i,1,Len-dis); else res-=BIT::calc(i,1,Len-dis-2); &#125; return res;&#125;inline void updatego(int cur)&#123; int ori=tod[cur]; for (register int i=cur;i;i=to[Head[i]]) &#123; int rt=tod[i],dis=getdist(ori,rt); BIT::update(i,dis+1,1); &#125;&#125;bool vv[MAXN+48];inline int solve(int Len)&#123; head=tail=1;q[head]=1; memset(vv,false,sizeof(vv)); int res=1;BIT::clear(); while (head&lt;=tail) &#123; int x=q[head++];vv[x]=true; res=1ll*res*(m-querygo(toc[x],Len))%MOD; updatego(toc[x]); for (register int i=0;i&lt;int(v[x].size());i++) &#123; int y=v[x][i]; if (!vv[y]) q[++tail]=y; &#125; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);io.Get(L);io.Get(R); int x,y; for (register int i=1;i&lt;=n-1;i++) &#123; io.Get(x);io.Get(y); v[x].pb(y);v[y].pb(x); &#125; init_dist(); dfs(1,-1); io.Print(sub(solve(L)-solve(R+1)),'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;fixed&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数学</category>
        <category>数据结构</category>
        <category>容斥原理</category>
        <category>BIT</category>
        <category>点分树</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>NFLSoj</tag>
        <tag>清华集训模拟</tag>
        <tag>点分树</tag>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP模拟赛]number 题解]]></title>
    <url>%2Fblog%2Fnumber%2F</url>
    <content type="text"><![CDATA[Description对于所有长度为$k$的满足$\sum_{i=1}^na_i=n$的不下降数列{$a_k$},其权值为$\sum_{i=1}^na_i^m$，求所有满足条件的数列的权值和。 数据范围: $n,m,k&lt;=4096$ Solution非常好的dp题 这题显然的一个思路是用类似背包的dp,令$dp[i][j][k]$表示当前考虑到第$i$个数，所有数的和是$j$，最大的数是$k$的方案数,转移的时候还要考虑下一个数是多少，所以这个dp是$O(n^4)$的，不能接受。 给出一个比较难想的dp思路:令$dp[i][j]$表示当前数列有$i$个数，和为j的方案数，有两种转移： 所有的数都加1，$dp[i][j]\rightarrow dp[i][j+i]$ 在数列的最前面添加一个1，$dp[i][j]\rightarrow dp[i+1]][j+1]$ 可以发现按照这个dp构造数列的方法，所有的满足条件的数列都能不重不漏的构造出来。 现在我们已经知道了方案数，考虑如何计算最后的权值。我们考虑对于一个数$x$，$dp[k-1][n-x]$对应的是序列中至少有一个$x$的方案数，$dp[k-2][n-2x]$对应的是序列中至少有两个$x$的方案数，以此类推。我们发现一个有$num$个$x$的序列会正好在$num$个“至少”的方案数中出现一次，所以我们只要枚举$x$和$num$，累加$dp[k-num][n-x\cdot num] *x^m$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=4096;int n,k,m;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("number.in","r",stdin); freopen ("number.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);io.Get(m); dp[0][0]=1; for (register int i=0;i&lt;=k-1;i++) for (register int j=0;j&lt;=n;j++) if (dp[i][j]) &#123; Add(dp[i+1][j+1],dp[i][j]); if (j+i&lt;=n) Add(dp[i][j+i],dp[i][j]); &#125; int ans=0; for (register int i=1;i&lt;=n;i++) &#123; int base=quick_pow(i,m); for (register int j=1;j&lt;=k &amp;&amp; i*j&lt;=n;j++) Add(ans,1ll*base*dp[k-j][n-i*j]%MOD); &#125; io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3636]教义问答手册 题解]]></title>
    <url>%2Fblog%2Fbzoj3636%2F</url>
    <content type="text"><![CDATA[Description“汉中沃野如关中，四五百里烟蒙蒙。黄云连天夏麦熟，水稻漠漠吹秋风。”——摘自 黄裳《汉中行》 “泉岭精神不朽，汉中诸球永生。”——摘自《泉岭精神创立者语录》 “把神犇烤一烤，味道会更好。”——摘自《xhr语录》 “秀恩爱有利于身心健康！”——摘自《泉岭精神集大成者语录》 “楼上说的对！”——摘自《泉岭精神信徒语录合集》 “不会做积分，怎么找妹子！”——摘自《xhr语录》 “切实保护耕地以放置更多的哨戒炮。”——摘自《泉岭精神信徒语录合集》 “就算两个包子一起吃掉，也不能阻止我修筑梯田。”——摘自《泉岭精神创立者语录》 “我来自泉岭，他来自汉中，我们半道而逢。”——摘自《泉岭精神集大成者语录》 作为泉岭精神的缔造者、信奉者、捍卫者、传承者，Pear决定印制一些教义问答手册，以满足泉岭精神日益增多的信徒。Pear收集了一些有关的诗选、语录，其中部分内容摘录在了【题目背景】里。这些语录是按出现的时间排好序的——Pear很喜欢这样的作风，于是决定在按时间排好序的基础上，选择部分语录，制作成若干本教义问答手册。 一共有N条语录。Pear决定从中选出某一段时间内的所有语录，在此基础上印制大小为L的若干本教义问答手册。Pear对印制的手册有如下要求： 1.每本手册必须包含这个区间内连续的恰好L条语录。 2.不同手册包含的语录不能相同。 3.每条语录有一个“主题相关程度”，这个数可正可负。Pear希望所有手册的语录的“主题相关程度”之和尽可能大。 例如，对于区间[3,15]和L=3，一种选择方法是：[4,6]+[9,11]+[12,14]。这三个区间长度都恰好为L，且互不重叠。 Pear并没有决定选哪段时间的语录，因此他有Q次询问。每次询问，给出两个数[l,r]表示候选语录的范围是第l条到第r条。你能回答出每个询问的最大“主题相关程度”之和么？ Input第一行两个正整数N，L，含义如上所述。注意对于所有询问，L都是一样的。 第二行N个整数，绝对值&lt;=10000。第i个数表示第i条语录的“主题相关程度”。 接下来Q行，每行两个正整数l和r，表示询问区间。 Output输出Q行，每行表示这组询问的答案。注意，这个答案可以是0，如果区间负数过于多的话。 Sample Input15 3 3 1 5 -2 3 -2 -2 2 2 2 0 3 2 -1 0 9 8 10 10 10 9 11 2 14 5 14 5 13 12 13 7 13 2 10 Sample Output6 0 4 17 11 11 0 11 12 HINT【数据范围】 对于10%的数据，N=1000,Q=1000,L&lt;=50 对于另外20%的数据，N=100000,Q=100000,L&lt;=5 对于另外20%的数据，N=100000,Q=100000,L&lt;=10 对于100%的数据，N=100000,Q=100000,L&lt;=50 Source2014年国家集训队十五人互测 Solution这样的题目还是很有启发性的 刚开始看到这样的区间询问，想到的肯定是线段树，但线段树不能只求当前区间的最值，否则无法支持合并。所以我们对每个区间都要维护$L^2$个状态，令$f[x][y]$表示左边$x$个不选，右边$y$个不选的最大值，然后合并两个区间的时候需要枚举跨两边的一个长度为$L$的区间的位置，这样总复杂度是$O(nlognL^3)$，显然是不能通过的。 如果没有$Q$次询问，只是求整个区间的最大选择方案，那我们有一个显然的dp做法：令$dp[i]$表示当前考虑到第$i$个数的最大方案，显然有两种转移：不选这个数，从$dp[i-1]$转移来，或者选这个数所在的一个长度为$L$的区间，从$dp[i-L]+sum(i-L+1,i)$转移来，于是状态转移方程为$$dp[i]=max(dp[i-1],dp[i-L]+sum(i-L+1,i)$$ 如果有多次询问，考虑离线后分治。在$solve(l,r)$的时候，我们只处理跨过该块中间点$(l+r)/2$的区间，完全在左边和完全在右边的区间递归下去处理。 考虑如何处理跨中间的询问，其实处理方法和线段树的区间合并差不多，我们向左向右分别维护$L$个dp状态，$dp1[i][j]$表示从$mid$开始向前的$i$个点没选，从后向前考虑到$j$时的最大方案，$dp2[i][j]$表示从$mid+1$开始向后的$i$个点没选，从前向后考虑到$j$时的最大方案，这两个dp的转移和之前是一样的。然后要么拿两边的max更新，要么枚举跨中间的一个长度为$L$的区间更新，这样复杂度是一个$L$的，因为相当于你在线段树上只求母区间的$f[0][0]$ 分治的总复杂度$O(nlognL)$，可以通过。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,L,Q;int a[MAXN+48],sum[MAXN+48];int ans[MAXN+48];inline int calc(int left,int right) &#123;return sum[right]-sum[left-1];&#125;struct Query&#123; int l,r,ind; inline void input() &#123;io.Get(l);io.Get(r);&#125;&#125;q[MAXN+48],tmp1[MAXN+48],tmp2[MAXN+48],tmp3[MAXN+48];int tot1,tot2,tot3;int dp1[51][MAXN+48],dp2[51][MAXN+48];inline void solve(int l,int r,int ql,int qr)&#123; if (l&gt;r) return; if (l==r) &#123; for (register int i=ql;i&lt;=qr;i++) ans[q[i].ind]=((a[l]&gt;=0 &amp;&amp; L&lt;=1)?a[l]:0); return; &#125; int mid=(l+r)&gt;&gt;1;tot1=tot2=tot3=0; for (register int i=ql;i&lt;=qr;i++) &#123; if (q[i].r&lt;=mid) &#123;tmp1[++tot1]=q[i];continue;&#125; if (q[i].l&gt;=mid+1) &#123;tmp2[++tot2]=q[i];continue;&#125; tmp3[++tot3]=q[i]; &#125; int pt=ql,ll=ql+tot1-1,rr=qr-tot2+1; for (register int i=1;i&lt;=tot1;i++) q[pt++]=tmp1[i]; for (register int i=1;i&lt;=tot3;i++) q[pt++]=tmp3[i]; for (register int i=1;i&lt;=tot2;i++) q[pt++]=tmp2[i]; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp1[gap][mid-gap+1]=0; for (register int i=mid-gap;i&gt;=l;i--) &#123; dp1[gap][i]=dp1[gap][i+1]; if (mid-gap-i+1&gt;=L) check_max(dp1[gap][i],dp1[gap][i+L]+calc(i,i+L-1)); &#125; &#125; for (register int gap=0;gap&lt;=L-1;gap++) &#123; dp2[gap][mid+gap]=0; for (register int i=mid+1+gap;i&lt;=r;i++) &#123; dp2[gap][i]=dp2[gap][i-1]; if (i-(mid+1+gap)+1&gt;=L) check_max(dp2[gap][i],dp2[gap][i-L]+calc(i-L+1,i)); &#125; &#125; for (register int i=1;i&lt;=tot3;i++) &#123; ans[tmp3[i].ind]=dp1[0][tmp3[i].l]+dp2[0][tmp3[i].r]; for (register int j=mid;j&gt;=mid-(L-1)+1;j--) if (j&gt;=tmp3[i].l &amp;&amp; j+L-1&lt;=tmp3[i].r) check_max(ans[tmp3[i].ind],calc(j,j+L-1)+dp1[mid-j+1][tmp3[i].l]+dp2[j+L-1-(mid+1)+1][tmp3[i].r]); &#125; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid-gap+1;i&gt;=l;i--) dp1[gap][i]=0; for (register int gap=0;gap&lt;=L-1;gap++) for (register int i=mid+gap;i&lt;=r;i++) dp2[gap][i]=0; solve(l,mid,ql,ll);solve(mid+1,r,rr,qr);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(L); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),sum[i]=sum[i-1]+a[i]; io.Get(Q); for (register int i=1;i&lt;=Q;i++) q[i].input(),q[i].ind=i; solve(1,n,1,Q); for (register int i=1;i&lt;=Q;i++) io.Print(ans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM198DIV1C]Soma 题解]]></title>
    <url>%2Fblog%2Ftcsrm198div1c%2F</url>
    <content type="text"><![CDATA[DescriptionSoma is a three dimensional puzzle invented by Piet Hein. You have seven pieces which are formed by joining cubes at their faces. (They are all of the non-convex shapes that can be so formed with four or fewer cubes). Six of the pieces are formed from four cubes and one is formed by three cubes. There are 27 cubes total. The pieces can be described by the following arrays which show how high cubes are stacked in each grid cell, and are also shown in the picture below. 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 1 1 0 0 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 2 &nbsp;&nbsp;&nbsp;&nbsp; 2 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 2 1 0 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 &nbsp;&nbsp;&nbsp;&nbsp; 0 1 The pieces can be translated and rotated into any orientation, to build larger shapes, but can not be reflected (as in a mirror) or disassembled. Pieces may touch, but not intersect. Each piece is used exactly once in a solution. Given pattern (a shape composed of 27 cubes, not necessarily connected), try to arrange the seven soma pieces into the same shape as pattern. In other words, you are constructing pattern using the seven pieces. Return the number of distinct solutions for pattern. What is meant by “distinct”: In a valid solution each cube in pattern will be occupied by a cube from exactly one of the seven pieces. You could assign a number between 1 and 7 inclusive to each pattern cube to indicate which piece occupies that pattern cube. Two solutions are distinct if this assignment is different at one or more pattern cubes. Thus removing a piece which has rotational symmetry, rotating it, and putting it back “in the same place” does not produce a new distinct solution. But a rearrangement of some or all of the pieces which is equivalent to rotating or reflecting the entire pattern (assuming pattern has such symmetry) is considered distinct by this definition. For example the pattern, “21112”, can be constructed in exactly two distinct ways using the pieces “211” and “12”. The distinct ways are “211”-“12” and “21”-“112”. The pattern will be specified in a String[] similar to the arrays showing the individual pieces above. Each character indicates how many cubes are stacked at that location, starting from a common plane at a height of zero. For example: {“333”, “333”, “333”} specifies a 3x3x3 cube which is possible to construct with the seven soma pieces in 11520 distinct (as defined above) ways, so return 11520. DefinitionClass: Soma Method: letMeCountTheWays Parameters: String[] Returns: int Method signature: int letMeCountTheWays(String[] pattern) (be sure your method is public) Notes If no rotational symmetries are involved, there are 24 possible orthogonal orientations resulting from rotations in three dimensions. Visualize the 3x2 “L” shaped piece (which has no rotational symmetry). The top (long end) of the “L” can point in six directions x,y,z,-x,-y,-z. For each of those, the short leg of the “L” can point in one of four directions. 6 x 4 = 24 Each of the other six pieces does have some rotational symmetry, and thus fewer possible distinct orientations. The rotation of a point about a line passing through the origin can be calculated using a single, vector by matrix, multiplication: [x y z]*M=[rx ry rz] where M is a 3 by 3 matrix, [x y z] is the original point and [rx ry rz] is the rotated point. Vector by matrix multiplication is defined as: for(i) { r[i]=0 ; for(j) { r[i]+=p[j]*M[j][i] } } where p is the original point and r is the rotated point. The matrix for 90 degree rotation about the x axis is: {&nbsp;{1,0,0},{0,0,1},{0,-1,0}&nbsp;} The matrix for 90 degree rotation about the y axis is: {&nbsp;{0,0,-1},{0,1,0},{1,0,0}&nbsp;} The matrix for 90 degree rotation about the z axis is: {&nbsp;{0,1,0},{-1,0,0},{0,0,1}&nbsp;} The easiest way to generate all possible orthogonal orientations is to rotate about the x axis (0,90,180 or 270 degrees), then about the y axis (0,90,180 or 270 degrees) then about the z axis (0,90,180,270 degrees). That is 64 combinations of rotations (4x4x4). Try all 64 and throw away those that produce duplicate results. Sequences of rotations in three dimensions are non-commutative. The order in which you apply the rotations matters. There are 240 fundamental patterns to form the cube, proven by the great mathematician, Prof. John H. Conway. 240 x 24 rotations x 2 (for mirror reflection) = 11520. There are 96 ways to rotate individual pieces in each of the 11520 “distinct” ways. 11520 x 96 = 1105920 which is the “over a million ways to build a cube” number the manufacturer uses. Constraints pattern will contain between 2 and 27 elements, inclusive. Each element of pattern will consist of between 2 and 27 characters, inclusive. Each element of pattern will have the same number of characters. Each character in each element of pattern will be a digit between ‘0’ and ‘9’ inclusive. The sum of all the digits in pattern will be exactly equal to 27. Examples0) {“333”, “333”, “333”} Returns: 11520 The cube. 1) {“345”, “234”, “123”} Returns: 2800 The crystal. 2) {“3330000”, “0033300”, “0000333”} Returns: 28 The wall. 3) {“21111111”, “21111111”, “21111111”} Returns: 0 The chase lounge, impossible. 4) {“67”, “77”} Returns: 1520 The tower. 5) {“010000000000000000000000000”, “110000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000000”, “000000000000000000000000022”, “000000000000000000000000022”, “000000000000000000000002222”, “000000000000000000000002222”} Returns: 76 Replication. 6) {“11100110001”, “01001100111”, “00000000000”, “20002012011”, “11011001001”} Returns: 1 Disjoint. 7) {“121”, “222”, “121”, “121”, “333”} Returns: 78 The monument. 8) {“020”, “010”, “010”, “020”, “343”, “353”} Returns: 42 The gallows. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution超级大模拟，不仅代码难写，而且搜索的时候还可能超时 首先预处理所有的soma的24种翻转并剔除掉重复的，旋转可以用题面中notes里的矩阵来实现，判断重复可以计算一下两个soma对应点的位移向量，如果全部一样就是相同的soma，只是位置不一样 搜索的时候找第一个没有被覆盖的格子，然后选一个soma往里面放就行 为了避免超时和尽量减少代码量，应该注意：STL处理方便 但是速度慢，内置数组处理较复杂 但是速度快，因此在时间不紧的预处理过程中 尽可能的使用STL模板，在搜索中尽可能使用标准的数组和指针 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n,m;struct Matrix&#123; int b[4][4]; Matrix () &#123;memset(b,0,sizeof(b));&#125; inline void clear() &#123;memset(b,0,sizeof(b));&#125; inline Matrix (int x,int y,int z) &#123;memset(b,0,sizeof(b));b[1][1]=x;b[1][2]=y;b[1][3]=z;&#125; inline void init_I() &#123;for (register int i=1;i&lt;=3;i++) b[i][i]=1;&#125; inline bool operator &lt; (const Matrix &amp;other) const &#123; if (b[1][3]!=other.b[1][3]) return b[1][3]&lt;other.b[1][3]; if (b[1][1]!=other.b[1][1]) return b[1][1]&lt;other.b[1][1]; return b[1][2]&lt;other.b[1][2]; &#125; inline bool operator == (const Matrix &amp;other) const &#123; for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) if (b[i][j]!=other.b[i][j]) return false; return true; &#125; inline Matrix operator + (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]+ma.b[i][j]; return res; &#125; inline Matrix operator - (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) res.b[i][j]=b[i][j]-ma.b[i][j]; return res; &#125; inline Matrix operator * (Matrix ma) &#123; Matrix res;res.clear(); for (register int i=1;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) for (register int k=1;k&lt;=3;k++) res.b[i][j]+=b[i][k]*ma.b[k][j]; return res; &#125;&#125;rx,ry,rz;inline Matrix quick_pow(Matrix x,int y)&#123; Matrix res;res.clear();res.init_I(); while (y) &#123; if (y&amp;1) res=res*x; x=x*x;y&gt;&gt;=1; &#125; return res;&#125;typedef vector&lt;Matrix&gt; soma;struct somapos&#123; int x,y,z; somapos () &#123;&#125; inline somapos(int xx,int yy,int zz) &#123;x=xx;y=yy;z=zz;&#125; inline bool operator &lt; (const somapos &amp;other) const &#123; if (z!=other.z) return z&lt;other.z; if (x!=other.x) return x&lt;other.x; return y&lt;other.y; &#125;&#125;P[48];int tot=0;soma base[48];vector&lt;soma&gt; candidate[48];int Cx[48][48][5],Cy[48][48][5],Cz[48][48][5];int ctot[48],wtot[48];inline soma Move(soma ori,Matrix pos,somapos topos)&#123; Matrix delta;delta.clear(); for (register int i=1;i&lt;=3;i++) delta.b[1][i]=-pos.b[1][i]; delta.b[1][1]+=topos.x;delta.b[1][2]+=topos.y;delta.b[1][3]+=topos.z; for (register int i=0;i&lt;int(ori.size());i++) ori[i]=ori[i]+delta; return ori;&#125;inline soma getsoma(soma ori,int dx,int dy,int dz)&#123; for (register int k=0;k&lt;int(ori.size());k++) for (register int i=2;i&lt;=3;i++) for (register int j=1;j&lt;=3;j++) assert(ori[k].b[i][j]==0); for (register int i=0;i&lt;int(ori.size());i++) &#123; ori[i]=ori[i]*quick_pow(rx,dx); ori[i]=ori[i]*quick_pow(ry,dy); ori[i]=ori[i]*quick_pow(rz,dz); &#125; sort(ori.begin(),ori.end()); return ori;&#125;inline bool issame(soma x,soma y)&#123; Matrix cmp=x[0]-y[0]; for (register int i=1;i&lt;int(x.size());i++) if (!(x[i]-y[i]==cmp)) return false; return true;&#125;inline void init_soma()&#123; for (register int i=1;i&lt;=7;i++) base[i].clear(),candidate[i].clear(); base[1].pb(Matrix(1,1,1));base[1].pb(Matrix(2,1,1));base[1].pb(Matrix(3,1,1));base[1].pb(Matrix(1,2,1)); base[2].pb(Matrix(1,1,1));base[2].pb(Matrix(2,1,1));base[2].pb(Matrix(3,1,1));base[2].pb(Matrix(2,2,1)); base[3].pb(Matrix(2,1,1));base[3].pb(Matrix(3,1,1));base[3].pb(Matrix(1,2,1));base[3].pb(Matrix(2,2,1)); base[4].pb(Matrix(1,1,1));base[4].pb(Matrix(2,1,1));base[4].pb(Matrix(1,2,1)); base[5].pb(Matrix(2,1,1));base[5].pb(Matrix(2,1,2));base[5].pb(Matrix(1,2,1));base[5].pb(Matrix(2,2,1)); base[6].pb(Matrix(1,1,1));base[6].pb(Matrix(1,1,2));base[6].pb(Matrix(1,2,1));base[6].pb(Matrix(2,2,1)); base[7].pb(Matrix(1,1,1));base[7].pb(Matrix(2,1,1));base[7].pb(Matrix(2,1,2));base[7].pb(Matrix(2,2,1)); rx.clear();ry.clear();rz.clear(); rx.b[1][1]=1;rx.b[2][3]=1;rx.b[3][2]=-1; ry.b[1][3]=-1;ry.b[2][2]=1;ry.b[3][1]=1; rz.b[1][2]=1;rz.b[2][1]=-1;rz.b[3][3]=1; for (register int i=1;i&lt;=7;i++) sort(base[i].begin(),base[i].end()); for (register int i=1;i&lt;=7;i++) for (register int dx=0;dx&lt;=3;dx++) for (register int dy=0;dy&lt;=3;dy++) for (register int dz=0;dz&lt;=3;dz++) &#123; soma ns=getsoma(base[i],dx,dy,dz);bool f=true; for (register int j=0;j&lt;int(candidate[i].size());j++) if (issame(candidate[i][j],ns)) &#123;f=false;break;&#125; if (f) candidate[i].pb(ns); &#125;&#125;bool exist[48][48][48];class Soma&#123; int ans; int a[48][48]; inline int dfs(int used) &#123; int res=0; if (used==127) return 1; int tox,toy,toz; for (register int i=1;i&lt;=27;i++) if (exist[P[i].x][P[i].y][P[i].z]) &#123;tox=P[i].x;toy=P[i].y;toz=P[i].z;break;&#125; for (register int i=1;i&lt;=7;i++) if (!(used&amp;(1&lt;&lt;(i-1)))) &#123; for (register int j=1;j&lt;=ctot[i];j++) &#123; int deltax=tox-Cx[i][j][1],deltay=toy-Cy[i][j][1],deltaz=toz-Cz[i][j][1]; bool valid=true; for (register int k=2;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; if (!exist[xx][yy][zz]) &#123;valid=false;break;&#125; &#125; if (valid) &#123; for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=false; &#125; used|=(1&lt;&lt;(i-1)); res+=dfs(used); for (register int k=1;k&lt;=wtot[i];k++) &#123; int xx=Cx[i][j][k]+deltax,yy=Cy[i][j][k]+deltay,zz=Cz[i][j][k]+deltaz; exist[xx][yy][zz]=true; &#125; used^=(1&lt;&lt;(i-1)); &#125; &#125; &#125; return res; &#125; inline void toarray() &#123; for (register int i=1;i&lt;=7;i++) &#123; ctot[i]=int(candidate[i].size()); wtot[i]=((i==4)?3:4); for (register int j=1;j&lt;=ctot[i];j++) for (register int k=1;k&lt;=wtot[i];k++) &#123; Cx[i][j][k]=candidate[i][j-1][k-1].b[1][1]; Cy[i][j][k]=candidate[i][j-1][k-1].b[1][2]; Cz[i][j][k]=candidate[i][j-1][k-1].b[1][3]; &#125; &#125; &#125; public: inline int letMeCountTheWays(vector&lt;string&gt; pattern) &#123; n=int(pattern.size());m=int(pattern[0].size()); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) a[i][j]=pattern[i-1][j-1]-'0'; init_soma();toarray(); tot=0;memset(exist,false,sizeof(exist)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=m;j++) for (register int k=1;k&lt;=a[i][j];k++) &#123; P[++tot]=somapos(i,j,k); exist[i][j][k]=true; &#125; sort(P+1,P+tot+1); for (register int i=1;i&lt;=27;i++) ind[P[i].x][P[i].y][P[i].z]=i; return dfs(0); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; int nn;vector&lt;string&gt; vv;string ss; Soma A; while (cin&gt;&gt;nn) &#123; vv.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;ss,vv.pb(ss); double t=clock(); cout&lt;&lt;A.letMeCountTheWays(vv)&lt;&lt;endl; cerr&lt;&lt;"Time: "&lt;&lt;(clock()-t)/CLOCKS_PER_SEC&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>大模拟</category>
      </categories>
      <tags>
        <tag>TopCoder</tag>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #8E]Beads 题解]]></title>
    <url>%2Fblog%2Fcf8e%2F</url>
    <content type="text"><![CDATA[DescriptionOne Martian boy called Zorg wants to present a string of beads to his friend from the Earth — Masha. He knows that Masha likes two colours: blue and red, — and right in the shop where he has come, there is a variety of adornments with beads of these two colours. All the strings of beads have a small fastener, and if one unfastens it, one might notice that all the strings of beads in the shop are of the same length. Because of the peculiarities of the Martian eyesight, if Zorg sees one blue-and-red string of beads first, and then the other with red beads instead of blue ones, and blue — instead of red, he regards these two strings of beads as identical. In other words, Zorg regards as identical not only those strings of beads that can be derived from each other by the string turnover, but as well those that can be derived from each other by a mutual replacement of colours and/or by the string turnover. It is known that all Martians are very orderly, and if a Martian sees some amount of objects, he tries to put them in good order. Zorg thinks that a red bead is smaller than a blue one. Let’s put 0 for a red bead, and 1 — for a blue one. From two strings the Martian puts earlier the string with a red bead in the i-th position, providing that the second string has a blue bead in the i-th position, and the first two beads i - 1 are identical. At first Zorg unfastens all the strings of beads, and puts them into small heaps so, that in each heap strings are identical, in his opinion. Then he sorts out the heaps and chooses the minimum string in each heap, in his opinion. He gives the unnecassary strings back to the shop assistant and says he doesn’t need them any more. Then Zorg sorts out the remaining strings of beads and buys the string with index k. All these manupulations will take Zorg a lot of time, that’s why he asks you to help and find the string of beads for Masha. InputThe input file contains two integers n and k (2 ≤ n ≤ 50;1 ≤ k ≤ 1016) —the length of a string of beads, and the index of the string, chosen by Zorg. OutputOutput the k-th string of beads, putting 0 for a red bead, and 1 — for a blue one. If it s impossible to find the required string, output the only number -1. ExamplesInput 4 4 Output 0101 NoteLet’s consider the example of strings of length 4 — 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110. Zorg will divide them into heaps: {0001, 0111, 1000, 1110}, {0010, 0100, 1011, 1101}, {0011, 1100}, {0101, 1010}, {0110, 1001}. Then he will choose the minimum strings of beads in each heap: 0001, 0010, 0011, 0101, 0110. The forth string — 0101. Solution考虑按位确定答案，于是我们要能算出对于一个确定的前缀，有多少个合法的数是以这个前缀开头的。 首先我们可以观察到一个性质：所有的答案的第一位肯定是0，否则它的取反串肯定比他小。在确定了第一位是0之后，我们之后在计算个数的时候就不用考虑取反串和它本身的大小问题了 第二我们可以发现当前串的最后一位如果是0，那么原串的取反串的倒串就肯定比原串小；最后一位如果是1，那么原串的倒串肯定比原串小，所以一旦确定了最后一位，我们就又可以少考虑一种情况。 所以在计算个数的时候，我们先枚举最后一位是0还是1，这样我们自始至终就只要考虑原串和其倒串的大小关系或者是原串和其取反倒串的关系。 先讨论最后一位是0的情况，我们考虑按位枚举后缀，后缀的每一位和前缀的一位相对应。如果前缀的对应位是0，那么后缀的对应位放1就肯定是合法的了，中间可以2的若干次方直接计算答案，当然也可以放0继续和前缀匹配，如果前缀的对应位是1，就只能放1和其匹配。 设当前前缀长度是$len$,我们匹配的总位数是$Len=min(len,n-len)$,全部匹配完之后，我们又要分两种情况讨论： $len\geq \frac{n}{2}$,此时整个串已经完全确定，我们还需要检验一下中间的这些位是否满足条件，这个部分比较简单。 $len&lt;\frac{n}{2}$，此时我们中间还有一些空位要填，考虑如何快速计算有多少种填法符合条件，我们可以发现，如果中间填一个回文串肯定是符合条件的，回文串的个数很好计算，相当于将对应的位打包，个数是$2^{\left \lceil \frac{n-Len-Len}{2}\right \rceil}$。对于不是回文串的串，我们发现一个合法的填法取反肯定是不合法的，一个不合法的填法取反肯定是合法的，所以合法的和不合法的填法一一对应，我们用总填法数减去回文的填法数除以二即可 再讨论最后一位是1的情况，大部分和前面是一样的。我们可以一样的按位和前缀匹配，匹配完了之后$len\geq \frac{n}{2}$的做法也是一样的，但在$len&lt;\frac{n}{2}$的时候，非回文的填法还是那样算，但我们发现回文的填法并不全是合法的，如果$n-Len-Len$是偶数是没有问题的，如果是奇数，我们会发现，最中间的那个单独的一位只能是0不能是1，所以这是回文的合法个数等于回文的总个数除以二。 写起来不长，但很容易错。时间复杂度$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;int n;LL k;int a[148];LL pw[148];inline LL Count(int len)&#123; int Len=min(len,n-len);LL res=0; //not reverse for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==1) break; if (a[i]==1 &amp;&amp; a[j]==0) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; bool f=true; for (register int i=1;i&lt;=len;i++) if (a[i]) &#123;f=false;break;&#125; if (f) res--; // 000...0 is not allowed if (len==n) return res; //reverse,a[n]=1; for (register int i=2;i&lt;=Len;i++) if (a[i]==0) res+=pw[n-len-i]; if ((len&lt;&lt;1)&lt;n) &#123; if ((n-Len-Len)%2==0) &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; res+=p+np/2; &#125; else &#123; LL p=pw[(n-Len-Len+1)/2],np=pw[n-Len-Len]-p; p/=2; res+=p+np/2; &#125; &#125; else &#123; bool f=true; for (register int i=Len+1,j=n-Len;i&lt;=j;i++,j--) &#123; if (a[i]==0 &amp;&amp; a[j]==0) break; if (a[i]==1 &amp;&amp; a[j]==1) &#123;f=false;break;&#125; &#125; if (f) res++; &#125; return res;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(k);a[1]=0; pw[0]=1;for (register int i=1;i&lt;=n;i++) pw[i]=pw[i-1]+pw[i-1]; if (Count(1)&lt;k) &#123;printf("-1\n");return 0;&#125; for (register int i=2;i&lt;=n;i++) &#123; a[i]=0; register LL res=Count(i); if (k&gt;res) k-=res,a[i]=1; &#125; for (register int i=1;i&lt;=n;i++) printf("%d",a[i]); printf("\n");#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2018模拟赛]money 题解]]></title>
    <url>%2Fblog%2Fmoney%2F</url>
    <content type="text"><![CDATA[Description给定$n$个节点，有$q$次操作: $0$ $a$ $b$ $c$，表示$a$向$b$连一条有向边，并给$a$赋值$c$ $1$ $a$ $b$，如果$b$是$a$的祖先，输出$a$到$b$路径上的权值最小值（包括$a$的权值，不包括$b$的权值） 保证整张图在任意时刻都是一个森林 $n\leq 100000$,$q\leq 1000000$ Solution非常好的思维题 如果整棵树是静态的，我们肯定希望维护祖先和最小值的倍增表，从而在$log$的时间查询 现在是动态的，但我们发现每个点的祖先和最小值倍增表的值只会添加不会删除，因为每个点的祖先是越来越多的，所以我们只要不重复的修改所有节点的祖先和最小值倍增表，最后的时间复杂度就会是数组的大小$O(nlogn)$ 考虑如何实现，我们对当前的每一颗树维护一个deque,deque里的每个节点又是一个单向链表，表示这棵树这一层的所有节点。 在更新祖先和最小值倍增表的过程中，考虑启发式合并，如果$a$所在的树的深度小于$b$所在的树的深度，我们抓着$a$里面的每个点去更新表格，随着深度的增加，更新的$2^k$的祖先的那个$k$也会增加，有点像two pointers；如果$a$所在的树的深度大于$b$所在的树的深度，我们抓着$b$里面的每个节点去找可能能更新到的$a$的节点，这个也是一个类似two pointers的东西。 在合并树的过程中，我们会发现相同深度的点是很好合并的，只要把第一个链表的结尾接上第二个链表的头就行了，这就是我们用链表存储信息的原因。合并的时候也要启发式，不然复杂度不对。 总时间复杂度$O(nlogn+mlogn)$，注意启发式合并的$log$和处理倍增表的$log$不是叠加的，所以不是$log^2n$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)#define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;struct List&#123; int bg,ed; List () &#123;&#125; inline List(int b,int e) &#123;bg=b;ed=e;&#125;&#125;;struct node&#123; int nxt;&#125;nodes[MAXN+48];inline List join(List x,List y)&#123; nodes[x.ed].nxt=y.bg; return List(x.bg,y.ed);&#125;int root[MAXN+48];struct tree&#123; vector&lt;List&gt; L,R; int sz,szl,szr; inline void clear() &#123;L.clear();R.clear();sz=szl=szr=0;&#125; inline void push_back(List nw) &#123;R.pb(nw);szr++;sz++;&#125; inline void push_front(List nw) &#123;L.pb(nw);szl++;sz++;&#125; inline List getind(int id) &#123;return (id&lt;=szl)?L[szl-id]:R[id-szl-1];&#125; inline void modify(int id,List nw) &#123; if (id&lt;=szl) L[szl-id]=nw; else R[id-szl-1]=nw; &#125;&#125;tree[MAXN+48];inline void init()&#123; for (register int i=1;i&lt;=n;i++) nodes[i].nxt=0,root[i]=i; for (register int i=1;i&lt;=n;i++) tree[i].clear(),tree[i].pb(List(i,i));&#125;int anc[MAXN+48][21],minn[MAXN+48][21];inline int getdepth(int u)&#123; int res=0; for (register int i=20;i&gt;=0;i--) if (anc[u][i]) res+=(1&lt;&lt;i),u=anc[u][i]; return res+1;&#125;inline int jump(int u,int depth)&#123; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),u=anc[u][i]; return u;&#125;inline int getmin(int u,int depth)&#123; int res=INF; for (register int i=20;i&gt;=0;i--) if (depth&gt;=(1&lt;&lt;i)) depth-=(1&lt;&lt;i),res=min(res,minn[u][i]),u=anc[u][i]; return res;&#125;inline int query(int a,int b)&#123; int da=getdepth(a),db=getdepth(b); if (da&lt;=db) return 0; if (jump(a,da-db)!=b) return 0; return getmin(a,da-db);&#125;inline void update(int a,int b,int c)&#123; anc[a][0]=b;minn[a][0]=c; int A=root[a]; int da=tree[A].sz,db=getdepth(b); //update info if (da&lt;=db) &#123; int curdepth=0; for (register int i=1;i&lt;=da;i++) &#123; while ((1&lt;&lt;curdepth)&lt;i) curdepth++; List cur=tree[A].getind(i); for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=i-1+db;j++) for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; else &#123; int curdepth=0; for (register int i=db;i&gt;=1;i--) &#123; while ((1&lt;&lt;curdepth)&lt;(db-i+1)) curdepth++; for (register int j=max(curdepth,1);(1&lt;&lt;j)&lt;=da-1+(db-i+1);j++) &#123; List cur=tree[A].getind((1&lt;&lt;j)-(db-i+1)+1); for (register int nd=cur.bg;nd;nd=nodes[nd].nxt) &#123; anc[nd][j]=anc[anc[nd][j-1]][j-1]; minn[nd][j]=min(minn[nd][j-1],minn[anc[nd][j-1]][j-1]); &#125; &#125; &#125; &#125; //merge int Root=root[jump(b,db-1)],dep=tree[Root].sz; if (da&lt;=db) &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[Root].getind(i); List need=join(tree[A].getind(j),cur); tree[Root].modify(i,need); &#125; for (register int i=dep-db+1;i&lt;=da;i++) tree[Root].pb(tree[A].getind(i)); tree[A].clear(); &#125; else &#123; for (register int i=db+1,j=1;i&lt;=dep &amp;&amp; j&lt;=da;i++,j++) &#123; List cur=tree[A].getind(j); List need=join(cur,tree[Root].getind(i)); tree[A].modify(j,need); &#125; for (register int i=db+da+1;i&lt;=dep;i++) tree[A].pb(tree[Root].getind(i)); for (register int i=db;i&gt;=1;i--) tree[A].pf(tree[Root].getind(i)); tree[Root].clear();root[jump(b,db-1)]=A; &#125;&#125;int lastans=0;inline int getreal(int x) &#123;return (x+lastans)%n+1;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("money.in","r",stdin); freopen ("money.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m); init();int op,a,b,c; while (m--) &#123; io.Get(op);io.Get(a);io.Get(b); a=getreal(a);b=getreal(b); if (!op) io.Get(c),c=getreal(c); if (!op) update(a,b,c); else &#123; lastans=query(a,b); printf("%d\n",lastans); &#125; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>倍增</category>
        <category>启发式合并</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>倍增</tag>
        <tag>启发式合并</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM565DIV1C]UnknownTree 题解]]></title>
    <url>%2Fblog%2Ftcsrm565div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given three int[]s: distancesA, distancesB, and distancesC. Each of these int[]s has exactly N elements. We are interested in trees that satisfy the following conditions: The tree has exactly N + 3 vertices. Each vertex has a different label. The set of all labels is { A, B, C, 0, 1, …, N-1 }. Each edge of the tree has a positive integer length. For each i (0 &lt;= i &lt; N), the distance between the vertex A and the vertex i is distancesA[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex B and the vertex i is distancesB[i]. For each i (0 &lt;= i &lt; N), the distance between the vertex C and the vertex i is distancesC[i]. Find the number of trees that satisfy all of the conditions above, and return the number modulo 1,000,000,009. DefinitionClass: UnknownTree Method: getCount Parameters: int[], int[], int[] Returns: int Method signature: int getCount(int[] distancesA, int[] distancesB, int[] distancesC) (be sure your method is public) Notes The distance between two vertices s and t is defined as the sum of lengths of all edges on the only simple path between s and t. Two trees T1 and T2 are different when T1 has an edge u-v such that in T2 the edge u-v is either not present at all, or it has a different length than the edge u-v in T1. Constraints distancesA, distancesB, and distancesC will contain the same number of elements. distancesA, distancesB, and distancesC will contain between 1 and 50 elements, inclusive. Each element of distancesA, distancesB, and distancesC will be between 1 and 100,000,000, inclusive. Examples0) {1} {2} {3} Returns: 6 1) {1, 2} {1, 2} {1, 2} Returns: 1 2) {5, 4} {3, 2} {2, 1} Returns: 8 3) {2, 4, 2} {1, 3, 3} {4, 6, 4} Returns: 2 4) {4, 6, 1, 5, 3, 2, 5} {4, 2, 3, 1, 3, 2, 1} {5, 7, 2, 6, 4, 3, 6} Returns: 12 5) {6, 4, 5, 6, 8, 1, 5, 6, 4, 2} {4, 2, 3, 4, 6, 1, 3, 4, 2, 2} {6, 4, 5, 6, 8, 3, 5, 6, 4, 4} Returns: 9000 6) {8, 5, 6, 8, 6, 5, 6, 10, 8, 5, 10, 8, 7, 9, 7, 1, 11, 5, 9, 6, 6, 1, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 5, 3, 3, 4, 8, 6, 6, 8, 8, 9, 7, 5} {9, 6, 7, 9, 7, 6, 7, 11, 9, 6, 11, 9, 8, 10, 8, 2, 12, 6, 10, 7, 7, 4, 7, 10, 9, 5, 13, 8, 6, 8, 7, 9, 13, 9, 7, 7, 6, 9, 6, 4, 4, 5, 9, 7, 7, 9, 9, 10, 8, 6} {8, 9, 6, 8, 2, 5, 6, 10, 8, 5, 10, 8, 7, 9, 1, 5, 11, 5, 9, 6, 6, 7, 6, 9, 8, 4, 12, 7, 5, 7, 6, 8, 12, 8, 6, 6, 5, 8, 1, 7, 3, 4, 8, 6, 6, 8, 8, 3, 7, 5} Returns: 770724166 7) {33030780, 30296205, 16842859, 28857842, 37928939, 27190807, 48689043, 33328845, 24254103, 3962046,31043603, 25699520, 11297547, 27045586, 31603483, 23207518, 44089781, 48470539, 52366295, 39786470,45623279, 21593844, 38639305, 27260993, 43899542, 36162768, 21640232, 43580853, 33826577, 30501815,51470990, 2157904, 27823597, 9550575, 39234641, 24163007, 34155133, 42504989, 35821444, 36054200,29026389, 29716374, 41764139, 19392309, 44258194, 19987908, 56722905, 46771885, 32668277, 40665175} {16191697, 13457122, 3776, 12018759, 21089856, 10351724, 31849960, 16489762, 7415020, 12877037,14204520, 8860437, 9035480, 10206503, 14764400, 6368435, 27250698, 31631456, 35527212, 22947387,28784196, 4754761, 21800222, 10421910, 27060459, 19323685, 4801149, 26741770, 16987494, 13662732,34631907, 18996987, 10984514, 7288508, 22395558, 7323924, 17316050, 25665906, 18982361, 19215117,12187306, 12877291, 24925056, 2553226, 27419111, 3148825, 39883822, 29932802, 15829194, 23826092} {19337227, 16602652, 3149306, 15164289, 24235386, 13497254, 34995490, 19635292, 10560550, 16030119,17350050, 12005967, 12188562, 13352033, 17909930, 3215353, 30396228, 34776986, 38672742, 26092917,31929726, 7907843, 24945752, 13567440, 30205989, 22469215, 7946679, 29887300, 20133024, 16808262,37777437, 22150069, 14130044, 10441590, 25541088, 10469454, 20461580, 28811436, 22127891, 22360647,15332836, 16022821, 28070586, 5706308, 30564641, 6294355, 43029352, 33078332, 18974724, 26971622} Returns: 101733071 This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution非常好(fan)的分类讨论题 不妨尝试考虑A,B,C三个点在树中的位置关系，发现无外乎两种：Y字型，即三个点在树上有LCA,和链状。 先考虑Y字型，对于一棵树，它可能是Y字型的条件是树上到A,B,C三个点距离之和最小的点是唯一的，这个点就是A,B,C的LCA，设其为root。确定了这个LCA之后，我们就能确定AB,AC,BC三条链的长度：用root-A,root-B,root-C加一加就有。 接下来我们希望找出root-A,root-B,root-C上的所有点，我们可以发现到A和B距离等于AB且到A和C距离等于AC的点在root-A分支上，同理可以确定出root-B和root-C分支，这里要判掉几个不合法的情况：每个点到A/B/C和root都要有距离且同一个分支上的两个点到root的距离必须不同,每个点最多只能存在于一个分支上。 最后我们要确定这个“电风扇”下面挂的点有多少种方案，我们考虑以A为根把树提起来，尝试为每个不在“电风扇”里的点找父亲，父亲应该满足深度比当前点小且当前点与父亲到A/B/C的距离差相等（这个值实际上是当前点和父亲的边的权值），注意不要漏了A,B,C三个点。 再考虑链状，首先应该枚举中间的关键点是哪一个，这样有三种情况，以A为例，考虑确定AB和AC的长度，以AB为例，如果AB之间有其他点，那么这个点集是到A和到B的距离和最小的点的集合；如果AB之间没有点，那么树上所有的关键点到A和到B的距离差的绝对值应该相等，AC也是同理，这样有12种情况，接下来为每个点确定父亲，过程和上面一样。有些要特判的不合法情况也和上面一样。 在实现上，为了简便，可以把Y型的A,B,C分别与root匹配形成三组两个点的情况解决，链状可以把B和C分别和A匹配形成两组两个点的情况，从而节省代码量。 这题主要难在以下几点： 判断每个分支上有哪些点，要能发现距离和，距离差的性质 对不合法情况的特判比较繁琐 对于每个点找到合法父亲的个数，直接累乘就是方案数，这些方案确实都是合法的，但是一下子就看出来可以直接这样计算并不容易。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+9;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;bool visited[148];int distA[148],distB[148],distC[148],n;inline bool cmpA(int x,int y) &#123;return distA[x]&lt;distA[y];&#125;inline bool cmpB(int x,int y) &#123;return distB[x]&lt;distB[y];&#125;inline bool cmpC(int x,int y) &#123;return distC[x]&lt;distC[y];&#125;class UnknownTree&#123; inline bool equ(int x,int y,int z) &#123;return x==y &amp;&amp; x==z;&#125; inline int Y() &#123; int minn=INF,root=-1; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]&lt;minn) minn=distA[i]+distB[i]+distC[i]; for (register int i=1;i&lt;=n;i++) if (distA[i]+distB[i]+distC[i]==minn) &#123;if (root==-1) root=i; else return 0;&#125; int AB=distA[root]+distB[root],AC=distA[root]+distC[root],BC=distB[root]+distC[root]; memset(visited,false,sizeof(visited));visited[root]=true; vector&lt;int&gt; ptA,ptB,ptC;ptA.clear();ptB.clear();ptC.clear(); for (register int i=1;i&lt;=n;i++) &#123; if (i==root) continue; if (distA[i]+distB[i]==AB &amp;&amp; distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distA[i]&gt;=distA[root]) return 0; ptA.pb(i);visited[i]=true; &#125; if (distA[i]+distB[i]==AB &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distB[i]&gt;=distB[root]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC &amp;&amp; distB[i]+distC[i]==BC) &#123; if (visited[i]) return 0; if (distC[i]&gt;=distC[root]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptA.begin(),ptA.end(),cmpA); sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptA.size())-1;i++) if (distA[ptA[i]]==distA[ptA[i+1]]) return 0; for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-BC)) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-BC)) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int calc(int AB,int AC) &#123; if (!AB || !AC) return 0; vector&lt;int&gt; ptB,ptC;ptB.clear();ptC.clear(); memset(visited,false,sizeof(visited)); for (register int i=1;i&lt;=n;i++) &#123; if (distA[i]+distB[i]==AB) &#123; if (visited[i]) return 0; if (distC[i]!=AC+distA[i]) return 0; ptB.pb(i);visited[i]=true; &#125; if (distA[i]+distC[i]==AC) &#123; if (visited[i]) return 0; if (distB[i]!=AB+distA[i]) return 0; ptC.pb(i);visited[i]=true; &#125; &#125; sort(ptB.begin(),ptB.end(),cmpB); sort(ptC.begin(),ptC.end(),cmpC); for (register int i=0;i&lt;int(ptB.size())-1;i++) if (distB[ptB[i]]==distB[ptB[i+1]]) return 0; for (register int i=0;i&lt;int(ptC.size())-1;i++) if (distC[ptC[i]]==distC[ptC[i+1]]) return 0; int pt[148]; for (register int i=1;i&lt;=n;i++) pt[i]=i; sort(pt+1,pt+n+1,cmpA);int ans=1,cnt; for (register int i=1;i&lt;=n;i++) if (!visited[pt[i]]) &#123; cnt=0; for (register int j=1;j&lt;=i-1;j++) if (distA[pt[i]]&gt;distA[pt[j]] &amp;&amp; equ(distA[pt[i]]-distA[pt[j]],distB[pt[i]]-distB[pt[j]],distC[pt[i]]-distC[pt[j]])) cnt++; if (equ(distA[pt[i]],distB[pt[i]]-AB,distC[pt[i]]-AC)) cnt++; if (equ(distB[pt[i]],distA[pt[i]]-AB,distC[pt[i]]-(AB+AC))) cnt++; if (equ(distC[pt[i]],distA[pt[i]]-AC,distB[pt[i]]-(AB+AC))) cnt++; if (!cnt) return 0; ans=1ll*ans*cnt%MOD; &#125; return ans; &#125; inline int Line(vector&lt;int&gt; B,vector&lt;int&gt; A,vector&lt;int&gt; C) &#123; for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; vector&lt;int&gt; AB,AC;AB.clear();AC.clear(); int maxn=-INF,minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distB[i])),minn=min(minn,myabs(distA[i]-distB[i])); if (maxn==minn) AB.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distB[i]); AB.pb(minn); maxn=-INF;minn=INF; for (register int i=1;i&lt;=n;i++) maxn=max(maxn,myabs(distA[i]-distC[i])),minn=min(minn,myabs(distA[i]-distC[i])); if (maxn==minn) AC.pb(maxn); minn=INF; for (register int i=1;i&lt;=n;i++) minn=min(minn,distA[i]+distC[i]); AC.pb(minn); int res=0; for (auto d1 : AB) for (auto d2 : AC) Add(res,calc(d1,d2)); return res; &#125; public: inline int getCount(vector&lt;int&gt; A,vector&lt;int&gt; B,vector&lt;int&gt; C) &#123; n=int(A.size()); for (register int i=1;i&lt;=n;i++) distA[i]=A[i-1]; for (register int i=1;i&lt;=n;i++) distB[i]=B[i-1]; for (register int i=1;i&lt;=n;i++) distC[i]=C[i-1]; return add(add(add(Y()+Line(B,A,C))+Line(A,B,C))+Line(A,C,B)); &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;int&gt; aa,bb,cc;int nn; UnknownTree A; while (cin&gt;&gt;nn) &#123; aa.clear();bb.clear();cc.clear();int x; for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,aa.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,bb.pb(x); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;x,cc.pb(x); cout&lt;&lt;A.getcount(aa,bb,cc)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>思维</category>
        <category>分类讨论题</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>TopCoder</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #228][六校联合训练 #8]地理课 题解]]></title>
    <url>%2Fblog%2Fnflsoj228%2F</url>
    <content type="text"><![CDATA[Description地理课上，老师给出了一个巨大的地图，由于世界日新月异，会有一些道路在某一时刻被删除，也会有一些道路在某一时刻被修建。这里的道路均为双向的。 老师认为，有一些城市被分在了一个连通块中可以相互到达，而有一些城市不能够相互到达。而他想知道，每个时刻所有连通块大小的乘积是多少？ wzy看到这个地图的时候就蒙了，还好那只上天的喵及时帮助了他。现在他把这个毒瘤的地图拿过来给你，想试试看你能不能求出来。由于答案可能很大，输出乘积mod 1e9+7即可。 Input Format第一行两个数n,m，表示有n个点，m个时刻。接下来mm行每行三个数，要么是1 u v，要么是2 u v，分别表示添加一条无向边和删除一条无向边。 Output Format共m行，每行一个数表示连通块大小乘积mod 1,000,000,007。 Sample Input5 6 1 1 3 1 2 3 1 1 2 1 4 5 1 3 4 2 3 4 Sample Output2 3 3 6 5 6 上面是每个时刻操作后的图。乘积分别为：2×1×1×1=2，3×1×1=3，3×1×1=3，3×2=6，5，3×2=6. Constraints subtask1: 30pts，n≤1,000, m≤2,000n≤1,000, m≤2,000. subtask2: 20pts，满足没有删除操作。 subtask3: 50pts，n,m≤100,000,n,m≤100,000. 保证没有重边自环，不会删除不存在的边。 时间限制2s，空间限制512MB Solution考虑离线做法，对于每条边我们都能确定它存在的时间区间，然后我们在线段树的对应区间上加上这条边 加完之后我们对线段树做dfs,每遍历一个节点，就将这个点上的所有边连到DSU里面，然后向左右继续搜索，这样我们可以确定当我们搜索到叶子时，所有覆盖了这个时刻的边都被加入了DSU，于是可以快速算出答案；在离开一个节点的时候，我们要把这个节点加入的边删掉，于是我们要写一个可撤销的DSU 线段树上所有节点的边数之和是$nlogn$级别，因为要支持撤销，所以DSU中没有路径压缩，只有启发式合并，find_anc也要一个$log$，所以时间复杂度为$O(nlog^2n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1e5;int n,m;int fans[MAXN+48];int ans=1;int inv[MAXN+48];inline void init_inv()&#123; inv[0]=inv[1]=1; for (register int i=2;i&lt;=n;i++) inv[i]=MOD-1ll*(MOD/i)*inv[MOD%i]%MOD;&#125;namespace DSU&#123; int pre[MAXN+48],sz[MAXN+48]; int ptx[MAXN*20+48],pty[MAXN*20+48],szx[MAXN*20+48],szy[MAXN*20+48],tot; inline void init() &#123;tot=0;for (register int i=1;i&lt;=n;i++) pre[i]=i,sz[i]=1;&#125; inline int find_anc(int x) &#123;if (pre[x]==x) return x; return find_anc(pre[x]);&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123; x=find_anc(x);y=find_anc(y); if (sz[x]&gt;sz[y]) swap(x,y); ++tot;ptx[tot]=x;pty[tot]=y;szx[tot]=sz[x];szy[tot]=sz[y]; ans=1ll*ans*inv[sz[x]]%MOD;ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=y;sz[y]+=sz[x]; ans=1ll*ans*sz[y]%MOD; &#125; inline void undo() &#123; int x=ptx[tot],y=pty[tot]; ans=1ll*ans*inv[sz[y]]%MOD; pre[x]=x;sz[x]=szx[tot];sz[y]=szy[tot];tot--; ans=1ll*ans*sz[x]%MOD;ans=1ll*ans*sz[y]%MOD; &#125;&#125;namespace SegmentTree&#123; vector&lt;Pair&gt; edge[MAXN*4+48]; inline void init() &#123;for (register int i=1;i&lt;=MAXN*4;i++) edge[i].clear();&#125; inline void update(int cur,int left,int right,Pair curedge,int l,int r) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123;edge[cur].pb(curedge);return;&#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,curedge,l,mid); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,curedge,mid+1,r); &#125; inline void dfs(int cur,int l,int r) &#123; int cnt=0; for (register int i=0;i&lt;int(edge[cur].size());i++) if (!DSU::issame(edge[cur][i].x,edge[cur][i].y)) &#123; cnt++; DSU::update(edge[cur][i].x,edge[cur][i].y); &#125; if (l==r) fans[l]=ans; else &#123; int mid=(l+r)&gt;&gt;1; dfs(cur&lt;&lt;1,l,mid);dfs(cur&lt;&lt;1|1,mid+1,r); &#125; while (cnt--) DSU::undo(); &#125;&#125;map&lt;Pair,int&gt; Mp;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int op,x,y; SegmentTree::init();DSU::init();Mp.clear();init_inv(); for (register int i=1;i&lt;=m;i++) &#123; io.Get(op);io.Get(x);io.Get(y); assert(x!=y); if (x&gt;y) swap(x,y); if (op==1) Mp[mp(x,y)]=i; else SegmentTree::update(1,Mp[mp(x,y)],i-1,mp(x,y),1,m),Mp[mp(x,y)]=0; &#125; for (map&lt;Pair,int&gt;::iterator iter=Mp.begin();iter!=Mp.end();iter++) if (iter-&gt;y) SegmentTree::update(1,iter-&gt;y,m,iter-&gt;x,1,m); SegmentTree::dfs(1,1,m); for (register int i=1;i&lt;=m;i++) io.Print(fans[i],'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>并查集</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>NFLSoj</tag>
        <tag>并查集</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Regular Contest 092F]Two Faced Edges 题解]]></title>
    <url>%2Fblog%2Farc092f%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given a directed graph with N vertices and M edges. The vertices are numbered 1,2,…,N, and the edges are numbered 1,2,…,M. Edge i points from Vertex ai to Vertex bi. For each edge, determine whether the reversion of that edge would change the number of the strongly connected components in the graph. Here, the reversion of Edge i means deleting Edge i and then adding a new edge that points from Vertex bi to Vertex ai. Constraints 2≤N≤1000 1≤M≤200,000 1≤ai,bi≤N ai≠bi If i≠j, then ai≠aj or bi≠bj. InputInput is given from Standard Input in the following format: N M a1 b1 a2 b2 : aM bM OutputPrint M lines. In the i-th line, if the reversion of Edge i would change the number of the strongly connected components in the graph, print diff; if it would not, print same. Sample Input 13 3 1 2 1 3 2 3 Sample Output 1same diff same The number of the strongly connected components is 3 without reversion of edges, but it will become 1 if Edge 2 is reversed. Sample Input 22 2 1 2 2 1 Sample Output 2diff diff Reversion of an edge may result in multiple edges in the graph. Sample Input 35 9 3 2 3 1 4 1 4 2 3 5 5 3 3 4 1 2 2 5 Sample Output 3same same same same same diff diff diff diff Solution朴素的做法是$O(m^2)$的，考虑优化到$O(nm)$ 我们发现翻转一条边$u\rightarrow v$后连通块个数是否改变主要取决于两点： $v$能否到$u$ $u$能否不经过$u\rightarrow v$这条边到达$v$ 稍微计算一下可以发现，如果上面两条都不满足，连通块个数减一，满足其一连通块个数不变，都满足连通块个数加一 我们枚举每个端点$u$，考虑$u$的所有出边，$v$能否到$u$这件事情是比较容易判断的，我们只要将所有边反向，从$u$做一遍dfs,能到的所有的点就是原图中能到$u$的点，这个部分是$O(m)$的 $u$能否不经过$u\rightarrow v$到$v$比较麻烦，考虑如下做法： 我们将$u$所有指向的点$v_1,v_2…v_k$找出来，然后从$v_1$出发做dfs,要求不经过$u$，找出所有能到的点，然后依次考察$v_2,v_3…v_k$，如果能从$v_1$到的话说明要求的路径存在 再从$v_2$出发做相同的事情，对$v_3,v_4…v_k$做考察，以此类推。这样做看似是$O(m^2)$的，但是注意到如果我们搜到一个已经搜过的点，是不用向下继续搜的，因为“前人”一定已经继续向下搜过了，所以只要每次的visited数组不清空，所有点的搜索复杂度总和就是$O(m)$的 以上我们只考虑了从编号小的点出发走到编号大的点的情况，所以还要再反过来做一次，考虑从编号大的点走到编号小的点的情况 这样，每个点的一轮的总复杂度是$O(m)$，一共$n$个点，总时间复杂度$O(nm)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;template&lt;typename T&gt; inline int quick_pow(int x,T y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;const int MAXN=1000;const int MAXM=2e5;int n,m;vector&lt;Pair&gt; v[MAXN+48];vector&lt;int&gt; vv[MAXN+48];bool visited1[MAXN+48],visited2[MAXN+48],ok[MAXN+48];int ans[MAXM+48];inline void dfs1(int cur)&#123; visited1[cur]=true; for (register int i=0;i&lt;int(vv[cur].size());i++) &#123; register int y=vv[cur][i]; if (!visited1[y]) dfs1(y); &#125;&#125;inline void dfs2(int cur)&#123; visited2[cur]=true; for (register int i=0;i&lt;int(v[cur].size());i++) &#123; register int y=v[cur][i].x; if (!visited2[y]) dfs2(y); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);int x,y; for (register int i=1;i&lt;=m;i++) &#123; io.Get(x);io.Get(y); v[x].pb(mp(y,i));vv[y].pb(x); &#125; for (register int i=1;i&lt;=n;i++) &#123; memset(visited1,false,sizeof(visited1)); memset(visited2,false,sizeof(visited2)); memset(ok,false,sizeof(ok)); dfs1(i);visited2[i]=true; for (register int j=0;j&lt;int(v[i].size())-1;j++) &#123; dfs2(v[i][j].x); for (register int k=j+1;k&lt;int(v[i].size());k++) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; memset(visited2,false,sizeof(visited2)); visited2[i]=true; for (register int j=int(v[i].size())-1;j&gt;=1;j--) &#123; dfs2(v[i][j].x); for (register int k=j-1;k&gt;=0;k--) if (visited2[v[i][k].x]) ok[v[i][k].x]=true; &#125; for (register int j=0;j&lt;int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]); &#125; for (register int i=1;i&lt;=m;i++) printf(ans[i]?"diff\n":"same\n"); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TopCoder SRM337DIV1C]CountPalindromes 题解]]></title>
    <url>%2Fblog%2Ftcsrm337div1c%2F</url>
    <content type="text"><![CDATA[Problem StatementA palindrome is a string that reads the same from left to right as it does from right to left, ignoring spaces. We are building a machine that makes the best palindromes in the world and we need you to make a function that calculates the number of possible results before trying it for the first time. You will be given a String[] words and an int k. Each palindrome generated by the machine will be a single space separated list of words, without leading or trailing spaces, that contains at most k characters (including spaces). Each word is an element of words, and each word can be used zero or more times in each palindrome. Return the number of different palindromes that can be generated by the machine modulo 835454957. DefinitionClass: CountPalindromes Method: count Parameters: String[], int Returns: int Method signature: int count(String[] words, int k) (be sure your method is public) Notes Returning the answer modulo 835454957 means that you have to return the remainder of dividing the answer by 835454957. The empty string does not count as a palindrome. Constraints words will contain between 1 and 50 elements, inclusive. Each element of words will contain between 1 and 15 characters, inclusive. Each character of each element of words will be a lowercase letter (‘a’-‘z’). No two elements of words will be equal. k will be between 1 and 100, inclusive. Examples0) {“tragic”,”cigar”} 24 Returns: 1 The only palindrome with no more than 24 characters is “cigar tragic” with 12 characters. “cigar tragic cigar tragic” is also a valid palindrome, but has 25 characters. 1) {“z”,”zz”} 4 Returns: 5 The 5 different palindromes are (quotes for clarity): “z”,”zz”,”z z”,”z zz”,”zz z”. 2) {“aba”,”acaba”,”baca”,”cac”,”b”,”c”,”a”} 70 Returns: 370786966 Remember to return the answer modulo 835454957. 3) {“hello”} 100 Returns: 0 There is no way to make a palindrome. This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved. Solution考虑dp 从中间向两边dp:设状态$dp[L][i][j][0/1]$，$L$表示当前构造的字符串长度,$0/1$表示当前是左边多出来一截还是右边多出来一截,$i$表示左/右边的最后一个字符串，$j$表示$i$字符串还剩的前缀最后位置/后缀起始位置，$dp[L][i][j][0/1]$里面存个数 转移的时候，我们只要枚举下一个接什么字符串，如果当前是左边多出来就向右边接，如果当前是右边多出来就向左边接，能否拼接可以预处理一下。 要注意的是为了避免算重，当恰好回文的时候，我们应该把状态固定在左边(或右边)，且应该固定向左边(或右边)加串，例如”zz zz”这个串先加左边再加右边和先加右边再加左边是一样的，不能算作两种 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=835454957;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;template&lt;typename T&gt; inline T gcd(T x,T y) &#123;return y==0?x:gcd(y,x%y);&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int add(int x,int MO) &#123;if (x&gt;=MO) x-=MO;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int sub(int x,int MO) &#123;if (x&lt;0) x+=MO;return x;&#125;inline void Add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void Add(int &amp;x,int y,int MO) &#123;x=add(x+y,MO);&#125;inline void Sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;inline void Sub(int &amp;x,int y,int MO) &#123;x=sub(x-y,MO);&#125;inline int quick_pow(int x,int y) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y&gt;&gt;=1;&#125;return res;&#125;inline int quick_pow(int x,int y,int MO) &#123;int res=1;while (y) &#123;if (y&amp;1) res=1ll*res*x%MO;x=1ll*x*x%MO;y&gt;&gt;=1;&#125;return res;&#125;class CountPalindromes&#123; int n; char s[148][48];int len[148]; bool table_suf[148][48][148],table_pref[148][48][148]; int dp[148][58][21][2]; inline bool judge_evenpalindrome(int id,int pos) &#123; if (pos&lt;=len[id]-pos) &#123; for (register int i=pos;i&gt;=1;i--) if (s[id][i]!=s[id][pos+pos-i+1]) return false; return true; &#125; else &#123; for (register int i=pos+1;i&lt;=len[id];i++) if (s[id][i]!=s[id][pos-(i-(pos+1))]) return false; return true; &#125; &#125; inline bool judge_oddpalindrome(int id,int pos) &#123; if (pos-1&lt;=len[id]-pos) &#123; for (register int l=1,r=pos+pos-1;l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; else &#123; for (register int l=pos-(len[id]-pos),r=len[id];l&lt;=r;l++,r--) if (s[id][l]!=s[id][r]) return false; return true; &#125; &#125; public: inline int count(vector&lt;string&gt; words,int lim) &#123; n=int(words.size()); for (register int i=1;i&lt;=n;i++) &#123; for (register int j=0;j&lt;int(words[i-1].size());j++) s[i][j+1]=words[i-1][j]; len[i]=int(words[i-1].size());s[i][len[i]+1]='\0'; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i]+1;j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&lt;=min(len[i],j+len[k]-1);p++) if (s[i][p]!=s[k][len[k]-(p-j)]) &#123;f=false;break;&#125; table_suf[i][j][k]=f; &#125; for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) for (register int k=1;k&lt;=n;k++) &#123; bool f=true; for (register int p=j;p&gt;=max(1,j-len[k]+1);p--) if (s[i][p]!=s[k][j-p+1]) &#123;f=false;break;&#125; table_pref[i][j][k]=f; &#125; // cerr&lt;&lt;table_pref[1][3][1]&lt;&lt;"@"&lt;&lt;endl; memset(dp,0,sizeof(dp)); for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_evenpalindrome(i,j)) &#123; if (j&lt;len[i]-j) Add(dp[len[i]][i][j*2+1][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2][0],1); &#125; for (register int i=1;i&lt;=n;i++) for (register int j=1;j&lt;=len[i];j++) if (judge_oddpalindrome(i,j)) &#123; if (j-1&lt;len[i]-j) Add(dp[len[i]][i][j*2][1],1); else Add(dp[len[i]][i][len[i]-(len[i]-j)*2-1][0],1); &#125; for (register int L=1;L&lt;=lim-1;L++) for (register int i=1;i&lt;=n;i++) for (register int j=0;j&lt;=len[i];j++) &#123; if (dp[L][i][j][0]) &#123; if (j==0) &#123; for (register int k=1;k&lt;=n;k++) if (L+len[k]+1&lt;=lim) Add(dp[L+len[k]+1][k][len[k]][0],dp[L][i][j][0]); continue; &#125; for (register int k=1;k&lt;=n;k++) if (table_pref[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (j&gt;=len[k]) Add(dp[L+len[k]+1][i][j-len[k]][0],dp[L][i][j][0]); else Add(dp[L+len[k]+1][k][j+1][1],dp[L][i][j][0]); &#125; &#125; if (dp[L][i][j][1]) for (register int k=1;k&lt;=n;k++) if (table_suf[i][j][k] &amp;&amp; L+len[k]+1&lt;=lim) &#123; if (len[i]-j+1&gt;len[k]) Add(dp[L+len[k]+1][i][j+len[k]][1],dp[L][i][j][1]); else Add(dp[L+len[k]+1][k][len[k]-(len[i]-j+1)][0],dp[L][i][j][1]); &#125; &#125; int ans=0; for (register int L=1;L&lt;=lim;L++) for (register int i=1;i&lt;=n;i++) Add(ans,dp[L][i][0][0]); return ans; &#125;&#125;;#ifdef LOCALint main ()&#123; double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl; vector&lt;string&gt; ss;string s;CountPalindrome A;int nn,kk; while (cin&gt;&gt;nn&gt;&gt;kk) &#123; ss.clear(); for (register int i=1;i&lt;=nn;i++) cin&gt;&gt;s,ss.pb(s); cout&lt;&lt;A.count(ss,kk)&lt;&lt;endl; &#125; io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;#endif]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NFLSoj #228][McfXH AK Contest]比赛 题解]]></title>
    <url>%2Fblog%2Fnflsoj218%2F</url>
    <content type="text"><![CDATA[Problem statement陈太阳非常喜欢打比赛。 最近有 n 个比赛，陈太阳参加第 i 个比赛能获得的快乐值是 ai，他准备选择某些比赛去虐场。 他选择的比赛的快乐值必须满足快乐值不下降，即如果陈太阳参加了第 $i$,$j$ 个比赛，且 $i&lt;j$，则必须有 $a_i\leq a_j$。 陈太阳如果不去打某个比赛他的心里就会难受，并且不打的时间越长他越难受。如果陈太阳选择不打某个比赛，并且他已经在这之前连续选择不打 x 个比赛了，那他就会损失 x+1 的快乐值。 请你计算陈太阳能获得的快乐值的最大值。注意他可以选择不参加所有比赛。 Input第一行一个整数 n。 接下来一行 n 个整数，表示 ai。 Output输出一个整数，表示答案。 Sample Input 17 1 3 2 7 3 2 4 Sample Output 17 Sample Input 27 -3 -4 -2 -2 -6 -8 -1 Sample Output 2-11 Constraints Subtask 11（30 pts）: 1≤n≤5000,1≤n≤5000； Subtask 22（70 pts）: 1≤n≤100000,1≤n≤100000。 Solution如果我们先不考虑不下降子序列的要求，那么这是一个比较显然的dp+斜率优化，推一波式子： $dp[i]$表示以i结尾的最大收益,有状态转移方程:$$dp[i]=a[i]+\max_{j=1}^{i-1}(dp[j]+\frac{(i-j)(i-j-1)}{2})$$ 考虑决策$j$比决策$k$优的条件：$$dp[j]+\frac{(i-j)(i-j-1)}{2}&lt;dp[k]+\frac{(i-k)(i-k-1)}{2}$$ 化简，按照斜率优化的套路移项，我们有$$i&lt;-\frac{(dp[j]-\frac{j(j+1)}{2})-(dp[k]-\frac{k(k+1)}{2})}{j-k}$$ 考虑到$i$是递增的，我们应该把$(j,dp[j]-\frac{j(j+1)}{2})$看做点，用单调队列维护斜率的相反数的一个下凸壳 然而现在还有一个不下降子序列的要求，相当于转移要在一个二维偏序上进行 考虑cdq分治，定义函数$solve(l,r)$表示我们当前正在计算$l$到$r$的dp状态，刚开始我们将数组按照$a[i]$排序，然后我们预处理每个区间的点按照$id$排序的结果$pos$数组，然后先$solve(l,mid)$(注意这里的区间是按照$a[i]$排序的),接着考虑$l$到$mid$对$mid+1$到$r$的贡献,我们按照$pos$数组从$l$到$r$扫描，如果这个点来自$l$就把它加到下凸壳里面，如果这个点来自$r$就在单调队列里面找一个最优决策点，想想可以发现的确是按照二维偏序进行的更新。 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=1e5;int n;int a[MAXN+48],id[MAXN+48];int pos[21][MAXN+48];bool isleft[MAXN+48];LL dp[MAXN+48];int q[MAXN+48];inline void mergesort(int l,int r,int d)&#123; if (l==r) &#123;pos[d][l]=id[l];return;&#125; int mid=(l+r)&gt;&gt;1; mergesort(l,mid,d+1);mergesort(mid+1,r,d+1); for (register int k1=l,k2=mid+1,pt=l;k1&lt;=mid || k2&lt;=r;pt++) &#123; if (k1&gt;mid) &#123;pos[d][pt]=pos[d+1][k2++];continue;&#125; if (k2&gt;r) &#123;pos[d][pt]=pos[d+1][k1++];continue;&#125; if (pos[d+1][k1]&lt;pos[d+1][k2]) pos[d][pt]=pos[d+1][k1++]; else pos[d][pt]=pos[d+1][k2++]; &#125;&#125;inline double calc(int id1,int id2)&#123; LL x1=id1,x2=id2,y1=-dp[id1]+1ll*id1*(id1+1)/2,y2=-dp[id2]+1ll*id2*(id2+1)/2; return double(y2-y1)/double(x2-x1);&#125;inline void solve(int l,int r,int d)&#123; if (l==r) &#123;dp[pos[d][l]]+=a[pos[d][l]];return;&#125; int mid=(l+r)&gt;&gt;1,head=1,tail=0; solve(l,mid,d+1); for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=true; for (register int i=l;i&lt;=r;i++) &#123; int cur=pos[d][i]; if (isleft[cur]) &#123; while (head&lt;tail &amp;&amp; calc(q[tail-1],q[tail])&gt;=calc(q[tail],cur)) tail--; q[++tail]=cur; &#125; else &#123; while (head&lt;tail &amp;&amp; calc(q[head],q[head+1])&lt;cur) head++; if (head&lt;=tail) check_max(dp[cur],dp[q[head]]-1ll*(cur-q[head]-1)*(cur-q[head])/2); &#125; &#125; for (register int i=l;i&lt;=mid;i++) isleft[pos[d+1][i]]=false; solve(mid+1,r,d+1);&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n); for (register int i=1;i&lt;=n;i++) io.Get(a[i]),id[i]=i; sort(id+1,id+n+1,[&amp;](const int &amp;x,const int &amp;y) &#123;if (a[x]!=a[y]) return a[x]&lt;a[y];return x&lt;y;&#125;); for (register int i=1;i&lt;=n;i++) dp[i]=-1ll*i*(i-1)/2; mergesort(1,n,1);solve(1,n,1); LL ans=-1ll*n*(n+1)/2; for (register int i=1;i&lt;=n;i++) check_max(ans,dp[i]-1ll*(n-i+1)*(n-i)/2); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>Dynamic Programming</category>
        <category>斜率优化</category>
        <category>cdq分治</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>NFLSoj</tag>
        <tag>斜率优化</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #908G]New Year and Original Order 题解]]></title>
    <url>%2Fblog%2Fcf908g%2F</url>
    <content type="text"><![CDATA[DescriptionLet S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555. Given a number X, compute modulo $10^9 + 7$. InputThe first line of input will contain the integer X ($1$ ≤ $X$ ≤ $10^{700}$). OutputPrint a single integer, the answer to the question. ExamplesInput 21 Output 195 Input 345342 Output 390548434 NoteThe first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195. Solution很神的dp题 我们尝试考虑每一位的贡献，也就是要算第i位是j的数有多少个 容易想到一个$O(n^3)$的dp:令$dp[i][j][k][l][cmp]$表示当前考虑到第$i$位，大于等于j的数位有k个，j这个数位有l个，当前数与$n$的大小关系是cmp的情况下有多少种情况，转移只要枚举下一个数是多少即可 这样最后在算答案的时候，把这连续的$l$个$j$统计一下贡献即可 然而这题需要$O(n^2)$的复杂度，考虑优化：我们把上面的dp中$l$的那一维去掉，这样算dp的复杂度是$O(n^2)$的，但你会发现答案不好统计了，因为比如如果你有一串3，中间的那些3无法通过差分得到 于是有这样一个神结论：对于每个$sum=dp[n][j][k][0]+dp[n][j][k][1]$，对答案的贡献是$sum*\underbrace{11…111}_{j个1}$ 下面证这个结论的正确性：我们尝试考虑每个数按数位排好序的那个序列是怎样被计算到的 首先对于最左边的数码$x_1$，显然会有$x_1$个长度为n的dp中会算到这个排列，所以会加$x_1$个$\underbrace{11…111}_{n个1}$，一个很好的性质是，如果有若干个连续的相同数码，在上面的dp中非开头位不会体现在某个状态之中，一起跟着开头的那个数位算掉了 然后我们考虑第二小的数码$x_2$，乍一看感觉它会被算$x_2$次，加上前面的$x_1$次就不对了，但我们注意到$x_2$是比$x_1$大的，所以从不大于$x_1$的数码中对$x_2$这位加的贡献其实都不归当前的这个状态，所以实际上这时$x_2$只被计算了$x_2-x_1$次，加上前面的$x_1$次正好是正确的，以此类推，后面的都是正确的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline void add(int &amp;x,int y) &#123;x=add(x+y);&#125;inline void sub(int &amp;x,int y) &#123;x=sub(x-y);&#125;const int MAXN=700;char s[MAXN+48];int n;int dp[MAXN+48][MAXN+48][10][2],ans[MAXN+48][10];int pw[MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.getstring(s+1);n=strlen(s+1); memset(dp,0,sizeof(dp)); for (register int i=0;i&lt;=9;i++) dp[0][0][i][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) for (register int k=0;k&lt;=9;k++) &#123; if (dp[i][j][k][0]) &#123; //to 0 add(dp[i+1][j+(s[i+1]-'0'&gt;=k)][k][0],dp[i][j][k][0]); //to 1 for (register int nxt=0;nxt&lt;=s[i+1]-'0'-1;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][0]); &#125; if (dp[i][j][k][1]) &#123; for (register int nxt=0;nxt&lt;=9;nxt++) add(dp[i+1][j+(nxt&gt;=k)][k][1],dp[i][j][k][1]); &#125; &#125; pw[1]=1; for (register int i=2;i&lt;=n;i++) pw[i]=(1ll*pw[i-1]*10+1)%MOD; int ans=0; for (register int j=0;j&lt;=n;j++) for (register int k=1;k&lt;=9;k++) add(ans,1ll*add(dp[n][j][k][0]+dp[n][j][k][1])*pw[j]%MOD); io.Print(ans,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1045A]Last Chance 题解]]></title>
    <url>%2Fblog%2Fcf1045a%2F</url>
    <content type="text"><![CDATA[DescriptionIt is the year 2969. 1000 years have passed from the moon landing. Meanwhile, the humanity colonized the Hyperspace™ and lived in harmony. Until we realized that we were not alone. Not too far away from the Earth, the massive fleet of aliens’ spaceships is preparing to attack the Earth. For the first time in a while, the humanity is in real danger. Crisis and panic are everywhere. The scientists from all around the solar system have met and discussed the possible solutions. However, no progress has been made. The Earth’s last hope is YOU! Fortunately, the Earth is equipped with very powerful defense systems made by MDCS. There are N aliens’ spaceships which form the line. The defense system consists of three types of weapons: SQL rockets – every SQL rocket can destroy at most one spaceship in the given set. Cognition beams – every Cognition beam has an interval [l,r]and can destroy at most one spaceship in that interval. OMG bazooka – every OMG bazooka has three possible targets, however, each bazooka can destroy either zero or exactly two spaceships. In addition, due to the smart targeting system, the sets of the three possible targets of any two different OMG bazookas are disjoint (that means that every ship is targeted with at most one OMG bazooka). Your task is to make a plan of the attack which will destroy the largest possible number of spaceships. Every destroyed spaceship should be destroyed with exactly one weapon. InputThe first line contains two integers: the number of your weapons N(1≤N≤5000)and the number of spaceships M(1≤M≤5000). In the next N lines, each line starts with one integer that represents type (either 0, 1 or 2). If the type is 0, then the weapon is SQL rocket, the rest of the line contains strictly positive number K(∑K≤100000) and array ki (1≤ki≤M) of K integers. If the type is 1, then the weapon is Cognition beam, the rest of the line contains integers l and r(1≤l≤r≤M). If the type is 2 then the weapon is OMG bazooka, the rest of the line contains distinct numbers a, b and c (1≤a,b,c≤M). OutputThe first line should contain the maximum number of destroyed spaceships —X. In the next X lines, every line should contain two numbers A and B, where A is an index of the weapon and B is an index of the spaceship which was destroyed by the weapon A. Exampleinput 3 5 0 1 4 2 5 4 1 1 1 4 output 4 2 1 3 2 1 4 2 5 NoteSQL rocket can destroy only 4th spaceship. OMG Bazooka can destroy two of 1st, 4th or 5th spaceship, and Cognition beam can destroy any spaceship from the interval [1,4]. The maximum number of destroyed spaceship is 4, and one possible plan is that SQL rocket should destroy 4th spaceship, OMG bazooka should destroy 1st and 5th spaceship and Cognition beam should destroy 2nd spaceship. Solution这题的宗旨是你要相信$1e5$的网络流是能跑的，然后你就真的过了（大雾 网络流的模型还是很显然的，考虑对每种武器建一个点，超级源点向这些点连流量为$1$的边（对于第三种武器，连流量为2的边），每个目标建一个点，这些点向超级汇点连流量为$1$的边 考虑三种武器怎么建： 第一种武器比较简单，从武器点向覆盖的集合连流量为1的边即可 第二种武器是区间，一条一条暴力连肯定会爆炸，考虑用线段树优化建边，我们可以把目标想象成线段树的叶子，然后向上垒出一棵线段树，线段树上的每个点向左右孩子连流量为$INF$的边，然后武器点只要像正常线段树一样查询一波，向所有查询到的区间$(left&lt;=l 且 r&lt;=right)$连边即可，这样点数仍然是$O(m)$的，边数是$O(nlogm)的$ 第三种武器，我们发现很难控制一选就要选两个这个条件，但是我们可以好好利用题目中的性质：任意两个第三种武器的集合是不交的。我们可以发现，只要向武器点连流量为2的边，武器点向对应目标连流量为1的边，不加控制答案就是对的，理由如下： 首先如果这条流量为2的边被流满了，那么它肯定选了两个 如果这条流量为2的边没流，那么它肯定不用选 如果这条流量为2的边流了1，首先可以确定的是，它指向的三个点不可能只有一个被选了，否则因为这个点还能流，所以当前的这个流肯定不是最大流。继而我们发现，我们可以直接把它对应的三个点中，任意一个被其他武器“占领”的点强行占为己有，这样带来的影响是，其他某个武器可能会因此变得无用，但最大流跑出的答案肯定是对的 接下来考虑如何构造答案。根据上面所述，第三种武器是要“抢占”别人的目标的，所以先处理掉。然后我们处理第一种武器，注意如果目标已经被第三种占领了就把这个武器直接扔掉。 第二种武器比较烦，因为比较难从残量网络中直接看出每个武器占用了哪个点，我们只能看出这些武器占领的点的总集合，所以我们换用一个贪心的手法来为每个区间分配一个点：考虑将所有的区间按照左端点从小到大排序，然后我们从左到右枚举每一个目标，这时我们要找出那些区间左端点在这个点左边的可能可行的区间，显然这个集合是单调增的，对于这些区间我们把它扔到按右端点从小到大排序的堆里，每次我们找区间右端点在这个点之右且最靠左的区间来覆盖这个点，这样的贪心策略显然是对的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template &lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template &lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template &lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=5e4;const int MAXM=1e6;int n,m,t,ind;int toid[MAXN+48],tonode[MAXN+48];int L[MAXN+48],R[MAXN+48],type[MAXN+48];bool visited[MAXN+48],chosen[MAXN+48];int head[MAXM+48],cur[MAXM+48],to[MAXM+48],nxt[MAXM+48],f[MAXM+48],tot=1;vector&lt;Pair&gt; ans;int seq[MAXN+48],stot;priority_queue&lt;Pair&gt; q;inline bool cmp_l(int x,int y) &#123;return L[x]&lt;L[y];&#125;inline bool cmp_x(Pair x,Pair y) &#123;return x.y&lt;y.y;&#125;namespace flow&#123; inline void addedge(int s,int t,int cap) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0; &#125; int q[MAXM+48],Head,Tail,depth[MAXM+48]; inline bool bfs() &#123; for (register int i=0;i&lt;=t;i++) depth[i]=-1; depth[0]=0;q[1]=0;Head=Tail=1; while (Head&lt;=Tail) &#123; register int x=q[Head++]; for (register int i=head[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==-1 &amp;&amp; f[i]) &#123; depth[y]=depth[x]+1; q[++Tail]=y; &#125; &#125; &#125; return depth[t]!=-1; &#125; inline int dfs(int x,int maxf) &#123; if (!maxf || x==t) return maxf; int minf,now,ans=0; for (register int &amp;i=cur[x];i;i=nxt[i]) &#123; register int y=to[i]; if (depth[y]==depth[x]+1 &amp;&amp; f[i]) &#123; minf=min(maxf-ans,f[i]); now=dfs(y,minf); f[i]-=now;f[i^1]+=now;ans+=now; if (ans&gt;=maxf) break; &#125; &#125; if (!ans) depth[x]=-1; return ans; &#125; inline int dinic() &#123; int ans=0; while (bfs()) &#123; for (register int i=0;i&lt;=t;i++) cur[i]=head[i]; ans+=dfs(0,INF); &#125; return ans; &#125;&#125;namespace SegmentTree&#123; inline void build(int cur,int left,int right) &#123; if (left==right) &#123; ++ind; toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,n+left,INF); return; &#125; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid);build(cur&lt;&lt;1|1,mid+1,right); ++ind;toid[cur]=ind;tonode[ind]=cur; flow::addedge(ind,toid[cur&lt;&lt;1],INF); flow::addedge(ind,toid[cur&lt;&lt;1|1],INF); &#125; inline void update(int cur,int left,int right,int l,int r,int id) &#123; if (left&lt;=l &amp;&amp; r&lt;=right) &#123; flow::addedge(id,toid[cur],1); return; &#125; int mid=(l+r)&gt;&gt;1; if (left&lt;=mid) update(cur&lt;&lt;1,left,right,l,mid,id); if (mid+1&lt;=right) update(cur&lt;&lt;1|1,left,right,mid+1,r,id); &#125;&#125;int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif io.Get(n);io.Get(m);ind=n+m; SegmentTree::build(1,1,m);int num,x; for (register int i=1;i&lt;=n;i++) &#123; io.Get(type[i]); switch(type[i]) &#123; case 0: &#123; io.Get(num); for (register int j=1;j&lt;=num;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; case 1: &#123; io.Get(L[i]);io.Get(R[i]); SegmentTree::update(1,L[i],R[i],1,m,i); break; &#125; case 2: &#123; for (register int j=1;j&lt;=3;j++) io.Get(x),flow::addedge(i,n+x,1); break; &#125; &#125; &#125; t=ind+1; for (register int i=1;i&lt;=n;i++) if (type[i]!=2) flow::addedge(0,i,1); else flow::addedge(0,i,2); for (register int i=1;i&lt;=m;i++) flow::addedge(n+i,t,1); io.Print(flow::dinic(),'\n'); for (register int i=1;i&lt;=m;i++) for (register int j=head[n+i];j;j=nxt[j]) if (to[j]==t) &#123; if (!f[j]) chosen[i]=true; break; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i],cnt=0; if (type[y]==2 &amp;&amp; f[i]&lt;2) &#123; for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; if (cnt&lt;2) for (register int j=head[y];j &amp;&amp; cnt&lt;2;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !visited[to[j]-n] &amp;&amp; chosen[to[j]-n]) &#123; cnt++; visited[to[j]-n]=true; ans.pb(mp(y,to[j]-n)); &#125; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==0 &amp;&amp; !f[i]) for (register int j=head[y];j;j=nxt[j]) if (n+1&lt;=to[j] &amp;&amp; to[j]&lt;=n+m &amp;&amp; !f[j]) &#123; if (!visited[to[j]-n]) visited[to[j]-n]=true,ans.pb(mp(y,to[j]-n)); break; &#125; &#125; for (register int i=head[0];i;i=nxt[i]) &#123; register int y=to[i]; if (type[y]==1 &amp;&amp; !f[i]) seq[++stot]=y; &#125; sort(seq+1,seq+stot+1,cmp_l);int pt=1; for (register int i=1;i&lt;=m;i++) if (chosen[i] &amp;&amp; !visited[i]) &#123; while (pt&lt;=stot &amp;&amp; L[seq[pt]]&lt;=i) q.push(mp(-R[seq[pt]],seq[pt])),pt++; while (!q.empty() &amp;&amp; -q.top().x&lt;i) q.pop(); assert(!q.empty()); ans.pb(mp(q.top().y,i));q.pop(); &#125; sort(ans.begin(),ans.end(),cmp_x); for (auto y : ans) io.Print(y.x,' '),io.Print(y.y,'\n'); io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>贪心</category>
        <category>线段树</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>最大流</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2134][Code Festival 2016 Final]Zigzag MST 题解]]></title>
    <url>%2Fblog%2Fatcoder2134%2F</url>
    <content type="text"><![CDATA[Problem StatementWe have a graph with N vertices, numbered 0 through N−1. Edges are yet to be added. We will process Q queries to add edges. In the i-th (1≦i≦Q) query, three integers Ai,Bi and Ci will be given, and we will add infinitely many edges to the graph as follows: The two vertices numbered Ai and Bi will be connected by an edge with a weight of Ci. The two vertices numbered Bi and Ai+1 will be connected by an edge with a weight of Ci+1. The two vertices numbered Ai+1 and Bi+1 will be connected by an edge with a weight of Ci+2. The two vertices numbered Bi+1 and Ai+2 will be connected by an edge with a weight of Ci+3. The two vertices numbered Ai+2 and Bi+2 will be connected by an edge with a weight of Ci+4. The two vertices numbered Bi+2 and Ai+3 will be connected by an edge with a weight of Ci+5. The two vertices numbered Ai+3 and Bi+3 will be connected by an edge with a weight of Ci+6. … Here, consider the indices of the vertices modulo N. For example, the vertice numbered N is the one numbered 0, and the vertice numbered 2N−1 is the one numbered N−1. The figure below shows the first seven edges added when N=16,Ai=7,Bi=14,Ci=1: After processing all the queries, find the total weight of the edges contained in a minimum spanning tree of the graph. Constraints2 ≦ N ≦ 200,000 1 ≦ Q ≦ 200,000 0 ≦ Ai,Bi ≦ N−1 1 ≦ Ci ≦ 1e9 InputThe input is given from Standard Input in the following format: N Q A1 B1 C1 A2 B2 C2 : AQ BQ CQ OutputPrint the total weight of the edges contained in a minimum spanning tree of the graph. Sample Input 17 1 5 2 1 Sample Output 121 The figure below shows the minimum spanning tree of the graph: Note that there can be multiple edges connecting the same pair of vertices. Sample Input 22 1 0 0 1000000000 Sample Output 21000000001 Also note that there can be self-loops. Sample Input 35 3 0 1 10 0 2 10 0 4 10 Sample Output 342 Solution对kruskal算法的灵活运用 我们考虑kruskal算法的精髓，不在于每条边连接的是哪两个点，而在于任意两点之间是否连通 对于每组边，首先我们考虑(Bi,Ai+1),因为(Ai,Bi)的边权比(Bi,Ai+1)小，所以我们一定会先处理(Ai,Bi),如果这条边没加进去，说明Ai和Bi已经连通了，如果这条边加进去了，那么此时Ai和Bi变得连通了，于是我们会发现处理(Bi,Ai+1)时Ai和Bi一定是连通的，所以这是Ai+1这个点我们可以改连到Ai上，把这条边换成(Ai,Ai+1) 依次类推，第二条边(Ai+1,Bi+1),Ai+1,Ai,Bi都是连通的，所以我们可以把Bi+1连到Bi上 最终我们会发现，对于每一组边，我们都是先在Ai和Bi之间连边，然后从Ai和Bi出发顺时针连边，所以我们可以把它拆成三部分：Ai和Bi的横跨边，从Ai出发的链和Bi出发的链 Ai和Bi的横跨边一共只有1e5条，可以不管。对于剩下的链,我们会发现一些很好的性质:如果某一条链当前在连的过程中，发现要连的两个点已经连通了，那么可以立刻停止这条链的连接过程，因为注意到每条链的边权都是公差为2的等差数列，所以已经连起来的那条边属于的链后面的边都会比当前链后面的边的边权小，当前链直接被废掉 因为一共只会向图中连n-1条边，所以直接用堆维护这个过程，复杂度正确 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;int n,m;struct node&#123; int A,B,C; inline void input() &#123;io.Get(A);io.Get(B);io.Get(C);&#125;&#125;a[MAXN+48];inline Pair query(int id,int ti)&#123; if (ti==1) return mp(a[id].A,a[id].B); if ((a[id].A+1)%n==a[id].B &amp;&amp; !(ti&amp;1)) return mp(0,0); if (ti&amp;1) &#123; Pair res=mp(a[id].B+ti/2-1,a[id].B+ti/2); res.x%=n;res.y%=n; return res; &#125; else &#123; Pair res=mp(a[id].A+ti/2-1,a[id].A+ti/2); res.x%=n;res.y%=n; return res; &#125;&#125;namespace DSU&#123; int pre[MAXN+48]; inline void init() &#123;for (register int i=0;i&lt;=n;i++) pre[i]=i;&#125; inline int find_anc(int x) &#123;if (pre[x]!=x) pre[x]=find_anc(pre[x]);return pre[x];&#125; inline bool issame(int x,int y) &#123;return find_anc(x)==find_anc(y);&#125; inline void update(int x,int y) &#123;x=find_anc(x);y=find_anc(y);pre[x]=y;&#125;&#125;priority_queue&lt;pair&lt;int,pair&lt;Pair,bool&gt; &gt; &gt; q;int main ()&#123; io.Get(n);io.Get(m); for (register int i=1;i&lt;=m;i++) &#123; a[i].input(); q.push(mp(-a[i].C,mp(mp(a[i].A,a[i].B),false))); if (a[i].A+1!=a[i].B) q.push(mp(-a[i].C-1,mp(mp(a[i].A,(a[i].A+1)%n),true))); q.push(mp(-a[i].C-2,mp(mp(a[i].B,(a[i].B+1)%n),true))); &#125; LL ans=0;DSU::init(); for (register int cnt=0;cnt&lt;n-1;) &#123; int len=q.top().x;Pair res=q.top().y.x;bool type=q.top().y.y;q.pop(); if (DSU::issame(res.x,res.y)) continue; cnt++;ans-=len; DSU::update(res.x,res.y); if (type) &#123; res.x=(res.x+1)%n;res.y=(res.y+1)%n; len-=2; q.push(mp(len,mp(res,type))); &#125; &#125; io.Print(ans,'\n'); io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4934][Ceoi2016]kangaroo 题解]]></title>
    <url>%2Fblog%2Fbzoj4934%2F</url>
    <content type="text"><![CDATA[Description有一个园子，里面有n个草丛排成一排，标号1~n，有一个袋鼠，从s出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达t。显然他会跳跃n-1次为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同，具体地，如果他现在在now,他是从prev跳跃一次到达now的，然后他跳跃一次到达next，那么如果prev &lt; now，就必须有now &lt; next，如果now &lt; prev，就必须有next &lt; now。问从s到t的方案数，模1e9+7两个路线不同，当且仅当草丛被访问的顺序不同保证至少有一种方案初始时可以往任意方向跳。 修正下：那么如果prev &lt; now，就必须有next &lt; now,如果now &lt; prev,就必须有now &lt; next Input 一行三个整数，n，s，t 2&lt;=n&lt;=2000 1&lt;=s&lt;=n 1&lt;=t&lt;=n Output一行一个整数，代表答案 Sample Input4 2 3 Sample Output2 Solution最后的序列肯定长成一个不断上下的折线 如果考虑从左到右确定折线，就不免要维护每个数是否已经被选过，无法逃离指数级的算法 考虑把所有的数从小到大往里面放，我们会发现，如果有一个“上扬“的结构，那它的后面肯定不能再接东西了，否则就会形成一个连续三个的”上扬”,从而不符合题意，也就是一个数只能单独成一块，或者连接两个端点“下垂”的块，除非是$S$或$T$才能去形成“上扬”结构 于是dp的思路就很明显了，考虑$dp[i][j]$表示已经将$1～i$扔进了排列，当前形成了$j$个连通块的方案数 考虑$i+1$的方法 单独建一个新连通块,$dp[i][j]\rightarrow dp[i+1][j+1]$ 如果是$S$或$T$，可以选择一个连通块接在它的前面或后面，但要注意除非$S$和$T$等于$n$，$S$不能和$T$在一个联通块中，否则这个图就连不起来了 连接两个连通块，当前有$j$个连通块，所以显然有$j(j-1)$种连法，但要注意$S$所在的连通块前面不能有连通块，所以如果$i+1&gt;=S$要$-=j$，$T$所在的连通块后面不能有连通块，所以如果$i+1&gt;=T$要$-=j$，这样$TS$型连通块会被减两次，所以如果$i+1&gt;=S$且$i+j&gt;=T$要$+1$，还要注意如果$i+1&lt;n$的话$S$不能和$T$连起来，所以还要减一 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;#define LOWBIT(x) x &amp; (-x)// #define LOCAL trueconst int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;template&lt;typename T&gt; inline void check_max(T &amp;x,T cmp) &#123;x=max(x,cmp);&#125;template&lt;typename T&gt; inline void check_min(T &amp;x,T cmp) &#123;x=min(x,cmp);&#125;template&lt;typename T&gt; inline T myabs(T x) &#123;return x&gt;=0?x:-x;&#125;const int MAXN=2000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,S,T;int dp[MAXN+48][MAXN+48];int main ()&#123;#ifdef LOCAL double TIME=clock(); freopen ("a.in","r",stdin); freopen ("a.out","w",stdout); cerr&lt;&lt;"Running..."&lt;&lt;endl;#endif // io.Get(n);io.Get(S);io.Get(T); scanf("%d%d%d",&amp;n,&amp;S,&amp;T); dp[0][0]=1; for (register int i=0;i&lt;=n-1;i++) for (register int j=0;j&lt;=i;j++) if (dp[i][j]) &#123; // cerr&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;' '&lt;&lt;dp[i][j]&lt;&lt;endl; //create a new node dp[i+1][j+1]=add(dp[i+1][j+1]+dp[i][j]); //add before a node if (i+1==S) &#123; register int valid=j; if (i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //add after a node if (i+1==T) &#123; register int valid=j; if (i+1&gt;=S &amp;&amp; i+1!=n) valid=sub(valid-1); dp[i+1][j]=add(dp[i+1][j]+1ll*dp[i][j]*valid%MOD); &#125; //connect two nodes if (i+1!=S &amp;&amp; i+1!=T &amp;&amp; j&gt;=2) &#123; register int valid=1ll*j*(j-1)%MOD; if (i+1&gt;=S) valid=sub(valid-(j-1)); //can't connect a node before S if (i+1&gt;=T) valid=sub(valid-(j-1)); //can't connect a node after T if (i+1&gt;=S &amp;&amp; i+1&gt;=T) valid=add(valid+1); //T-S is deleted twice if (i+1&gt;=S &amp;&amp; i+1&gt;=T &amp;&amp; i+1!=n) valid=sub(valid-1); //S-T is not allowed dp[i+1][j-1]=add(dp[i+1][j-1]+1ll*dp[i][j]*valid%MOD); &#125; &#125; // io.Print(dp[n][1],'\n'); printf("%d\n",dp[n][1]); // io.flush();#ifdef LOCAL cerr&lt;&lt;"Exec Time: "&lt;&lt;(clock()-TIME)/CLOCKS_PER_SEC&lt;&lt;endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #992E]Nastya and King-Shamans 题解]]></title>
    <url>%2Fblog%2Fcf992e%2F</url>
    <content type="text"><![CDATA[DescriptionNastya likes reading and even spends whole days in a library sometimes. Today she found a chronicle of Byteland in the library, and it stated that there lived shamans long time ago. It is known that at every moment there was exactly one shaman in Byteland, and there were n shamans in total enumerated with integers from 1 to n in the order they lived. Also, each shaman had a magic power which can now be expressed as an integer. The chronicle includes a list of powers of the n shamans. Also, some shamans can be king-shamans, if they gathered all the power of their predecessors, i.e. their power is exactly the sum of powers of all previous shamans. Nastya is interested in whether there was at least one king-shaman in Byteland. Unfortunately many of the powers are unreadable in the list, so Nastya is doing the following: Initially she supposes some power for each shaman.After that she changes the power of some shaman q times (the shamans can differ) and after that wants to check if there is at least one king-shaman in the list. If yes, she wants to know the index of any king-shaman.Unfortunately the list is too large and Nastya wants you to help her. InputThe first line contains two integers n and q (1 ≤ n, q ≤ 2·105). The second line contains n integers a1, …, an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman. After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi. OutputPrint q lines, the i-th of them should contain - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change. If there are multiple king-shamans after each change, print the index of any of them. Examplesinput 2 11 31 2 output -1 input 3 42 2 31 11 22 43 6 output 32-13 input 10 70 3 1 4 6 2 7 8 10 12 51 39 364 104 91 21 0 output 1-19-14-11 NoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2. In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3. Solution注意到$a[i]=sum[i-1]$的话，那么$sum[i]=2*sum[i-1]$，似乎存在倍增的关系，尝试从这个角度入手 我们对原序列维护线段树，线段树记录区间和&amp;区间最大值,每次单点修改后，我们记录一个初始前缀和cursum，然后在序列中找第一个比cursum大的数a[i]，这个根据我们维护的区间最大值可以线段树二分在log的时间内求出，然后我们验证a[i]是否是king，如果是则结束，否则把cursum更新成sum[i]，从头来过。可以看出因为cursum每次至少乘2，所以最多只会做log(1e9)次，加上每次线段树二分的log，我们可以在$O(nlognlog(1e9))$的时间复杂度解决这个问题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define uint unsigned int #define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rlen,wlen; fastio () &#123;rlen=wlen=0;&#125; inline char Getchar() &#123; if (rlen==S) rlen=0,fread(rbuf,1,S,stdin); return rbuf[rlen++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; T res=0;char ch;bool f; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=res; &#125; inline void flush() &#123;fwrite(wbuf,1,wlen,stdout);rlen=0;&#125; inline void Writechar(char ch) &#123; wbuf[wlen++]=ch; if (wlen==S) flush(); &#125; template &lt;class T&gt; inline void Print(T res,char ch) &#123; char s[48];int pt; if (res==0) &#123; pt=1; s[1]='0'; &#125; else &#123; bool f=true;if (res&lt;0) f=false,res=-res; pt=0;while (res) s[++pt]=res%10+'0',res/=10; if (!f) s[++pt]='-'; &#125; while (pt&gt;=1) Writechar(s[pt--]); Writechar(ch); &#125;&#125;io;const int MAXN=2e5;int n,q;int a[MAXN+48];namespace SegmentTree&#123; struct node &#123; int left,right; int maxn;LL sum; &#125;tree[MAXN*4]; inline void pushup(int cur) &#123; tree[cur].maxn=max(tree[cur&lt;&lt;1].maxn,tree[cur&lt;&lt;1|1].maxn); tree[cur].sum=tree[cur&lt;&lt;1].sum+tree[cur&lt;&lt;1|1].sum; &#125; inline void build(int cur,int left,int right) &#123; tree[cur].left=left;tree[cur].right=right; if (left!=right) &#123; int mid=(left+right)&gt;&gt;1; build(cur&lt;&lt;1,left,mid); build(cur&lt;&lt;1|1,mid+1,right); pushup(cur); &#125; else &#123; tree[cur].maxn=tree[cur].sum=a[left]; &#125; &#125; inline void update(int cur,int pos,int newval) &#123; if (tree[cur].left==tree[cur].right) &#123; tree[cur].maxn=tree[cur].sum=newval; return; &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (pos&lt;=mid) update(cur&lt;&lt;1,pos,newval); else update(cur&lt;&lt;1|1,pos,newval); pushup(cur); &#125; inline LL querysum(int cur,int left,int right) &#123; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) return tree[cur].sum; LL res=0; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; if (left&lt;=mid) res+=querysum(cur&lt;&lt;1,left,right); if (mid+1&lt;=right) res+=querysum(cur&lt;&lt;1|1,left,right); return res; &#125; inline int findpos(int cur,int left,int right,LL need) &#123; if (left&gt;right) return -1; if (left&lt;=tree[cur].left &amp;&amp; tree[cur].right&lt;=right) &#123; if (tree[cur].maxn&lt;need) return -1; if (tree[cur].left==tree[cur].right) return tree[cur].left; if (tree[cur&lt;&lt;1].maxn&gt;=need) return findpos(cur&lt;&lt;1,left,right,need); else return findpos(cur&lt;&lt;1|1,left,right,need); &#125; int mid=(tree[cur].left+tree[cur].right)&gt;&gt;1; int res=-1; if (left&lt;=mid) res=findpos(cur&lt;&lt;1,left,right,need); if (res!=-1) return res; if (mid+1&lt;=right) res=findpos(cur&lt;&lt;1|1,left,right,need); return res; &#125;&#125;inline int solve()&#123; LL cursum=SegmentTree::querysum(1,1,1);int lastpos=1; if (!cursum) return 1; for (;;) &#123; int pos=SegmentTree::findpos(1,lastpos+1,n,cursum); if (pos==-1) return -1; if (SegmentTree::querysum(1,pos,pos)==SegmentTree::querysum(1,1,pos-1)) return pos; cursum=SegmentTree::querysum(1,1,pos); lastpos=pos; &#125;&#125;int main ()&#123; io.Get(n);io.Get(q); for (register int i=1;i&lt;=n;i++) io.Get(a[i]); SegmentTree::build(1,1,n); while (q--) &#123; register int pos,x; io.Get(pos);io.Get(x); SegmentTree::update(1,pos,x); io.Print(solve(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>倍增</category>
        <category>线段树二分</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6405][2018ACM多校]Make ZYB Happy 题解]]></title>
    <url>%2Fblog%2Fhdu6405%2F</url>
    <content type="text"><![CDATA[DescriptionIt’s known to all that ZYB is godlike, so obviously he has a large number of titles, such as jsking, bijingzyb and nbazyb. ZYB likes his titles very much. Each of ZYB’s titles is a string consisting of lower case letters ‘a’-‘z’ associated with a happiness value hi, which shows how much ZYB likes this title. If you say any substring of some title with happiness value x, he will get x happiness points. Moreover, a string may appear in more than one title. In this case, the happiness points ZYB gets are multiplied. If the string you say is not the substring of any of his titles, he gets no happiness point. For example, let’s say ZYB has two titles: zybnb (with happiness value 3) and ybyb (with happiness value 5). If you say y, b or yb, ZYB will get 15 happiness points; if you say z, zy or zyb, ZYB will only get 3 happiness points; if you say ybz or ybac he will get 0 happiness points. One day, you find ZYB pretty sad. As a big fan of ZYB, you want to say a word to ZYB to cheer him up. However, ZYB is really busy, so you can only say no more than m letters. As you haven’t seen ZYB for a long time, you are so excited that you forget what you want to say, so you decide to choose to say a nonempty string no longer than m and only containing ‘a’-‘z’ with equal probability. You want to know the expectations of happiness points you will bring to ZYB for different m. InputThe first line contains an integer n (1≤n≤104), the number of titles ZYB has. The i-th of the next n lines contains a nonempty string ti, which only contains lower case letters ‘a’-‘z’, representing the i-th title. The sum of lengths of all titles does not exceed 3×105. Then follows a line with n integers hi (1≤hi≤106), the happiness value of i-th title. The next line is a single integer Q (1≤Q≤3×105), the number of queries. For the next Q lines, each contains a single integer m (1≤m≤106), meaning that you can say no more than m letters to ZYB. The input data contains only one test case. OutputFor each query, display a single line of integer, representing the answer. It can be proved that the answer can be uniquely written as p/q where p and q are non-negative integers with gcd(p,q)=gcd(q,109+7)=1, and you should display p*q−1mod(109+7), where q−1 means the multiplicative inverse of q modulo 109+7. Sample Input2zybnbybyb3 541234 Sample Output769230776425925929891125950633120399 HintFor the first query, you can bring him 3 happiness points if you say “z” or “n”, and 15 happiness points if you say “y” or “b”; all other strings of length 1 bring no happiness point to ZYB. Therefore, the expectation is (2×3+2×15)/26 = 18/13, and the answer is 18×13^(-1) mod (10^9+7) = 769230776. Source2018 Multi-University Training Contest 8 Solution学习了一下广义后缀自动机 广义后缀自动机其实和普通后缀自动机一模一样，可以把它看做在trie上建立的SAM,实现上只要先建好一个串的SAM,然后后面的串把last置成root再来就可以了，中间不需要任何改动 首先对所有的串建立广义SAM,然后考虑题目的需求，对于广义SAM的每个节点，我们需要计算有多少个串包含它，然后把它们的happy值做累乘，这个的话，只要抓着每个串到SAM里面跑一遍，每跑到一个状态就同时顺着parent树更新所有的祖先，为了保证复杂度，每个节点记一个visited，如果已经被访问过了，那么它的祖先们肯定也都被访问过了，所以可以终止向上，这样保证每个点最多被访问一次，使得复杂度是$O(\sum len)$的 求出每个节点的累乘值后，考虑到每个节点所代表的子串长度都是在$min[i]$到$max[i]$范围内的，所以可以用一个差分数组来维护权值，具体来说，$sum[min[i]]+=\Pi_{happy},sum[max[i]+1]-=\Pi_{happy}$即可，这个数组做一遍前缀和就可以得到对于每种长度，所有可能子串的权值和 最后还要除以每种长度的子串个数，注意到子串是完全随机的，所以总个数显然是$26^{len}$,于是这题就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void getstring(string &amp;s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) s+=string(1,ch); &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=4e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int n,q;string s[MAXN+48];int h[MAXN+48];int sum[MAXN+48],ans[MAXN+48],maxlen;namespace SAM&#123; const int MAXN=1e6; int maxn[MAXN+48],nxt[MAXN+48][27],par[MAXN+48],h[MAXN+48],visited[MAXN+48],root,last,tot; inline void init() &#123;root=last=tot=1;&#125; inline void extend(char ch) &#123; int w=ch-'a'+1,p=last,np=++tot;maxn[np]=maxn[p]+1; while (p &amp;&amp; !nxt[p][w]) nxt[p][w]=np,p=par[p]; if (!p) &#123;par[np]=root;last=np;return;&#125; int q=nxt[p][w]; if (maxn[q]==maxn[p]+1) &#123;par[np]=q;last=np;return;&#125; int nq=++tot;maxn[nq]=maxn[p]+1; memcpy(nxt[nq],nxt[q],sizeof(nxt[q])); par[nq]=par[q];par[q]=par[np]=nq; while (p &amp;&amp; nxt[p][w]==q) nxt[p][w]=nq,p=par[p]; last=np; &#125; inline void insert(string s) &#123; last=root;int len=int(s.size()); for (register int i=0;i&lt;=len-1;i++) extend(s[i]); &#125; inline void go(string s,int ind,int val) &#123; int pos=root,len=int(s.size()); for (register int i=0;i&lt;len;i++) &#123; pos=nxt[pos][s[i]-'a'+1];int tmp=pos; while (tmp &amp;&amp; visited[tmp]!=ind) &#123; visited[tmp]=ind; //带着编号进去就不用清空visited if (!h[tmp]) h[tmp]=val; else h[tmp]=(1ll*h[tmp]*val)%MOD; tmp=par[tmp]; &#125; &#125; &#125;&#125;int main ()&#123; int i,qlen;io.Get(n);SAM::init(); for (i=1;i&lt;=n;i++) &#123; io.getstring(s[i]); SAM::insert(s[i]); maxlen=max(maxlen,int(s[i].size())); &#125; for (i=1;i&lt;=n;i++) io.Get(h[i]); for (i=1;i&lt;=n;i++) SAM::go(s[i],i,h[i]); for (i=2;i&lt;=SAM::tot;i++) &#123; int L=SAM::maxn[SAM::par[i]]+1,R=SAM::maxn[i]; sum[L]=add(sum[L]+SAM::h[i]);sum[R+1]=sub(sum[R+1]-SAM::h[i]); &#125; int ss=0,cur=1,vv=0; for (i=1;i&lt;=maxlen;i++) &#123; cur=(1ll*cur*26)%MOD; ss=add(ss+cur); sum[i]=add(sum[i]+sum[i-1]); vv=add(vv+sum[i]); ans[i]=1ll*vv*quick_pow(ss,MOD-2)%MOD; &#125; io.Get(q); while (q--) &#123; io.Get(qlen); qlen=min(qlen,maxlen); //注意一下这个细节 io.Print(ans[qlen],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>字符串</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6428][2018ACM多校]Calculate 题解]]></title>
    <url>%2Fblog%2Fhdu6428%2F</url>
    <content type="text"><![CDATA[DescriptionGiven A, B, C, Calculate $$ \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3)) (mod 2^{30}) $$ Where $\phi (n)$ denotes the number of positive integers ≤ n that are relatively prime to n. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there are three integers A, B, C in one line, as described above. 1 ≤ T ≤ 10, 0 &lt; A, B, C ≤ 10^7 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 2^30. Sample Input496 93 95970 906 89392460 95043 542459760979 8053227 7156842 Sample Output111453628070648388873924623507672 Source2018 Multi-University Training Contest 10 Solution考虑莫比乌斯反演 \begin{split}ans &amp;= \sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\phi (gcd(i,j^2,k^3))\ &amp;= \sum_{d=1}^A\phi (d)\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=d]\end{split} 令$f(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[gcd(i,j^2,k^3)=n]$ 令$F(n)=\sum_{n\mid d}f(d)$ $gcd(i,j^2,k^3)$是$n$的倍数等价于$i$,$j^2$,$k^3$都是$n$的倍数，所以 $$F(n)=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{d\mid i,d\mid j^2,d\mid k^3} 1$$ 考虑$x\mid y^k$的充要条件，设$x=\Pi_ip_i^{a_i}$,则应满足$\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil} \mid y$ 令$f_k(x)=\Pi_ip_i^{\left \lceil \frac{a_i}{k}\right \rceil}$,则 $$F(n)=\left \lfloor \frac{A}{f_1(n)}\right \rfloor \left\lfloor \frac{B}{f_2(n)}\right\rfloor \left\lfloor \frac{C}{f_3(n)} \right\rfloor $$ 根据莫比乌斯反演 $$f(n)=\sum_{n\mid d}F(d)\mu (\frac{d}{n})=\sum_{n\mid d}\left \lfloor \frac{A}{f_1(d)}\right \rfloor \left\lfloor \frac{B}{f_2(d)}\right\rfloor \left\lfloor \frac{C}{f_3(d)} \right\rfloor \mu (\frac{d}{n})$$ 将此式带回$ans$式,有 $$ans=\sum_{d=1}^A\phi (d)f(d)=\sum_{d=1}^A\phi (d)\sum_{d\mid t}\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \mu (\frac{t}{d})$$ 发现$\mu$和$\phi$很像卷积的关系，所以转而枚举$t$,我们有 \begin{split}ans &amp;=\sum_{t=1}^A\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor \sum_{d\mid t}\phi (d)\mu (\frac{t}{d})&amp;=\sum_{t=1}^A(\phi \ast \mu)(t)\left \lfloor \frac{A}{f_1(t)}\right \rfloor \left\lfloor \frac{B}{f_2(t)}\right\rfloor \left\lfloor \frac{C}{f_3(t)} \right\rfloor\end{split} 现在只要线性筛出$f_k(n)$和$(\phi \ast \mu)(n)$,$f_k(n)$是积性函数比较显然,对于$(\phi \ast \mu)(n)$是积性函数，下面给出一个简短的证明:证明：考虑$(\phi \ast \mu)(a)和(\phi \ast \mu)(b)$,其中$a$,$b$互质&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(\phi \ast \mu)(a)$可以写成$\sum \phi(x)\mu(y)[xy=a]$的形式，同理$(\phi \ast \mu)(b)$可以写成$\sum \phi(X)\mu(Y)[XY=b]$的形式&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 考虑$(\phi \ast \mu)(a)$和$(\phi \ast \mu)(b)$相乘，拆开括号后，每一项应该都是$\phi(x)\mu(y)\phi(X)\mu(Y)的形式$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为$(a,b)=1$,所以$(x,X)=1,(y,Y)=1$,因为$\phi$和$\mu$都是积性函数，所以上式可以写成$\phi(xX)\mu(yY)$&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 注意到$xXyY=ab$,因为$xy$遍历了$a$的所有拆分,$XY$遍历了$b$的所有拆分，所以$xX$和$yY$必然也遍历了$ab$的所有拆分，又因为$(a,b)=1$,所以所有的$xX$必然互不相同,同时所有的$yY$也互不相同&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 所以，当$(a,b)=1$时,$(\phi \ast \mu)(ab)=(\phi \ast \mu)(a)(\phi \ast \mu)(b)$,$(\phi \ast \mu)(n)$是积性函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Q.E.D.$ $f_1(n)$不用筛，我们注意到线性筛有一个非常好的性质，每个数都是被它最小的质因数筛去的，举一个例子，如果有一个数是$2^2\cdot 3^2\cdot 5$,那筛掉它的一定是$2$,剩下的是$2\cdot 3^2\cdot 5$,而$2\cdot 3^2\cdot 5$又是被$2$筛掉的,剩下的是$3^2\cdot 5$…依次类推，我们会发现一个数的相同质因数总是会在一起，所以如果我们对每一个数记录一个$cnt$表示筛掉它的质数现在有几个，在$i%prime[j]==0$的环节$cnt$累加,否则$cnt$置为$1$,然后判断一下$cnt%k$是否为1就能维护$f_k(n)$,具体细节可以看看代码 对于$(\phi \ast \mu)(n)$,首先当n是质数的时候,$(\phi \ast \mu)(n)=\phi (n)\mu (1)+\phi(1) \mu(n)=n-2$,进而当$n=p^k$,其中$p$是质数时,$(\phi \ast \mu)(n)=(\phi \ast \mu)(p^k)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)+\phi(p^{k-2})\mu(p^2)+…+\phi(p)\mu(p^{k-1})+\phi(1)\mu(p^k)$, 根据莫比乌斯函数的定义,后面的$p$的次数大于等于二的项都是0,所以$(\phi \ast \mu)(n)=\phi(p^k)\mu(1)+\phi(p^{k-1})\mu(p)=(p^k-p^{k-1})\cdot 1+(p^{k-1}-p^{k-2})\cdot (-1)=p^k-2\cdot p^{k-1}+p^{k-2}$根据这个就足够进行线性筛了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define uint unsigned int#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e7;bool isprime[MAXN+48];int prime[MAXN+48],tot;int phi[MAXN+48],mu[MAXN+48],mup[MAXN+48],f2[MAXN+48],f3[MAXN+48];int cnt[MAXN+48],pw[MAXN+48];inline void init()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=mu[1]=mup[1]=f2[1]=f3[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) &#123; prime[++tot]=i; phi[i]=i-1;mu[i]=-1;mup[i]=i-2; f2[i]=f3[i]=i;cnt[i]=1;pw[i]=i; &#125; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]!=0) &#123; phi[i*prime[j]]=phi[i]*(prime[j]-1); mu[i*prime[j]]=-mu[i]; mup[i*prime[j]]=mup[i]*mup[prime[j]]; f2[i*prime[j]]=f2[i]*prime[j]; f3[i*prime[j]]=f3[i]*prime[j]; cnt[i*prime[j]]=1;pw[i*prime[j]]=prime[j]; &#125; else &#123; phi[i*prime[j]]=phi[i]*prime[j]; mu[i*prime[j]]=0;cnt[i*prime[j]]=cnt[i]+1;pw[i*prime[j]]=pw[i]*prime[j]; mup[i*prime[j]]=mup[i/pw[i]]*(pw[i*prime[j]]-2*pw[i*prime[j]]/prime[j]+pw[i*prime[j]]/prime[j]/prime[j]); f2[i*prime[j]]=f2[i]*((cnt[i*prime[j]]%2==1)?prime[j]:1); f3[i*prime[j]]=f3[i]*((cnt[i*prime[j]]%3==1)?prime[j]:1); break; &#125; &#125; &#125;&#125;uint A,B,C;int main ()&#123; int ca;io.Get(ca);init(); while (ca--) &#123; io.Get(A);io.Get(B);io.Get(C); uint ans=0; for (register int i=1;i&lt;=A;i++) ans+=(A/i)*(B/f2[i])*(C/f3[i])*mup[i]; io.Print(ans&amp;((1&lt;&lt;30)-1),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6437][2018ACM多校]Videos 题解]]></title>
    <url>%2Fblog%2Fhdu6437%2F</url>
    <content type="text"><![CDATA[DescriptionC-bacteria takes charge of two kinds of videos: ’The Collection of Silly Games’ and ’The Collection of Horrible Games’. For simplicity’s sake, they will be called as videoA and videoB. There are some people who want to watch videos during today, and they will be happy after watching videos of C-bacteria. There are n hours a day, m videos are going to be show, and the number of people is K. Every video has a type(videoA or videoB), a running time, and the degree of happi- ness after someone watching whole of it. People can watch videos continuous(If one video is running on 2pm to 3pm and another is 3pm to 5pm, people can watch both of them). But each video only allows one person for watching. For a single person, it’s better to watch two kinds to videos alternately, or he will lose W happiness. For example, if the order of video is ’videoA, videoB, videoA, videoB, …’ or ’B, A, B, A, B, …’, he won’t lose happiness; But if the order of video is ’A, B, B, B, A, B, A, A’, he will lose 3W happiness. Now you have to help people to maximization the sum of the degree of happiness. InputMultiple query. On the first line, there is a positive integer T, which describe the number of data. Next there are T groups of data. for each group, the first line have four positive integers n, m, K, W : n hours a day, m videos, K people, lose W happiness when watching same videos).and then, the next m line will describe m videos, four positive integers each line S, T, w, op : video is the begin at S and end at T, the happiness that people can get is w, and op describe it’s tpye(op=0 for videoA and op=1 for videoB). There is a blank line before each groups of data. T&lt;=20, n&lt;=200, m&lt;=200, K&lt;=200, W&lt;=20, 1&lt;=S&lt;T&lt;=n, W&lt;=w&lt;=1000,op=0 or op=1 OutputYour output should include T lines, for each line, output the maximum happiness for the corresponding datum. Sample Input210 3 1 101 5 1000 05 10 1000 13 9 10 010 3 1 101 5 1000 05 10 1000 03 9 10 0 Sample Output20001990 Source2018 Multi-University Training Contest 10 Solution这题一眼网络流 我们可以对每个时刻建点，给每个点一个编号(A/B,1~n)表示上一个看的电影是A/B,当前是第i个小时，把人想象成流量 首先，一个人可以在某一个时刻什么也不干，所以(A,i)应该向(A,i+1)连一条流量为INF,费用为0的边，(B,i)应该向(B,i+1)连一条流量为INF，费用为0的边 每一步电影可以看做一条边，如果是A类型的电影，时刻从a到b,那么(A,a)应该向(B,b)连一条流量为1，费用为val的边，如果是B类型的电影，时刻从a到b,那么(B,a)应该向(A,b)连一条流量为1，费用为val的边，可以看出，这样连边如果看的电影类型交替是没有额外花费的 如果连续看同样的电影会有w的代价，所以(A,i)应该向(B,i)连一条流量为INF,费用为-w的边，同时(B,i)应该向(A,i)连一条流量为INF,费用为-w的边 最后设置源点和汇点，s向(A,1)和(B,1)连流量为INF,费用为0的边，(A,n)和(B,n)向t连流量为INF，费用为0的边 最后只要跑流量为k的最小费用流即可，最后要把答案取反 因为一开始就有负权边，所以有两种解决方案： 先跑一遍spfa，再跑带势的dijkstra 先把负权边流满，重新构图再跑费用流 考场上懒直接按1做了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=1e8;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=10000;int n,m,k,w;namespace flow&#123; int head[200048],nxt[200048],to[200048],f[200048],w[200048],tot=1,t; inline void addedge(int s,int t,int l,int cost) &#123; to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=l;w[tot]=cost; to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;w[tot]=-cost; &#125; int prevv[200048],preve[200048]; int h[200048]; priority_queue&lt;Pair&gt; q;int dist[200048]; inline void init() &#123; t=n*2+2; for (register int i=0;i&lt;=t;i++) head[i]=0; for (register int i=0;i&lt;=t;i++) h[i]=0; tot=1; &#125; bool dijkstra() &#123; int i,x,y,dd; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;q.push(mp(0,t)); while (!q.empty()) &#123; x=q.top().y;dd=-q.top().x;q.pop(); if (dd&gt;dist[x]) continue; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]+h[x]-h[y]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]+h[x]-h[y]; prevv[y]=x;preve[y]=i; q.push(mp(-dist[y],y)); &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; int qq[MAXN+48],Head,Tail;bool inq[MAXN+48]; bool spfa() &#123; int i,x,y; for (i=0;i&lt;=t;i++) dist[i]=INF; dist[t]=0;qq[Head=Tail=1]=t;inq[t]=true; while (Head&lt;=Tail) &#123; x=qq[Head++];inq[x]=false; for (i=head[x];i;i=nxt[i]) &#123; y=to[i]; if (f[i] &amp;&amp; dist[x]+w[i]&lt;dist[y]) &#123; dist[y]=dist[x]+w[i]; prevv[y]=x;preve[y]=i; if (!inq[y]) inq[y]=true,qq[++Tail]=y; &#125; &#125; &#125; if (dist[n*2+1]&gt;=INF) return false; else return true; &#125; inline int min_cost_flow() &#123; int i,u,res,minf; for (i=0;i&lt;=t;i++) h[i]+=dist[i]; minf=INF; for (u=n*2+1;u!=t;u=prevv[u]) minf=min(minf,f[preve[u]]); res=minf*h[n*2+1]; for (u=n*2+1;u!=t;u=prevv[u]) &#123; f[preve[u]]-=minf; f[preve[u]^1]+=minf; &#125; return res; &#125; inline int ek() &#123; int ans=0; if (spfa()) &#123; do &#123; ans+=min_cost_flow(); &#125; while (dijkstra()); &#125; return -ans; &#125;&#125;int main ()&#123; int i,ca,s,t,v,op;io.Get(ca); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k);io.Get(w); flow::init(); for (i=1;i&lt;=n*2;i++) flow::addedge(0,i,INF,0),flow::addedge(i,n*2+1,INF,0); flow::addedge(n*2+2,0,k,0); for (i=1;i&lt;=n;i++) flow::addedge(i,n+i,INF,w),flow::addedge(n+i,i,INF,w); for (i=1;i&lt;=n-1;i++) flow::addedge(i,i+1,INF,0),flow::addedge(n+i,n+i+1,INF,0); for (i=1;i&lt;=m;i++) &#123; io.Get(s);io.Get(t);io.Get(v);io.Get(op); flow::addedge(op*n+s,(op^1)*n+t,1,-v); &#125; io.Print(flow::ek(),'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记]Miller_Rabin强伪素性测试]]></title>
    <url>%2Fblog%2Fmiller_rabin%2F</url>
    <content type="text"><![CDATA[Miller_Rabin强伪素性测试主要基于下面两个定理 费尔马小定理：若$gcd(a,p)=1$,则$a^{p-1}\equiv 1(mod$ &nbsp; $p)$ 二次探测定理：若p是质数且$a^2\equiv 1(mod$ &nbsp; $p)$,则$a\equiv \pm 1(mod$ &nbsp; $p)$ (对于2给出一个简单的证明: 若$a^2\equiv 1(mod$ &nbsp; $p)$,那么$p\mid a^2-1$,即$p\mid (a+1)(a-1)$,这里我们不讨论$p=2$的情况，因为p是质数，所以p不可能同时整除$a-1$和$a+1$,所以要么$p\mid a-1$,要么$p\mid a+1$,即$a\equiv \pm 1(mod$ &nbsp; $p)$) 也就是说，一旦找到任何一个$a$不满足上述条件，那么$p$一定不是质数 为什么定理1不够用还要定理2呢，因为有一种数叫Carmichael数，它们都是合数，且均满足对于$\forall a$,有$a^{p-1}\equiv 1(mod$ &nbsp; $p)$,这种数在1e8范围内只有255个，但是也足够多了 所以我们考虑下面的方法： 对于$p-1$,把它写成$p-1=2^kt$的形式,其中$p\equiv 1(mod$ &nbsp; $2)$ 随机一个小于p的数a, 快速幂算出$a^t$ 当前数是$a^t$,自乘的结果是$a^{2t}$,再自乘的结果是$a^{2^2t}$,依次类推，自乘k次后这个数就会变成$a^{2^kt}$,即$a^{p-1}$ 在3的过程中，参考上面的两条定理，我们可以得到： 如果最后这个数不等于1，那么p不是质数 如果在某一个时刻，这个数在模$p$意义下等于1,而上一时刻不等于$\pm 1$，那么$p$不是质数 我们称2和3为一次测试，一个数$p$,不是质数且通过一次测试的概率约为25%,所以多随机几次失败的概率就微乎其微]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Miller_Rabin强伪素性测试</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Miller_Rabin强伪素性测试</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记]Pollard_Rho分解质因数]]></title>
    <url>%2Fblog%2Fpollard_rho%2F</url>
    <content type="text"><![CDATA[Pollard_Rho的核心思想大概是两个: 生日攻击理论 假设当前要分解的数$p=a*b$，$a$和$b$很稀有，但是$a$和$b$的倍数却有很多，所以只要找到一个数$c$，使得$gcd(c,p)&gt;1$即可 所以算法大概是这样： 在[2,n-1]之间随机一些数$x_1,x_2…x_k$,$k$大概是$n^{\frac{1}{4}}$级别 判断是否存在$gcd(\mid x_i-x_j\mid ,p)&gt;1$ 但把这些x全部预处理出来的方法太傻了，事实上我们可以先造两个数出来，然后不断地生成伪随机数，pollard告诉我们,$x_{i+1}=(x_i^2+a)\%N$是一个非常好的随机函数，这里的$a$是随机的，通常随机一个不会出锅如果真的出锅了就再随机一个 不过这个随机算法有一点问题：这样随机下去之后，$x_i$会重复。如果把所有的$x_i$都存下来然后哈希显然又显得烦了一些，有两种判圈算法可以帮我们在发现入圈之后跳出去 Floyd判圈法：它的核心思想是这样的：假设乌龟和兔子在某种形状的跑道上跑，兔子的速度比乌龟快，那么除了在起点的时刻，如果兔子遇到了乌龟，说明跑道上存在环，套用在pollard_rho上，就是$x_{i+1}=(x_i^2+a)\%N$这个函数，准备$x$和$y$两个变量，一个每次做一下，一个每次做两下，模拟乌龟和兔子 Brent判圈法：还是用乌龟和兔子举例子，乌龟不动，兔子每跑一步，就判断一下是否和兔子相遇，一旦兔子跑的步数是2的次幂，就把乌龟移到兔子的位置。这个算法比Floyd要好一些]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>Pollard_Rho分解质因数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Pollard_Rho分解质因数</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6434][2018ACM多校]Count 题解]]></title>
    <url>%2Fblog%2Fhdu6434%2F</url>
    <content type="text"><![CDATA[DescriptionMultiple query, for each n, you need to get $$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)=1]$$ InputOn the first line, there is a positive integer T, which describe the number of queries. Next there are T lines, each line give a positive integer n, as mentioned above. T&lt;=1e5, n&lt;=2e7 OutputYour output should include T lines, for each line, output the answer for the corresponding n. Sample Input4978438233666 Sample Output194041389511106589963 Source2018 Multi-University Training Contest 10 Solution我刚开始的思路是：转而考虑枚举i+j和j，但发现j的范围与i+j有关，最后不好算 我们考虑枚举一个a,i+j=2i-a,i-j=a,可以看出这样的a和j是一一对应的，且a+j=n 所以我们转而求 $$\sum_{i=1}^n\sum_{a=1}^{n-1}[gcd(2i-a,a)=1]$$ 根据辗转相减求gcd的原理，我们有$gcd(a+b,b)=gcd(a,b)$，所以$gcd(2i-a,a)=gcd(2i,a)$ 于是我们转而求 $$\sum_{i=1}^n\sum_{j=1}^{n-1}[gcd(2i,a)=1]$$ 首先a肯定是奇数，然后这时可以把2扔掉，只判断i和a是否互质 如果i是偶数，那么小于i的与i互质的数必然全都是奇数，都可以作为a，所以这时答案是$phi(i)$ 如果i是奇数，考虑任意一个小于i且与i互质的数p，则i-p也和i互质，而且p和i-p必然一奇一偶，所以所有小于i且与i互质的数中，奇数偶数各占一半，所以这时答案是$\frac{phi(i)}{2}$ 所以只要线性筛一波欧拉函数，然后前缀和一下就好了，时间复杂度O(n+T) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e7;int phi[MAXN+48],prime[MAXN+48],tot;bool isprime[MAXN+48];inline void init_phi()&#123; memset(isprime,true,sizeof(isprime)); phi[1]=1; for (register int i=2;i&lt;=MAXN;i++) &#123; if (isprime[i]) prime[++tot]=i,phi[i]=i-1; for (register int j=1;j&lt;=tot &amp;&amp; 1ll*i*prime[j]&lt;=MAXN;j++) &#123; isprime[i*prime[j]]=false; if (i%prime[j]) phi[i*prime[j]]=phi[i]*(prime[j]-1); else phi[i*prime[j]]=phi[i]*prime[j]; if (i%prime[j]==0) break; &#125; &#125;&#125;LL ans[MAXN+48];inline void init_ans()&#123; ans[1]=0; for (register int i=2;i&lt;=MAXN;i++) if (i&amp;1) ans[i]=ans[i-1]+phi[i]/2; else ans[i]=ans[i-1]+phi[i];&#125;int main ()&#123; int ca,i,n;io.Get(ca); init_phi();init_ans(); while (ca--) &#123; io.Get(n); io.Print(ans[n],'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6432][2018ACM多校]Cyclic 题解]]></title>
    <url>%2Fblog%2Fhdu6432%2F</url>
    <content type="text"><![CDATA[DescriptionCount the number of cyclic permutations of length n with no continuous subsequence [i, i + 1 mod n]. Output the answer modulo 998244353. InputThe first line of the input contains an integer T , denoting the number of test cases. In each test case, there is a single integer n in one line, denoting the length of cyclic permutations. 1 ≤ T ≤ 20, 1 ≤ n ≤ 100000 OutputFor each test case, output one line contains a single integer, denoting the answer modulo 998244353. Sample Input3456 Sample Output1836 Source2018 Multi-University Training Contest 10 Solution考场上我已经想到了容斥竟然还没推出式子，卑劣地使用了OEIS，太惭愧了 容斥的思路是显然的，每次要算至少包含i个[i,i+1]片段的序列有多少种(这个“至少”指的是对于任意i个片段，这个序列都被算了一次)，这个怎么算呢？ 我们考虑所有的[i,i+1]片段，一共有[1,2],[2,3]…[n-1,n],[n,1]n种 我们考虑选出其中的i种，这i种将会在序列中出现，这个是$C_n^i$，然后我们将这些片段中的数捆在一起，比如如果选中了[1,2],[3,4]就把1和2捆在一起,3和4捆在一起; 如果选中了[1,2],[2,3]就把1,2,3三个数捆在一起。显然不论怎么选，最后一定会有n-i捆数，这些捆有$(n-i)!$种排列方法，考虑到这是一个置换群，所以1必须放在第一个，所以实际上是$(n-i-1)!$排列方法 这样我们得到了至少有i个片段的序列个数是$C_n^i(n-i-1)!$，注意到这个式子只在i=0~n-1的时候适用，当i=n时，显然有n个片段的排列只有一个，即1,2,3…n 所以最后的答案是 $$ans=(-1)^n+\sum_{i=0}^{n-1}(-1)^iC_n^i(n-i-1)!$$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD;y&gt;&gt;=1; &#125; return res;&#125;int inv[MAXN+48],finv[MAXN+48],fac[MAXN+48];inline void init_inv()&#123; fac[0]=fac[1]=1; for (register int i=2;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y) &#123;return 1ll*fac[x]*finv[y]%MOD*finv[x-y]%MOD;&#125;int main ()&#123; int i,n,ans,ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);ans=0; for (i=0;i&lt;=n-1;i++) &#123; int delta=1ll*C(n,i)*fac[n-i-1]%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; if (n&amp;1) ans=sub(ans-1); else ans=add(ans+1); io.Print(ans,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6412][百度之星2018]公共子序列 题解]]></title>
    <url>%2Fblog%2Fhdu6412%2F</url>
    <content type="text"><![CDATA[Description光羽一点都不喜欢高代，某一次高代课上，光羽特意挑了最后一排的位置，睡着睡着，他忽然想到了这道字符串水题！ 度度熊有k(k≥2)个序列s1,s2,..,sk，每个序列的长度均为n，且序列中每个数均是1到n之间某个整数，请问这k个串有多少个长度大于0的公共子序列？ 解释：在每个序列中都选出一些位置，并将这些位置对应的字符顺次拼接起来，当它们都相等时，称其为公共子序列。 答案可能很大，请对$10^9+7$取模。 Input第一行一个数，表示数据组数T。 每组数据第一行两个数k,n；接下来k行，每行一个长度为n的序列si。 数据组数T=80，分别有20组数据满足k=2,3,4,5。 每组数据均满足1≤n≤1000，且s1,s2,…,sk中每一个数在1到n之间等概率随机生成！！ 随机生成！！ 随机生成！！ 随机生成！！ Output每组数据输出一行，每行仅包含一个数，表示公共子序列个数。 Sample Input42 31 2 12 3 13 31 2 32 3 11 2 34 33 2 23 1 32 3 13 2 15 33 1 33 1 11 2 32 3 31 3 3 Sample Output4428 Source2018“百度之星”程序设计大赛 - 复赛 Solution这么naive的题我赛场没有做出来，这种随机相关的题见的太少了…… 两个串的公共子串个数有非常简单的$O(n^2)$的dp可以解决，如果没有特殊性质，那么$k=5$时的复杂度应该是$O(n^5)$的，所以必须利用好随机这个性质 我刚开始一直在往最长公共子串很短这方面想，但这并没有什么用。我们可以考虑常规dp里的每个状态，记录的第一，二，三…个串的公共子串的最后位置p1,p2,p3…pn，要满足$s1[p1]=s2[p2]=s3[p3]=…=sn[pn]$,在随机的情况下，每个数列都接近一个排列，所以这样的状态数不会很多，期望是$O(n)$的，所以只要先搜索出所有合法的状态，再做一个$O(n^2)$的dp就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=1e9+7;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1000;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n,k;int a[6][MAXN+48];vector&lt;int&gt; v[6][MAXN+48];struct node&#123; int pos[6]; inline bool operator &lt; (const node &amp;other) const &#123; for (register int i=1;i&lt;=k;i++) if (pos[i]&gt;=other.pos[i]) return false; return true; &#125;&#125;sta[MAXN*10+48],ins;int tot;int dp[MAXN*10+48];inline void dfs(int step,int type)&#123; if (step==k+1) &#123; sta[++tot]=ins; return; &#125; for (register int i=0;i&lt;int(v[step][type].size());i++) ins.pos[step]=v[step][type][i],dfs(step+1,type);&#125;inline int solve(int cur)&#123; if (dp[cur]!=-1) return dp[cur]; dp[cur]=1; for (register int i=1;i&lt;=tot;i++) if (sta[i]&lt;sta[cur]) dp[cur]=add(dp[cur]+solve(i)); return dp[cur];&#125;inline void Clear()&#123; for (register int i=1;i&lt;=k;i++) for (register int j=1;j&lt;=n;j++) v[i][j].clear();&#125;int main ()&#123; int i,j,ca;io.Get(ca); while (ca--) &#123; io.Get(k);io.Get(n);Clear(); for (i=1;i&lt;=k;i++) for (j=1;j&lt;=n;j++) io.Get(a[i][j]),v[i][a[i][j]].pb(j); tot=0; for (i=1;i&lt;=n;i++) dfs(1,i); memset(dp,-1,sizeof(dp));int ans=0; for (i=1;i&lt;=tot;i++) ans=add(ans+solve(i)); io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>Dynamic Programming</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>HDU</tag>
        <tag>随机</tag>
        <tag>百度之星</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6403][2018ACM多校]Card Game 题解]]></title>
    <url>%2Fblog%2Fhdu6403%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob are playing a card game. In this card game, a number is written on each face of the playing card. The rule of the game is described as follows: Alice arranges the cards in a row, and for each of the cards, she chooses one of its faces to place it up; Bob turns over minimum number of cards to make all numbers on the front faces unique. They play the game some times, and Bob always succeeds making the numbers unique. However, both of them are not sure whether the number of cards flipped is minimum. Moreover, they want to figure out the number of different ways of turning over minimum number of cards to make the numbers unique. Two ways are considered equal if and only if the sets of flipped cards are equal. Please write a program to help them! InputThe first line of the input is a single integer T (1≤T≤50), the number of test cases. Each test case begins with a single line of integer n (1≤n≤105), the number of cards on the table. Then follow n lines, specifying the cards that Alice arranges. Each of these n lines contains two integers x,y (1≤x,y≤2n), meaning that Alice places a card with number x on the front face and number y on the back face. It is guaranteed that the sum of n over all test cases does not exceed 106. OutputFor each test case, display two integers in a line, the minimum number of cards to turn over, and the number of different ways of flipping modulo 998244353, respectively. If it is impossible to turn over cards to make all numbers unique, display -1 -1 instead. Sample Input341 21 34 54 621 11 131 23 45 6 Sample Output2 4-1 -10 1 HintIn the first sample test case, Bob may turn over one of the first two cards and one of the last two cards, so there are four different ways of turning over two cards tomake all numbers on the front faces unique. Obviously, this can’t be done with less than two cards flipped. In the second sample test case, it is impossible to make all numbers on the front faces unique. In the third sample test case, all numbers on the front faces are already distinct. Source2018 Multi-University Training Contest 8 Solution非常赞的图论建模题 我们可以考虑把每场卡片看成一条无向边，把数字看成点，比如卡片上的数字是u和v，就在u和v之间连一条边，这样我们的任务就是给每条边定向（显然有一种方向权值是0，另外一种方向权值是1），使得每个点被不多于一条边指向（即每条边指向的点是这张卡片最后的数字），且权值和最小 我们可以发现两个重要的性质 如果出现了一个环，那么这个环只有两种定向方式：逆时针和顺时针，即环上的每个点都会被指到 如果某个联通块中有两个环，那么必然无解。因为考虑连接两个环的路径，因为路径的两头的点都属于环中，根据性质1，这两个点都在环上被指到了，那么这条路径中的边数会比点数多1，无论如何也不可能合法定向 所以每个联通块要么是基环外向树，要么是树，分情况讨论： 基环外向树：考虑环上挂的若干棵树，因为根节点在环上已经被指到了，所以树中所有连接到根节点的边必须向下定向，同理根节点的孩子们都被指到了，所以根节点的孩子们的边也要向下定向……所以说，基环树上的每棵树的定向方式都是唯一的，即所有边都向下，然后环有两种情况，分别判一下就好。尤其要注意自环的情况，自环无论如何只可能有一种情况 树：树中有n-1条边和n个点，所以必然有且仅有一个点没有被指到，考虑一旦确定了这个没有被指到的点，以它为根，那么整棵树的定向就确定了。我们可以先考虑随便抓一个点i作为根算一遍，得到一个初始答案ans,然后再做一遍深搜枚举根，设当前根为j,我们会发现这时i到j的路径上的边会反向，其他边不变，这个可以边搜边记录，可以比较轻松的解决 至此所有情况讨论完毕，时间复杂度$O(n)$，对代码能力要求稍高 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *s++=ch; *s='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x,char ch) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar(ch); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=2e5;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int n;vector&lt;int&gt; v[MAXN+48];bool incir[MAXN+48];struct Edge&#123; int u,v; inline void input() &#123;io.Get(u);io.Get(v);&#125;&#125;edge[MAXN+48];inline int getanother(int id,int u)&#123; return edge[id].u==u?edge[id].v:edge[id].u;&#125;int cid,cnt;int depth[MAXN+48],fa[MAXN+48],vis[MAXN+48],exist[MAXN+48];//fa didn't store his father but the id of the edge to his fatherinline void dfs(int cur,int father)&#123; fa[cur]=father;int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (!depth[y]) &#123; depth[y]=depth[cur]+1; dfs(y,id); &#125; else if (id!=father &amp;&amp; depth[y]&lt;=depth[cur]) &#123; cnt++; cid=id; &#125; &#125;&#125;int minn,minmethod;namespace cycle&#123; int cirlist[MAXN+48],ctot; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father &amp;&amp; !incir[y]) &#123; if (cur==edge[id].u) minn++; dfs(y,id); &#125; &#125; &#125; inline void solve() &#123; ctot=0;int u=edge[cid].u,v=edge[cid].v; if (depth[u]&lt;depth[v]) swap(u,v); for (register int cur=u;cur!=v;cur=getanother(fa[cur],cur)) cirlist[++ctot]=cur,incir[cur]=true; cirlist[++ctot]=v;incir[v]=true; for (register int i=1;i&lt;=ctot;i++) dfs(cirlist[i],-1); if (ctot==1) return; int cnt1=0,cnt2=0; //from down to up for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].u==cirlist[i]) cnt1++; if (edge[cid].u==cirlist[ctot]) cnt1++; //from up to down for (register int i=1;i&lt;=ctot-1;i++) if (edge[fa[cirlist[i]]].v==cirlist[i]) cnt2++; if (edge[cid].u==cirlist[1]) cnt2++; minn+=min(cnt1,cnt2); if (cnt1==cnt2) minmethod=add(minmethod+minmethod); &#125;&#125;namespace tree&#123; int Minn,Cnt,ans; inline void update(int curans) &#123; if (curans&lt;Minn) Minn=curans,Cnt=1; else if (curans==Minn) Cnt++; &#125; inline void dfs(int cur,int father) &#123; int i,id,y; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id!=father) &#123; if (edge[id].u==cur) ans++; dfs(y,id); &#125; &#125; &#125; inline void Dfs(int cur,int father) &#123; update(ans);int i,id,y,delta; for (i=0;i&lt;int(v[cur].size());i++) &#123; id=v[cur][i];y=getanother(id,cur); if (id==father) continue; if (edge[id].u==cur) delta=1; else delta=-1; ans-=delta;Dfs(y,id); ans+=delta; &#125; &#125; inline void solve(int root) &#123; Minn=INF;Cnt=0; ans=0;dfs(root,-1); Dfs(root,-1); minn+=Minn;minmethod=(1ll*minmethod*Cnt)%MOD; &#125;&#125;inline void Clear()&#123; for (register int i=1;i&lt;=n*2;i++) depth[i]=0,v[i].clear(),incir[i]=false,vis[i]=false; minn=0;minmethod=1;&#125;int main ()&#123; int ca;io.Get(ca);int i; while (ca--) &#123; io.Get(n);Clear(); bool f=true; for (i=1;i&lt;=n;i++) &#123; edge[i].input(); if (edge[i].u!=edge[i].v) v[edge[i].u].pb(i),v[edge[i].v].pb(i); else v[edge[i].u].pb(i); exist[edge[i].u]=true;exist[edge[i].v]=true; if (edge[i].u==edge[i].v) &#123; if (vis[edge[i].u]) f=false; vis[edge[i].u]=true; &#125; &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; for (i=1;i&lt;=n*2;i++) if (!depth[i] &amp;&amp; exist[i]) &#123; cnt=0;cid=0; depth[i]=1;dfs(i,-1); if (cnt&gt;1) &#123;f=false;break;&#125; if (cnt==1) cycle::solve(); else tree::solve(i); &#125; if (!f) &#123;io.Print(-1,' ');io.Print(-1,'\n');continue;&#125; io.Print(minn,' ');io.Print(minmethod,'\n'); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>图论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>图论</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6397][2018ACM多校]Character Encoding 题解]]></title>
    <url>%2Fblog%2Fhdu6397%2F</url>
    <content type="text"><![CDATA[DescriptionIn computer science, a character is a letter, a digit, a punctuation mark or some other similar symbol. Since computers can only process numbers, number codes are used to represent characters, which is known as character encoding. A character encoding system establishes a bijection between the elements of an alphabet of a certain size n and integers from 0 to n−1. Some well known character encoding systems include American Standard Code for Information Interchange (ASCII), which has an alphabet size 128, and the extended ASCII, which has an alphabet size 256. For example, in ASCII encoding system, the word wdy is encoded as [119, 100, 121], while jsw is encoded as [106, 115, 119]. It can be noticed that both 119+100+121=340 and 106+115+119=340, thus the sum of the encoded numbers of the two words are equal. In fact, there are in all 903 such words of length 3 in an encoding system of alphabet size 128 (in this example, ASCII). The problem is as follows: given an encoding system of alphabet size n where each character is encoded as a number between 0 and n−1 inclusive, how many different words of length m are there, such that the sum of the encoded numbers of all characters is equal to k? Since the answer may be large, you only need to output it modulo 998244353. InputThe first line of input is a single integer T (1≤T≤400), the number of test cases. Each test case includes a line of three integers n,m,k (1≤n,m≤$10^5$,0≤k≤$10^5$), denoting the size of the alphabet of the encoding system, the length of the word, and the required sum of the encoded numbers of all characters, respectively. It is guaranteed that the sum of n, the sum of m and the sum of k don’t exceed $5×10^6$, respectively. OutputFor each test case, display the answer modulo 998244353 in a single line. Sample Input42 3 32 3 43 3 3128 3 340 Sample Output107903 Source2018 Multi-University Training Contest 8 Solution这题我刚开始直接无脑上了多项式快速幂，然后就T飞了，于是被戴大爷教做人……真的是知识越多越反动 我们考虑如果没有每个数在0~n-1这个条件的话，那就是一个简单的盒子可空的隔板法问题，现在加上这个限制，我们考虑容斥，那么最后的方案可以写成这样 $$ans=\sum_{i=0}^{lim}(-1)^i*f(至少有i个数大于n-1)$$ 现在考虑$f(至少有i个数大于n-1)$怎么算，我们可以先钦定哪i个位置比n-1大，这个是$C_m^i$，然后剩下的依旧是一个简单的隔板法，于是就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=3e5;inline int quick_pow(int x,int y)&#123; int res=1; while (y) &#123; if (y&amp;1) res=(1ll*res*x)%MOD,y--; x=(1ll*x*x)%MOD,y&gt;&gt;=1; &#125; return res;&#125;inline int add(int x) &#123;if (x&gt;=MOD) x-=MOD;return x;&#125;inline int sub(int x) &#123;if (x&lt;0) x+=MOD;return x;&#125;int fac[MAXN+48],finv[MAXN+48];inline void init_inv()&#123; fac[0]=1; for (register int i=1;i&lt;=MAXN;i++) fac[i]=(1ll*fac[i-1]*i)%MOD; finv[MAXN]=quick_pow(fac[MAXN],MOD-2); for (register int i=MAXN-1;i&gt;=0;i--) finv[i]=(1ll*finv[i+1]*(i+1))%MOD;&#125;inline int C(int x,int y)&#123; if (x&lt;0 || y&lt;0 || x&lt;y) return 0; return ((1ll*fac[x]*finv[y])%MOD*finv[x-y])%MOD;&#125;int n,m,k;int main ()&#123; int ca;io.Get(ca); init_inv(); while (ca--) &#123; io.Get(n);io.Get(m);io.Get(k); int ans=0; for (register int i=0;i&lt;=m &amp;&amp; n*i&lt;=k;i++) &#123; int delta=(1ll*C(m,i)*C(k-n*i+m-1,m-1))%MOD; if (i&amp;1) ans=sub(ans-delta); else ans=add(ans+delta); &#125; io.Print(ans); &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>HDU</tag>
        <tag>2018多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU6406][2018ACM多校]Taotao Picks Apples 题解]]></title>
    <url>%2Fblog%2Fhdu6406%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1,h2,⋯,hn, you are required to answer some independent queries. Each query is two integers p,q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1≤T≤10), the number of test cases. Each test case begins with a line of two integers n,m (1≤n,m≤105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1,h2,⋯,hn (1≤hi≤109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1≤p≤n) and q (1≤q≤109), as described in the problem statement. OutputFor each query, display the answer in a single line. Sample Input15 31 2 3 4 41 55 52 3 Sample Output153 HintFor the first query, the heights of the apples were 5, 2, 3, 4, 4, so Taotao would only pick the first apple. For the second query, the heights of the apples were 1, 2, 3, 4, 5, so Taotao would pick all these five apples. For the third query, the heights of the apples were 1, 3, 3, 4, 4, so Taotao would pick the first, the second and the fourth apples. Source2018 Multi-University Training Contest 8 Solution我们可以先预处理原数列中会摘哪些苹果，这样对于每次询问，如果这次修改的苹果是pos，那么原数列中位置在pos前的那些苹果还是会被摘，这个可以二分一下找出在它之前的苹果个数 设之前的最后一个苹果的高度是h, 位置pos的新苹果高度为nv，分两种情况讨论： h&lt;nv 则下一个苹果是nv，在往下一个苹果是pos之后的第一个比nv大的苹果 h&gt;=nv 则下一个苹果是pos之后的第一个比h大的苹果 我们可以看出两种情况都需要支持查找在某个位置p之后，第一个比某个值val大的值在什么位置，显然我们可以二分这个位置，然后查找这个区间的max，如果max&gt;val则在位置以左，否则在位置以右，静态的查询max可以用ST表，这样复杂度可以控制在一个log 找到这关键的pos以右的第一个苹果之后，我们可以发现这之后的苹果都是原始数列的苹果，所以我们可以刚开始从后往前预处理一下从某个苹果开始向后能摘多少个苹果，加一下就好了 时间复杂度$O(nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);struct fastio&#123; static const int S=1e7; char rbuf[S+48],wbuf[S+48];int rpos,wpos,len; fastio() &#123;rpos=len=wpos=0;&#125; inline char Getchar() &#123; if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin); if (!len) return EOF; return rbuf[rpos++]; &#125; template &lt;class T&gt; inline void Get(T &amp;x) &#123; char ch;bool f;T res; while (!isdigit(ch=Getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=Getchar())) res=res*10+ch-'0'; x=(f?res:-res); &#125; inline void getstring(char *s) &#123; char ch; while ((ch=Getchar())&lt;=32) &#123;&#125; for (;ch&gt;32;ch=Getchar()) *++s=ch; *(s+1)='\0'; &#125; inline void flush() &#123;fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;&#125; inline void Writechar(char ch) &#123; if (wpos==S) flush(); wbuf[wpos++]=ch; &#125; template &lt;class T&gt; inline void Print(T x) &#123; char s[20];int pt=0; if (x==0) s[++pt]='0'; else &#123; if (x&lt;0) Writechar('-'),x=-x; while (x) s[++pt]='0'+x%10,x/=10; &#125; while (pt) Writechar(s[pt--]); Writechar('\n'); &#125; inline void printstring(char *s) &#123; int pt=1; while (s[pt]!='\0') Writechar(s[pt++]); &#125;&#125;io;const int MAXN=1e5;int n,m;int a[MAXN+48];int maxn[MAXN+48][21],Log[MAXN+48];inline void construct_ST()&#123; int i,j; for (i=1;i&lt;=n;i++) maxn[i][0]=a[i]; for (j=1;j&lt;=20;j++) for (i=1;i&lt;=n;i++) &#123; maxn[i][j]=maxn[i][j-1]; if (i+(1&lt;&lt;(j-1))&lt;=n) maxn[i][j]=max(maxn[i][j],maxn[i+(1&lt;&lt;(j-1))][j-1]); &#125; Log[0]=Log[1]=0; for (i=2;i&lt;=MAXN;i++) Log[i]=Log[i&gt;&gt;1]+1;&#125;inline int query_ST(int l,int r)&#123; int k=r-l+1; return max(maxn[l][Log[k]],maxn[r-(1&lt;&lt;Log[k])+1][Log[k]]);&#125;inline int find(int pos,int cmp)&#123; int l=pos,r=n,mid,res=-1; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (query_ST(pos,mid)&gt;cmp) res=mid,r=mid-1; else l=mid+1; &#125; return res;&#125;int dp[MAXN+48];inline void init_dp()&#123; for (register int i=n;i&gt;=1;i--) &#123; dp[i]=1; int res=find(i+1,a[i]); if (res!=-1) dp[i]+=dp[res]; &#125;&#125;int seq[MAXN+48],tot;inline int bsearch(int cmp)&#123; int l=1,r=tot,res=0,mid; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if (seq[mid]&gt;=cmp) r=mid-1; else res=mid,l=mid+1; &#125; return res;&#125;int main ()&#123; int ca;io.Get(ca);int i,pos,nv; while (ca--) &#123; io.Get(n);io.Get(m); for (i=1;i&lt;=n;i++) io.Get(a[i]); construct_ST();init_dp();tot=0; seq[++tot]=1; for (i=2;i&lt;=n;i++) if (a[i]&gt;a[seq[tot]]) seq[++tot]=i; while (m--) &#123; io.Get(pos);io.Get(nv); int pp=bsearch(pos),ans=pp; if (!pp || a[seq[pp]]&lt;nv) &#123; ans++; int res=find(pos+1,nv); if (res!=-1) ans+=dp[res]; &#125; else &#123; int res=find(pos+1,a[seq[pp]]); if (res!=-1) ans+=dp[res]; &#125; io.Print(ans); &#125; &#125; io.flush();return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>常用技术</category>
        <category>数据结构</category>
        <category>ST表</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>2018多校</tag>
        <tag>ST表</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #1019B]The hat 题解]]></title>
    <url>%2Fblog%2Fcf1019b%2F</url>
    <content type="text"><![CDATA[DescriptionThis is an interactive problem. Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice. As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists. You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions. InputAt the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students. You are allowed to ask no more than 60 questions. OutputTo ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109). When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn’t exist, you should output «! -1». In both cases you should immediately terminate the program. The query that contains your answer is not counted towards the limit of 60 queries. Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language. HackingUse the following format for hacking: In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students. In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or - 1. The hacked solution will not have direct access to the sequence ai. Examplesinput 822 output ? 4? 8! 4 input 6123210 output ? 1? 2? 3? 4? 5? 6! -1 NoteInput-output in statements illustrates example interaction. In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2 In the second sample the selection sequence is 1, 2, 3, 2, 1, 0. Solution交互题毁我青春……本人不擅长做动脑子的题，这个花了整场比赛才做出来，于是rnk在2题里面垫底。。。 既然次数只有60次，感觉每次肯定要查询相对的两个人，相当于查询30组，估计是二分相关 我们永远考虑位置相对的两个扇形，设上面的扇形上的数字从a到A,下面的扇形上的数字从b到B 通过仔细的观察，我们能发现一些结论： 如果$abs(a-b)\equiv 1(mod 2)$，那么这两个扇形区域内必然没有任何一组数相等 如果$a&gt;b$且$A&lt;B$，那这两个扇形区域内必然有一组数相等 如果(a,A),(b,B)两个区间不相交，那么这两个扇形区域内必然没有任何一组数相等 进而我们可以发现，对于相对的两个扇形，我们二分出中间的一条线，把他们切成两组扇形，这两组扇形要么有一组铁定无解，要么至少有一组铁定有解，无论是哪一种情况，我们都可以把另一半扔掉，在必定有解的那一半里继续二分 这就是大概的思路了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define LB long double#define ull unsigned long long#define x first#define y second#define pb push_back#define pf push_front#define mp make_pair#define Pair pair&lt;int,int&gt;#define pLL pair&lt;LL,LL&gt;#define pii pair&lt;double,double&gt;const int INF=2e9;const LL LINF=2e16;const int magic=348;const int MOD=998244353;const double eps=1e-10;const double pi=acos(-1);inline int getint()&#123; bool f;char ch;int res; while (!isdigit(ch=getchar()) &amp;&amp; ch!='-') &#123;&#125; if (ch=='-') f=false,res=0; else f=true,res=ch-'0'; while (isdigit(ch=getchar())) res=res*10+ch-'0'; return f?res:-res;&#125;int n;int a,A,b,B,m,M;inline int myabs(int x) &#123;return x&gt;=0?x:-x;&#125;inline bool check_invalid()&#123; if (myabs(a-b)%2==0) return false; if (myabs(A-B)%2==0) return false; return true;&#125;inline bool Contain(int l1,int r1,int l2,int r2)&#123; if (l1&gt;l2 &amp;&amp; r1&lt;r2) return true; if (l1&lt;l2 &amp;&amp; r1&gt;r2) return true; return false;&#125;inline bool Away(int l1,int r1,int l2,int r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return r1&lt;l2 || r2&lt;l1;&#125;int main ()&#123; n=getint(); if (n==2) &#123; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? 2\n");fflush(stdout);scanf("%d",&amp;A); if (a==A) printf("! 1\n"); else printf("! -1\n"); return 0; &#125; int la=1,lA=n/2; printf("? 1\n");fflush(stdout);scanf("%d",&amp;a); printf("? %d\n",lA);fflush(stdout);scanf("%d",&amp;A); printf("? %d\n",la+n/2);fflush(stdout);scanf("%d",&amp;b); printf("? %d\n",lA+n/2);fflush(stdout);scanf("%d",&amp;B); if (a==b) &#123; printf("! 1\n"); return 0; &#125; if (A==B) &#123; printf("! %d\n",lA); return 0; &#125; if (check_invalid()) &#123;printf("! -1\n");return 0;&#125; while (lA-la&gt;1) &#123; int mid=(la+lA)&gt;&gt;1,to=mid+n/2; printf("? %d\n",mid);fflush(stdout);scanf("%d",&amp;m); printf("? %d\n",to);fflush(stdout);scanf("%d",&amp;M); if (m==M) &#123; printf("! %d\n",mid); return 0; &#125; if (Contain(a,m,b,M)) &#123;lA=mid;A=m;B=M;continue;&#125; if (Contain(m,A,M,B)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(a,m,b,M)) &#123;la=mid;a=m;b=M;continue;&#125; if (Away(m,A,M,B)) &#123;lA=mid;A=m;B=M;continue;&#125; &#125; if (a==b) &#123;printf("! %d\n",la);return 0;&#125; if (A==B) &#123;printf("! %d\n",lA);return 0;&#125; printf("! -1\n");return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
        <category>交互题</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
</search>
